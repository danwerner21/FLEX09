|===========================================================================|
Objects : -
propIO
   |
   +--VGA_1024
   |      |
   |      +---vga_Hires_Text
   |
   +--hc11_Ports
   |
   +--Keyboard
   |
   +--fsrw
        |
        +-safe_spi

Object Address : 0010 : Object Name : propIO
Object Address : 03D8 : Object Name : VGA_1024
Object Address : 0DD8 : Object Name : vga_Hires_Text
Object Address : 16B4 : Object Name : hc11_Ports
Object Address : 1964 : Object Name : Keyboard
Object Address : 1F98 : Object Name : fsrw
Object Address : 2904 : Object Name : safe_spi

Binary Image Information :
PBASE : 0010
VBASE : 3130
DBASE : 4530
PCURR : 0044
DCURR : 4534
|===========================================================================|
|===========================================================================|
Object propIO
Object Base is 0010
|===========================================================================|
Object Constants
|===========================================================================|
Constant _clkmode = 00000408 (1032)
Constant _xinfreq = 004C4B40 (5000000)
Constant video_base = 00000010 (16)
Constant TURQUOISE = 00000029 (41)
Constant BLUE = 00000027 (39)
Constant BABYBLUE = 00000095 (149)
Constant RED = 000000C1 (193)
Constant GREEN = 00000099 (153)
Constant GOLDBROWN = 000000A2 (162)
Constant AMBERDARK = 000000E2 (226)
Constant LAVENDER = 000000A5 (165)
Constant WHITE = 000000FF (255)
Constant HOTPINK = 000000C9 (201)
Constant GOLD = 000000D9 (217)
Constant PINK = 000000C5 (197)
Constant spiDO = 00000018 (24)
Constant spiClk = 00000019 (25)
Constant spiDI = 0000001A (26)
Constant spiCS = 0000001B (27)
Constant DSKREAD = 00000001 (1)
Constant DSKWRITE = 00000002 (2)
Constant DSKREQUEST = 000000EE (238)
Constant DSKIODONE = 000000AA (170)
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable x
VBASE : 0004 LONG Size 002C Variable CLR
VBASE : 0030 LONG Size 0004 Variable temp
VBASE : 0034 LONG Size 0004 Variable status
VBASE : 0038 LONG Size 0004 Variable dsk_status
VBASE : 003C LONG Size 0004 Variable dsk_request
VBASE : 0040 LONG Size 0004 Variable keyboard
VBASE : 0044 LONG Size 0040 Variable drive_base
VBASE : 0084 LONG Size 0004 Variable sd_block_number
VBASE : 0088 LONG Size 0004 Variable current_block_number
VBASE : 008C LONG Size 0004 Variable block_offset
VBASE : 0090 LONG Size 0004 Variable sector_offset
VBASE : 0094 LONG Size 0004 Variable sector_number
VBASE : 0098 LONG Size 0004 Variable err
VBASE : 009C LONG Size 0004 Variable i
VBASE : 00A0 LONG Size 0004 Variable j
VBASE : 00A4 LONG Size 0004 Variable k
VBASE : 00A8 LONG Size 0004 Variable index
VBASE : 00AC BYTE Size 0208 Variable disk_buff
VBASE : 02B4 BYTE Size 0001 Variable ch
VBASE : 02B5 BYTE Size 0001 Variable disk_command
VBASE : 02B6 BYTE Size 0001 Variable drive_number
|===========================================================================|
|===========================================================================|
Spin Block main with 0 Parameters and 0 Extra Stack Longs. Method 1
PUB   main

Local Parameter DBASE:0000 - Result
|===========================================================================|
Addr : 0044:          38 29  : Constant 1 Bytes - 29 - $00000029 41
# Source File : ./propIO.spin
78                        CLR[1]:=TURQUOISE
Addr : 0046:             36  : Constant 2 $00000001
Addr : 0047:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0049:          38 27  : Constant 1 Bytes - 27 - $00000027 39
79                        CLR[2]:=BLUE
Addr : 004B:          37 00  : Constant Mask Y=0 00000002 2
Addr : 004D:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 004F:          38 95  : Constant 1 Bytes - 95 - $00000095 149
80                        CLR[3]:=BABYBLUE
Addr : 0051:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 0053:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0055:          38 C1  : Constant 1 Bytes - C1 - $000000C1 193
81                        CLR[4]:=RED
Addr : 0057:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0059:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 005B:          38 99  : Constant 1 Bytes - 99 - $00000099 153
82                        CLR[5]:=GREEN
Addr : 005D:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 005F:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0061:          38 A2  : Constant 1 Bytes - A2 - $000000A2 162
83                        CLR[6]:=GOLDBROWN
Addr : 0063:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 0065:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0067:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
84                        CLR[7]:=WHITE
Addr : 0069:          37 22  : Constant Mask Y=34 Decrement 00000007 7
Addr : 006B:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 006D:          38 C9  : Constant 1 Bytes - C9 - $000000C9 201
85                        CLR[8]:=HOTPINK
Addr : 006F:          37 02  : Constant Mask Y=2 00000008 8
Addr : 0071:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0073:          38 D9  : Constant 1 Bytes - D9 - $000000D9 217
86                        CLR[9]:=GOLD
Addr : 0075:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 0077:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 0079:          38 C5  : Constant 1 Bytes - C5 - $000000C5 197
87                        CLR[10]:=PINK
Addr : 007B:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 007D:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 007F:          38 E2  : Constant 1 Bytes - E2 - $000000E2 226
88                        CLR[11]:=AMBERDARK
Addr : 0081:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 0083:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
90                        status := 0
Addr : 0085:             35  : Constant 1 $00000000
Addr : 0086:          C9 34  : Memory Op Long VBASE + WRITE Address = 0034
92                        txt.start(video_base)
Addr : 0088:             01  : Drop Anchor   
Addr : 0089:          37 03  : Constant Mask Y=3 00000010 16
Addr : 008B:       06 09 01  : Call Obj.Sub 9 1
93                        txt.color(CLR[5])
Addr : 008E:             01  : Drop Anchor   
Addr : 008F:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 0091:          D8 04  : Memory Op Long VBASE + POP Index READ Address = 0004
Addr : 0093:       06 09 03  : Call Obj.Sub 9 3
95                        txt.cls1(9600, 5, 1, 0, 0)
Addr : 0096:             01  : Drop Anchor   
Addr : 0097:       39 25 80  : Constant 2 Bytes - 25 80 - $00002580 9600
Addr : 009A:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 009C:             36  : Constant 2 $00000001
Addr : 009D:             35  : Constant 1 $00000000
Addr : 009E:             35  : Constant 1 $00000000
Addr : 009F:       06 09 06  : Call Obj.Sub 9 6
96                        txt.inv(0)
Addr : 00A2:             01  : Drop Anchor   
Addr : 00A3:             35  : Constant 1 $00000000
Addr : 00A4:       06 09 02  : Call Obj.Sub 9 2
97                        txt.cursorset(5)
Addr : 00A7:             01  : Drop Anchor   
Addr : 00A8:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 00AA:       06 09 04  : Call Obj.Sub 9 4
99                        kb.start(14,15)
Addr : 00AD:             01  : Drop Anchor   
Addr : 00AE:          38 0E  : Constant 1 Bytes - 0E - $0000000E 14
Addr : 00B0:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 00B2:       06 0B 01  : Call Obj.Sub 11 1
100                        txt.str(string("starting propIO"))
Addr : 00B5:             01  : Drop Anchor   
Addr : 00B6: PBASE Constant Address of Label0002
Addr : 00B6:       87 81 B8  : Memory Op Byte PBASE + ADDRESS Address = 01B8
Addr : 00B9:       06 09 09  : Call Obj.Sub 9 9
101                        crlf
Addr : 00BC:             01  : Drop Anchor   
Addr : 00BD:          05 05  : Call Sub 5    
102                        FindSDblock
Addr : 00BF:             01  : Drop Anchor   
Addr : 00C0:          05 02  : Call Sub 2    
103                        txt.str(string(" after findSD "))
Addr : 00C2:             01  : Drop Anchor   
Addr : 00C3: PBASE Constant Address of Label0003
Addr : 00C3:       87 81 C8  : Memory Op Byte PBASE + ADDRESS Address = 01C8
Addr : 00C6:       06 09 09  : Call Obj.Sub 9 9
104                        crlf
Addr : 00C9:             01  : Drop Anchor   
Addr : 00CA:          05 05  : Call Sub 5    
105                        port.start
Addr : 00CC:             01  : Drop Anchor   
Addr : 00CD:       06 0A 01  : Call Obj.Sub 10 1
106                        current_block_number := 0
Addr : 00D0:             35  : Constant 1 $00000000
Addr : 00D1:       C9 80 88  : Memory Op Long VBASE + WRITE Address = 0088
108                        j := @disk_buff
Addr : 00D4:       8B 80 AC  : Memory Op Byte VBASE + ADDRESS Address = 00AC
Addr : 00D7:       C9 80 A0  : Memory Op Long VBASE + WRITE Address = 00A0
109                        txt.str(string("Disk buffer start = "))
Addr : 00DA:             01  : Drop Anchor   
Addr : 00DB: PBASE Constant Address of Label0004
Addr : 00DB:       87 81 D7  : Memory Op Byte PBASE + ADDRESS Address = 01D7
Addr : 00DE:       06 09 09  : Call Obj.Sub 9 9
110                        txt.hex(j,4)
Addr : 00E1:             01  : Drop Anchor   
Addr : 00E2:       C8 80 A0  : Memory Op Long VBASE + READ Address = 00A0
Addr : 00E5:          37 01  : Constant Mask Y=1 00000004 4
Addr : 00E7:       06 09 08  : Call Obj.Sub 9 8
111                        crlf
Addr : 00EA:             01  : Drop Anchor   
Addr : 00EB:          05 05  : Call Sub 5    
112                        i := 0
Addr : 00ED:             35  : Constant 1 $00000000
Addr : 00EE:       C9 80 9C  : Memory Op Long VBASE + WRITE Address = 009C
Addr : 00F1: Label0005
114                          disk_command := port.get_disk_command
Addr : 00F1:             00  : Drop Anchor Push 
Addr : 00F2:       06 0A 05  : Call Obj.Sub 10 5
Addr : 00F5:       89 82 B5  : Memory Op Byte VBASE + WRITE Address = 02B5
115                          if disk_command ==  DSKREQUEST
Addr : 00F8:       88 82 B5  : Memory Op Byte VBASE + READ Address = 02B5
Addr : 00FB:          38 EE  : Constant 1 Bytes - EE - $000000EE 238
Addr : 00FD:             FC  : Math Op ==    
Addr : 00FE: JZ Label0008
Addr : 00FE:          0A 0B  : jz Address = 010B 11
116                              port.set_disk_command(0)
Addr : 0100:             01  : Drop Anchor   
Addr : 0101:             35  : Constant 1 $00000000
Addr : 0102:       06 0A 06  : Call Obj.Sub 10 6
117                              port.set_disk_status(4)
Addr : 0105:             01  : Drop Anchor   
Addr : 0106:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0108:       06 0A 07  : Call Obj.Sub 10 7
Addr : 010B: Label0008
Addr : 010B: Label0009
119                          dsk_status := port.get_disk_status
Addr : 010B:             00  : Drop Anchor Push 
Addr : 010C:       06 0A 08  : Call Obj.Sub 10 8
Addr : 010F:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
120                          if dsk_status == $80
Addr : 0111:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0113:          37 06  : Constant Mask Y=6 00000080 128
Addr : 0115:             FC  : Math Op ==    
Addr : 0116: JZ Label000A
Addr : 0116:          0A 21  : jz Address = 0139 33
121                            disk_command := port.get_disk_command
Addr : 0118:             00  : Drop Anchor Push 
Addr : 0119:       06 0A 05  : Call Obj.Sub 10 5
Addr : 011C:       89 82 B5  : Memory Op Byte VBASE + WRITE Address = 02B5
122                            if disk_command == DSKREAD
Addr : 011F:       88 82 B5  : Memory Op Byte VBASE + READ Address = 02B5
Addr : 0122:             36  : Constant 2 $00000001
Addr : 0123:             FC  : Math Op ==    
Addr : 0124: JZ Label000C
Addr : 0124:          0A 08  : jz Address = 012E 8
123                              port.set_disk_command(0)
Addr : 0126:             01  : Drop Anchor   
Addr : 0127:             35  : Constant 1 $00000000
Addr : 0128:       06 0A 06  : Call Obj.Sub 10 6
124                              disk_read
Addr : 012B:             01  : Drop Anchor   
Addr : 012C:          05 06  : Call Sub 6    
Addr : 012E: Label000C
Addr : 012E: Label000D
125                            if disk_command == DSKWRITE
Addr : 012E:       88 82 B5  : Memory Op Byte VBASE + READ Address = 02B5
Addr : 0131:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0133:             FC  : Math Op ==    
Addr : 0134: JZ Label000E
Addr : 0134:          0A 03  : jz Address = 0139 3
126                              disk_write
Addr : 0136:             01  : Drop Anchor   
Addr : 0137:          05 07  : Call Sub 7    
Addr : 0139: Label000E
Addr : 0139: Label000F
Addr : 0139: Label000A
Addr : 0139: Label000B
127                          temp := port.get_status                             'see if we are ready for another key
Addr : 0139:             00  : Drop Anchor Push 
Addr : 013A:       06 0A 04  : Call Obj.Sub 10 4
Addr : 013D:          C9 30  : Memory Op Long VBASE + WRITE Address = 0030
128                          if temp <> 1                                        'if 0 then we can send another key if in buffer
Addr : 013F:          C8 30  : Memory Op Long VBASE + READ Address = 0030
Addr : 0141:             36  : Constant 2 $00000001
Addr : 0142:             FB  : Math Op <>    
Addr : 0143: JZ Label0010
Addr : 0143:       0A 80 5D  : jz Address = 01A3 93
129                            if kb.gotkey                                      'check to see if key in buffer
Addr : 0146:             00  : Drop Anchor Push 
Addr : 0147:       06 0B 06  : Call Obj.Sub 11 6
Addr : 014A: JZ Label0012
Addr : 014A:       0A 80 56  : jz Address = 01A3 86
130                              keyboard := kb.getkey                           'yes so stuff it in key and
Addr : 014D:             00  : Drop Anchor Push 
Addr : 014E:       06 0B 05  : Call Obj.Sub 11 5
Addr : 0151:          C9 40  : Memory Op Long VBASE + WRITE Address = 0040
135                              if keyboard > 576
Addr : 0153:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 0155:       39 02 40  : Constant 2 Bytes - 02 40 - $00000240 576
Addr : 0158:             FA  : Math Op >     
Addr : 0159: JZ Label0014
Addr : 0159:          0A 10  : jz Address = 016B 16
136                                if keyboard < 603
Addr : 015B:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 015D:       39 02 5B  : Constant 2 Bytes - 02 5B - $0000025B 603
Addr : 0160:             F9  : Math Op <     
Addr : 0161: JZ Label0016
Addr : 0161:          0A 08  : jz Address = 016B 8
137                                  keyboard := keyboard - 576
Addr : 0163:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 0165:       39 02 40  : Constant 2 Bytes - 02 40 - $00000240 576
Addr : 0168:             ED  : Math Op -     
Addr : 0169:          C9 40  : Memory Op Long VBASE + WRITE Address = 0040
Addr : 016B: Label0016
Addr : 016B: Label0017
Addr : 016B: Label0014
Addr : 016B: Label0015
138                              if keyboard > 608 and keyboard < 635
Addr : 016B:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 016D:       39 02 60  : Constant 2 Bytes - 02 60 - $00000260 608
Addr : 0170:             FA  : Math Op >     
Addr : 0171:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 0173:       39 02 7B  : Constant 2 Bytes - 02 7B - $0000027B 635
Addr : 0176:             F9  : Math Op <     
Addr : 0177:             F0  : Math Op AND   
Addr : 0178: JZ Label0018
Addr : 0178:          0A 08  : jz Address = 0182 8
139                                keyboard := keyboard - 608
Addr : 017A:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 017C:       39 02 60  : Constant 2 Bytes - 02 60 - $00000260 608
Addr : 017F:             ED  : Math Op -     
Addr : 0180:          C9 40  : Memory Op Long VBASE + WRITE Address = 0040
Addr : 0182: Label0018
Addr : 0182: Label0019
140                              if keyboard == 200
Addr : 0182:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 0184:          38 C8  : Constant 1 Bytes - C8 - $000000C8 200
Addr : 0186:             FC  : Math Op ==    
Addr : 0187: JZ Label001A
Addr : 0187:          0A 04  : jz Address = 018D 4
141                                keyboard := 08
Addr : 0189:          37 02  : Constant Mask Y=2 00000008 8
Addr : 018B:          C9 40  : Memory Op Long VBASE + WRITE Address = 0040
Addr : 018D: Label001A
Addr : 018D: Label001B
142                              if keyboard == 203
Addr : 018D:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 018F:          38 CB  : Constant 1 Bytes - CB - $000000CB 203
Addr : 0191:             FC  : Math Op ==    
Addr : 0192: JZ Label001C
Addr : 0192:          0A 04  : jz Address = 0198 4
143                                keyboard := 27
Addr : 0194:          38 1B  : Constant 1 Bytes - 1B - $0000001B 27
Addr : 0196:          C9 40  : Memory Op Long VBASE + WRITE Address = 0040
Addr : 0198: Label001C
Addr : 0198: Label001D
145                              port.set_key(keyboard) 
Addr : 0198:             01  : Drop Anchor   
Addr : 0199:          C8 40  : Memory Op Long VBASE + READ Address = 0040
Addr : 019B:       06 0A 0D  : Call Obj.Sub 10 13
146                              port.set_status(1)                               'set status that we have a key
Addr : 019E:             01  : Drop Anchor   
Addr : 019F:             36  : Constant 2 $00000001
Addr : 01A0:       06 0A 03  : Call Obj.Sub 10 3
Addr : 01A3: Label0012
Addr : 01A3: Label0013
Addr : 01A3: Label0010
Addr : 01A3: Label0011
148                          ch := port.vga_check                                 'see if N8VEM has output a character
Addr : 01A3:             00  : Drop Anchor Push 
Addr : 01A4:       06 0A 0E  : Call Obj.Sub 10 14
Addr : 01A7:       89 82 B4  : Memory Op Byte VBASE + WRITE Address = 02B4
149                          if ch <> 255
Addr : 01AA:       88 82 B4  : Memory Op Byte VBASE + READ Address = 02B4
Addr : 01AD:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
Addr : 01AF:             FB  : Math Op <>    
Addr : 01B0: JZ Label001E
Addr : 01B0:          0A 12  : jz Address = 01C4 18
150                            txt.process_char(ch)
Addr : 01B2:             01  : Drop Anchor   
Addr : 01B3:       88 82 B4  : Memory Op Byte VBASE + READ Address = 02B4
Addr : 01B6:       06 09 15  : Call Obj.Sub 9 21
151                            ch := -1
Addr : 01B9:             34  : Constant 0 $FFFFFFFF
Addr : 01BA:       89 82 B4  : Memory Op Byte VBASE + WRITE Address = 02B4
152                            waitcnt(5_000 + cnt)
Addr : 01BD:       39 13 88  : Constant 2 Bytes - 13 88 - $00001388 5000
Addr : 01C0:          3F 91  : Register op CNT Read
Addr : 01C2:             EC  : Math Op +     
Addr : 01C3:             23  : WaitCnt(count)
Addr : 01C4: Label001E
Addr : 01C4: Label001F
Addr : 01C4: Label0006
Addr : 01C4: JMP Label0005
Addr : 01C4:       04 FF 2A  : Jmp 00F1 -214 
Addr : 01C7: Label0007
Addr : 01C7:             32  : Return        
Addr : 01C8: Label0002
Addr : 01C8: Data : 73 74 61 72 74 69 6E 67  starting
Addr : 01D0: Data : 20 70 72 6F 70 49 4F 00   propIO.
Addr : 01D8: Data :                          
Addr : 01D8: Label0003
Addr : 01D8: Data : 20 61 66 74 65 72 20 66   after f
Addr : 01E0: Data : 69 6E 64 53 44 20 00     indSD .
Addr : 01E7: Label0004
Addr : 01E7: Data : 44 69 73 6B 20 62 75 66  Disk buf
Addr : 01EF: Data : 66 65 72 20 73 74 61 72  fer star
Addr : 01F7: Data : 74 20 3D 20 00           t = .
|===========================================================================|
Spin Block FindSDblock with 0 Parameters and 1 Extra Stack Longs. Method 2
PRI FindSDblock | r

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - r
|===========================================================================|
156                        txt.str(string(" before mount "))
Addr : 01FC:             01  : Drop Anchor   
Addr : 01FD: PBASE Constant Address of Label0002
Addr : 01FD:       87 82 3A  : Memory Op Byte PBASE + ADDRESS Address = 023A
Addr : 0200:       06 09 09  : Call Obj.Sub 9 9
157                        crlf
Addr : 0203:             01  : Drop Anchor   
Addr : 0204:          05 05  : Call Sub 5    
158                        r := sd.mount_explicit(spiDO, spiClk, spiDI, spiCS)
Addr : 0206:             00  : Drop Anchor Push 
Addr : 0207:          38 18  : Constant 1 Bytes - 18 - $00000018 24
Addr : 0209:          38 19  : Constant 1 Bytes - 19 - $00000019 25
Addr : 020B:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 020D:          38 1B  : Constant 1 Bytes - 1B - $0000001B 27
Addr : 020F:       06 0C 05  : Call Obj.Sub 12 5
Addr : 0212:             65  : Variable Operation Local Offset - 1 Write
159                        txt.str(string(" After mount "))
Addr : 0213:             01  : Drop Anchor   
Addr : 0214: PBASE Constant Address of Label0003
Addr : 0214:       87 82 49  : Memory Op Byte PBASE + ADDRESS Address = 0249
Addr : 0217:       06 09 09  : Call Obj.Sub 9 9
160                        crlf
Addr : 021A:             01  : Drop Anchor   
Addr : 021B:          05 05  : Call Sub 5    
161                        CheckError(r)
Addr : 021D:             01  : Drop Anchor   
Addr : 021E:             64  : Variable Operation Local Offset - 1 Read
Addr : 021F:          05 04  : Call Sub 4    
162                        txt.str(string(" in FindSDblock"))
Addr : 0221:             01  : Drop Anchor   
Addr : 0222: PBASE Constant Address of Label0004
Addr : 0222:       87 82 57  : Memory Op Byte PBASE + ADDRESS Address = 0257
Addr : 0225:       06 09 09  : Call Obj.Sub 9 9
163                        crlf
Addr : 0228:             01  : Drop Anchor   
Addr : 0229:          05 05  : Call Sub 5    
164                        FindDriveBase(0, string("FLEX_1.DSK"))
Addr : 022B:             01  : Drop Anchor   
Addr : 022C:             35  : Constant 1 $00000000
Addr : 022D: PBASE Constant Address of Label0005
Addr : 022D:       87 82 67  : Memory Op Byte PBASE + ADDRESS Address = 0267
Addr : 0230:          05 03  : Call Sub 3    
165                        FindDriveBase(1, string("FLEX_2.DSK"))
Addr : 0232:             01  : Drop Anchor   
Addr : 0233:             36  : Constant 2 $00000001
Addr : 0234: PBASE Constant Address of Label0006
Addr : 0234:       87 82 72  : Memory Op Byte PBASE + ADDRESS Address = 0272
Addr : 0237:          05 03  : Call Sub 3    
166                        FindDriveBase(2, string("FLEX_3.DSK"))
Addr : 0239:             01  : Drop Anchor   
Addr : 023A:          37 00  : Constant Mask Y=0 00000002 2
Addr : 023C: PBASE Constant Address of Label0007
Addr : 023C:       87 82 7D  : Memory Op Byte PBASE + ADDRESS Address = 027D
Addr : 023F:          05 03  : Call Sub 3    
167                        FindDriveBase(3, string("FLEX_4.DSK"))
Addr : 0241:             01  : Drop Anchor   
Addr : 0242:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 0244: PBASE Constant Address of Label0008
Addr : 0244:       87 82 88  : Memory Op Byte PBASE + ADDRESS Address = 0288
Addr : 0247:          05 03  : Call Sub 3    
Addr : 0249:             32  : Return        
Addr : 024A: Label0002
Addr : 024A: Data : 20 62 65 66 6F 72 65 20   before 
Addr : 0252: Data : 6D 6F 75 6E 74 20 00     mount .
Addr : 0259: Label0003
Addr : 0259: Data : 20 41 66 74 65 72 20 6D   After m
Addr : 0261: Data : 6F 75 6E 74 20 00        ount .
Addr : 0267: Label0004
Addr : 0267: Data : 20 69 6E 20 46 69 6E 64   in Find
Addr : 026F: Data : 53 44 62 6C 6F 63 6B 00  SDblock.
Addr : 0277: Data :                          
Addr : 0277: Label0005
Addr : 0277: Data : 46 4C 45 58 5F 31 2E 44  FLEX_1.D
Addr : 027F: Data : 53 4B 00                 SK.
Addr : 0282: Label0006
Addr : 0282: Data : 46 4C 45 58 5F 32 2E 44  FLEX_2.D
Addr : 028A: Data : 53 4B 00                 SK.
Addr : 028D: Label0007
Addr : 028D: Data : 46 4C 45 58 5F 33 2E 44  FLEX_3.D
Addr : 0295: Data : 53 4B 00                 SK.
Addr : 0298: Label0008
Addr : 0298: Data : 46 4C 45 58 5F 34 2E 44  FLEX_4.D
Addr : 02A0: Data : 53 4B 00                 SK.
|===========================================================================|
Spin Block FindDriveBase with 2 Parameters and 1 Extra Stack Longs. Method 3
PRI FindDriveBase(n, st) | r

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - n
Local Parameter DBASE:0008 - st
Local Variable  DBASE:000C - r
|===========================================================================|
170                        r := sd.popen(st, "r")
Addr : 02A3:             00  : Drop Anchor Push 
Addr : 02A4:             68  : Variable Operation Local Offset - 2 Read
Addr : 02A5:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 02A7:       06 0C 08  : Call Obj.Sub 12 8
Addr : 02AA:             6D  : Variable Operation Local Offset - 3 Write
171                        CheckError(r)
Addr : 02AB:             01  : Drop Anchor   
Addr : 02AC:             6C  : Variable Operation Local Offset - 3 Read
Addr : 02AD:          05 04  : Call Sub 4    
172                        drive_base[n] := sd.getSDdatablock
Addr : 02AF:             00  : Drop Anchor Push 
Addr : 02B0:       06 0C 03  : Call Obj.Sub 12 3
Addr : 02B3:             64  : Variable Operation Local Offset - 1 Read
Addr : 02B4:          D9 44  : Memory Op Long VBASE + POP Index WRITE Address = 0044
173                        txt.str(st)
Addr : 02B6:             01  : Drop Anchor   
Addr : 02B7:             68  : Variable Operation Local Offset - 2 Read
Addr : 02B8:       06 09 09  : Call Obj.Sub 9 9
174                        txt.str(string("  = "))
Addr : 02BB:             01  : Drop Anchor   
Addr : 02BC: PBASE Constant Address of Label0002
Addr : 02BC:       87 82 BF  : Memory Op Byte PBASE + ADDRESS Address = 02BF
Addr : 02BF:       06 09 09  : Call Obj.Sub 9 9
175                        txt.hex(drive_base[n],4)
Addr : 02C2:             01  : Drop Anchor   
Addr : 02C3:             64  : Variable Operation Local Offset - 1 Read
Addr : 02C4:          D8 44  : Memory Op Long VBASE + POP Index READ Address = 0044
Addr : 02C6:          37 01  : Constant Mask Y=1 00000004 4
Addr : 02C8:       06 09 08  : Call Obj.Sub 9 8
176                        crlf
Addr : 02CB:             01  : Drop Anchor   
Addr : 02CC:          05 05  : Call Sub 5    
Addr : 02CE:             32  : Return        
Addr : 02CF: Label0002
Addr : 02CF: Data : 20 20 3D 20 00             = .
|===========================================================================|
Spin Block CheckError with 1 Parameters and 0 Extra Stack Longs. Method 4
PRI CheckError(r)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - r
|===========================================================================|
179                        if r < 0
Addr : 02D4:             64  : Variable Operation Local Offset - 1 Read
Addr : 02D5:             35  : Constant 1 $00000000
Addr : 02D6:             F9  : Math Op <     
Addr : 02D7: JZ Label0002
Addr : 02D7:          0A 1C  : jz Address = 02F5 28
180                          txt.str(string("****Error*** $"))
Addr : 02D9:             01  : Drop Anchor   
Addr : 02DA: PBASE Constant Address of Label0004
Addr : 02DA:       87 82 E6  : Memory Op Byte PBASE + ADDRESS Address = 02E6
Addr : 02DD:       06 09 09  : Call Obj.Sub 9 9
181                          txt.dec(r)
Addr : 02E0:             01  : Drop Anchor   
Addr : 02E1:             64  : Variable Operation Local Offset - 1 Read
Addr : 02E2:       06 09 07  : Call Obj.Sub 9 7
182                          txt.str(string("***HALTED***"))
Addr : 02E5:             01  : Drop Anchor   
Addr : 02E6: PBASE Constant Address of Label0005
Addr : 02E6:       87 82 F5  : Memory Op Byte PBASE + ADDRESS Address = 02F5
Addr : 02E9:       06 09 09  : Call Obj.Sub 9 9
183                          crlf
Addr : 02EC:             01  : Drop Anchor   
Addr : 02ED:          05 05  : Call Sub 5    
184                          sd.unmount
Addr : 02EF:             01  : Drop Anchor   
Addr : 02F0:       06 0C 04  : Call Obj.Sub 12 4
Addr : 02F3: Label0006
Addr : 02F3: Label0007
Addr : 02F3: JMP Label0006
Addr : 02F3:          04 7E  : Jmp 02F3 -2   
Addr : 02F5: Label0008
Addr : 02F5: Label0002
Addr : 02F5: Label0003
Addr : 02F5:             32  : Return        
Addr : 02F6: Label0004
Addr : 02F6: Data : 2A 2A 2A 2A 45 72 72 6F  ****Erro
Addr : 02FE: Data : 72 2A 2A 2A 20 24 00     r*** $.
Addr : 0305: Label0005
Addr : 0305: Data : 2A 2A 2A 48 41 4C 54 45  ***HALTE
Addr : 030D: Data : 44 2A 2A 2A 00           D***.
|===========================================================================|
Spin Block crlf with 0 Parameters and 0 Extra Stack Longs. Method 5
PRI crlf

Local Parameter DBASE:0000 - Result
|===========================================================================|
188                        txt.process_char(13)
Addr : 0312:             01  : Drop Anchor   
Addr : 0313:          38 0D  : Constant 1 Bytes - 0D - $0000000D 13
Addr : 0315:       06 09 15  : Call Obj.Sub 9 21
189                        txt.process_char(10)
Addr : 0318:             01  : Drop Anchor   
Addr : 0319:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 031B:       06 09 15  : Call Obj.Sub 9 21
Addr : 031E:             32  : Return        
|===========================================================================|
Spin Block disk_read with 0 Parameters and 0 Extra Stack Longs. Method 6
PRI disk_read

Local Parameter DBASE:0000 - Result
|===========================================================================|
192                        refresh_hd_cache
Addr : 031F:             01  : Drop Anchor   
Addr : 0320:          05 08  : Call Sub 8    
193                        sector_offset := @disk_buff + block_offset
Addr : 0322:       8B 80 AC  : Memory Op Byte VBASE + ADDRESS Address = 00AC
Addr : 0325:       C8 80 8C  : Memory Op Long VBASE + READ Address = 008C
Addr : 0328:             EC  : Math Op +     
Addr : 0329:       C9 80 90  : Memory Op Long VBASE + WRITE Address = 0090
194                        port.set_sector_offset(sector_offset)
Addr : 032C:             01  : Drop Anchor   
Addr : 032D:       C8 80 90  : Memory Op Long VBASE + READ Address = 0090
Addr : 0330:       06 0A 0C  : Call Obj.Sub 10 12
195                        port.set_disk_status($10)
Addr : 0333:             01  : Drop Anchor   
Addr : 0334:          37 03  : Constant Mask Y=3 00000010 16
Addr : 0336:       06 0A 07  : Call Obj.Sub 10 7
Addr : 0339:             32  : Return        
|===========================================================================|
Spin Block disk_write with 0 Parameters and 0 Extra Stack Longs. Method 7
PRI disk_write

Local Parameter DBASE:0000 - Result
|===========================================================================|
198                         refresh_hd_cache
Addr : 033A:             01  : Drop Anchor   
Addr : 033B:          05 08  : Call Sub 8    
199                         sector_offset := @disk_buff + block_offset
Addr : 033D:       8B 80 AC  : Memory Op Byte VBASE + ADDRESS Address = 00AC
Addr : 0340:       C8 80 8C  : Memory Op Long VBASE + READ Address = 008C
Addr : 0343:             EC  : Math Op +     
Addr : 0344:       C9 80 90  : Memory Op Long VBASE + WRITE Address = 0090
213                         port.set_sector_offset(sector_offset)
Addr : 0347:             01  : Drop Anchor   
Addr : 0348:       C8 80 90  : Memory Op Long VBASE + READ Address = 0090
Addr : 034B:       06 0A 0C  : Call Obj.Sub 10 12
214                         port.set_disk_status($10)
Addr : 034E:             01  : Drop Anchor   
Addr : 034F:          37 03  : Constant Mask Y=3 00000010 16
Addr : 0351:       06 0A 07  : Call Obj.Sub 10 7
216                         dsk_status := port.get_disk_command
Addr : 0354:             00  : Drop Anchor Push 
Addr : 0355:       06 0A 05  : Call Obj.Sub 10 5
Addr : 0358:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 035A: Label0003
217                         repeat until dsk_status == DSKIODONE
Addr : 035A:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 035C:          38 AA  : Constant 1 Bytes - AA - $000000AA 170
Addr : 035E:             FC  : Math Op ==    
Addr : 035F: JNZ Label0005
Addr : 035F:          0B 08  : jnz Address = 0369 8
221                           dsk_status := port.get_disk_command
Addr : 0361:             00  : Drop Anchor Push 
Addr : 0362:       06 0A 05  : Call Obj.Sub 10 5
Addr : 0365:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0367: Label0004
Addr : 0367: JMP Label0003
Addr : 0367:          04 71  : Jmp 035A -15  
Addr : 0369: Label0005
225                         err := \sd.writeSDCard(sd_block_number, @disk_buff, 512)
Addr : 0369:             02  : Drop Anchor Push Try
Addr : 036A:       C8 80 84  : Memory Op Long VBASE + READ Address = 0084
Addr : 036D:       8B 80 AC  : Memory Op Byte VBASE + ADDRESS Address = 00AC
Addr : 0370:          37 08  : Constant Mask Y=8 00000200 512
Addr : 0372:       06 0C 02  : Call Obj.Sub 12 2
Addr : 0375:       C9 80 98  : Memory Op Long VBASE + WRITE Address = 0098
226                         CheckError(err)
Addr : 0378:             01  : Drop Anchor   
Addr : 0379:       C8 80 98  : Memory Op Long VBASE + READ Address = 0098
Addr : 037C:          05 04  : Call Sub 4    
227                         port.set_disk_status($20)
Addr : 037E:             01  : Drop Anchor   
Addr : 037F:          37 04  : Constant Mask Y=4 00000020 32
Addr : 0381:       06 0A 07  : Call Obj.Sub 10 7
Addr : 0384:             32  : Return        
|===========================================================================|
Spin Block refresh_hd_cache with 0 Parameters and 1 Extra Stack Longs. Method 8
PRI refresh_hd_cache | r

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - r
|===========================================================================|
243                        sector_number := (port.get_track_number * 32) + (port.get_sector_number)      'Find correct block for the selected track and sector
Addr : 0385:             00  : Drop Anchor Push 
Addr : 0386:       06 0A 0A  : Call Obj.Sub 10 10
Addr : 0389:          37 04  : Constant Mask Y=4 00000020 32
Addr : 038B:             F4  : Math Op *     
Addr : 038C:             00  : Drop Anchor Push 
Addr : 038D:       06 0A 0B  : Call Obj.Sub 10 11
Addr : 0390:             EC  : Math Op +     
Addr : 0391:       C9 80 94  : Memory Op Long VBASE + WRITE Address = 0094
245                        sd_block_number := sector_number >> 2                 'Determine the SD block of this sector..
Addr : 0394:       C8 80 94  : Memory Op Long VBASE + READ Address = 0094
Addr : 0397:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0399:             E2  : Math Op >>    
Addr : 039A:       C9 80 84  : Memory Op Long VBASE + WRITE Address = 0084
246                        sd_block_number += drive_base[port.get_drive_number]  'get the first sector of the selected drive
Addr : 039D:             00  : Drop Anchor Push 
Addr : 039E:       06 0A 09  : Call Obj.Sub 10 9
Addr : 03A1:          D8 44  : Memory Op Long VBASE + POP Index READ Address = 0044
Addr : 03A3:    CA 80 84 4C  : Memory Op Long VBASE + ASSIGN Address = 0084 WordMathop +
247                        block_offset := (sector_number & %11) * 128           'Determine the position of this sector within the block
Addr : 03A7:       C8 80 94  : Memory Op Long VBASE + READ Address = 0094
Addr : 03AA:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 03AC:             E8  : Math Op &     
Addr : 03AD:          37 06  : Constant Mask Y=6 00000080 128
Addr : 03AF:             F4  : Math Op *     
Addr : 03B0:       C9 80 8C  : Memory Op Long VBASE + WRITE Address = 008C
249                        if sd_block_number <> current_block_number            'If the block is not in disk buffer then load it
Addr : 03B3:       C8 80 84  : Memory Op Long VBASE + READ Address = 0084
Addr : 03B6:       C8 80 88  : Memory Op Long VBASE + READ Address = 0088
Addr : 03B9:             FB  : Math Op <>    
Addr : 03BA: JZ Label0002
Addr : 03BA:          0A 1B  : jz Address = 03D7 27
252                          err := \sd.readSDCard(sd_block_number, @disk_buff, 512)     'read the block! (complete 512 bytes)
Addr : 03BC:             02  : Drop Anchor Push Try
Addr : 03BD:       C8 80 84  : Memory Op Long VBASE + READ Address = 0084
Addr : 03C0:       8B 80 AC  : Memory Op Byte VBASE + ADDRESS Address = 00AC
Addr : 03C3:          37 08  : Constant Mask Y=8 00000200 512
Addr : 03C5:       06 0C 01  : Call Obj.Sub 12 1
Addr : 03C8:       C9 80 98  : Memory Op Long VBASE + WRITE Address = 0098
253                          CheckError(err)
Addr : 03CB:             01  : Drop Anchor   
Addr : 03CC:       C8 80 98  : Memory Op Long VBASE + READ Address = 0098
Addr : 03CF:          05 04  : Call Sub 4    
255                          current_block_number := sd_block_number           'Make this new block current
Addr : 03D1:       C8 80 84  : Memory Op Long VBASE + READ Address = 0084
Addr : 03D4:       C9 80 88  : Memory Op Long VBASE + WRITE Address = 0088
Addr : 03D7: Label0002
Addr : 03D7: Label0003
Addr : 03D7:             32  : Return        
|===========================================================================|
Object VGA_1024
Object Base is 03D8
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable sync
VBASE : 0004 LONG Size 0004 Variable loc
VBASE : 0008 LONG Size 0004 Variable xloc
VBASE : 000C LONG Size 0004 Variable yloc
VBASE : 0010 LONG Size 0004 Variable kbdreq
VBASE : 0014 LONG Size 0020 Variable BR
VBASE : 0034 LONG Size 0004 Variable Brate
VBASE : 0038 LONG Size 0004 Variable arg0
VBASE : 003C LONG Size 0004 Variable arg1
VBASE : 0040 WORD Size 0050 Variable colors
VBASE : 0090 WORD Size 0002 Variable pos
VBASE : 0092 WORD Size 0002 Variable oldpos
VBASE : 0094 WORD Size 0002 Variable regionTop
VBASE : 0096 WORD Size 0002 Variable regionBot
VBASE : 0098 WORD Size 0002 Variable statpos
VBASE : 009A BYTE Size 0C80 Variable screen
VBASE : 0D1A BYTE Size 0050 Variable tmpl
VBASE : 0D6A BYTE Size 0006 Variable cursor
VBASE : 0D70 BYTE Size 0001 Variable inverse
VBASE : 0D71 BYTE Size 0001 Variable invs
VBASE : 0D72 BYTE Size 0001 Variable state
VBASE : 0D73 BYTE Size 0001 Variable lastc
|===========================================================================|
|===========================================================================|
Spin Block start with 1 Parameters and 2 Extra Stack Longs. Method 1
PUB start(BasePin) | i, char

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - BasePin
Local Variable  DBASE:0008 - i
Local Variable  DBASE:000C - char
|===========================================================================|
47                        vga.start(BasePin, @screen, @colors, @cursor, @sync)
Addr : 0448:             01  : Drop Anchor   
Addr : 0449:             64  : Variable Operation Local Offset - 1 Read
Addr : 044A:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 044D:          AB 40  : Memory Op Word VBASE + ADDRESS Address = 0040
Addr : 044F:       8B 8D 6A  : Memory Op Byte VBASE + ADDRESS Address = 0D6A
Addr : 0452:             43  : Variable Operation Global Offset - 0 Address
Addr : 0453:       06 1B 01  : Call Obj.Sub 27 1
Addr : 0456:             35  : Constant 1 $00000000
Addr : 0457:             C0  : Memory Op Long POP Address READ 
48                        waitcnt(clkfreq * 1 + cnt)    'wait 1 second for cogs to start
Addr : 0458:             36  : Constant 2 $00000001
Addr : 0459:             F4  : Math Op *     
Addr : 045A:          3F 91  : Register op CNT Read
Addr : 045C:             EC  : Math Op +     
Addr : 045D:             23  : WaitCnt(count)
51                        repeat i from 0 to rows - 1
Addr : 045E:             35  : Constant 1 $00000000
Addr : 045F:             69  : Variable Operation Local Offset - 2 Write
Addr : 0460: Label0002
52                          colors[i] := $08F0          '$2804 (if you want cyan on blue)
Addr : 0460:       39 08 F0  : Constant 2 Bytes - 08 F0 - $000008F0 2288
Addr : 0463:             68  : Variable Operation Local Offset - 2 Read
Addr : 0464:          B9 40  : Memory Op Word VBASE + POP Index WRITE Address = 0040
Addr : 0466: Label0003
51                        repeat i from 0 to rows - 1
Addr : 0466:             35  : Constant 1 $00000000
Addr : 0467:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 0469:             36  : Constant 2 $00000001
Addr : 046A:             ED  : Math Op -     
Addr : 046B: Repeat i Step Label0002
Addr : 046B:       6A 02 72  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 0460 -14
Addr : 046E: Label0004
55                        cursor[2] := %110             ' init cursor to underscore with slow blink
Addr : 046E:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 0470:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0472:       99 8D 6A  : Memory Op Byte VBASE + POP Index WRITE Address = 0D6A
56                        BR[0]:=300 
Addr : 0475:       39 01 2C  : Constant 2 Bytes - 01 2C - $0000012C 300
Addr : 0478:             35  : Constant 1 $00000000
Addr : 0479:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
57                        BR[1]:=1200
Addr : 047B:       39 04 B0  : Constant 2 Bytes - 04 B0 - $000004B0 1200
Addr : 047E:             36  : Constant 2 $00000001
Addr : 047F:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
58                        BR[2]:=2400
Addr : 0481:       39 09 60  : Constant 2 Bytes - 09 60 - $00000960 2400
Addr : 0484:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0486:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
59                        BR[3]:=4800
Addr : 0488:       39 12 C0  : Constant 2 Bytes - 12 C0 - $000012C0 4800
Addr : 048B:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 048D:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
60                        BR[4]:=9600
Addr : 048F:       39 25 80  : Constant 2 Bytes - 25 80 - $00002580 9600
Addr : 0492:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0494:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
61                        BR[5]:=19200
Addr : 0496:       39 4B 00  : Constant 2 Bytes - 4B 00 - $00004B00 19200
Addr : 0499:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 049B:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
62                        BR[6]:=38400
Addr : 049D:       39 96 00  : Constant 2 Bytes - 96 00 - $00009600 38400
Addr : 04A0:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 04A2:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
63                        BR[7]:=57600
Addr : 04A4:       39 E1 00  : Constant 2 Bytes - E1 00 - $0000E100 57600
Addr : 04A7:          37 22  : Constant Mask Y=34 Decrement 00000007 7
Addr : 04A9:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
64                        BR[8]:=115200
Addr : 04AB:    3A 01 C2 00  : Constant 3 Bytes - 01 C2 00 - $0001C200 115200
Addr : 04AF:          37 02  : Constant Mask Y=2 00000008 8
Addr : 04B1:          D9 14  : Memory Op Long VBASE + POP Index WRITE Address = 0014
65                        xloc := cursor[0] := 0
Addr : 04B3:             35  : Constant 1 $00000000
Addr : 04B4:             35  : Constant 1 $00000000
Addr : 04B5:    9A 8D 6A 80  : Memory Op Byte VBASE + POP Index ASSIGN Address = 0D6A Write Push
Addr : 04B9:             49  : Variable Operation Global Offset - 2 Write
66                        yloc := cursor[1] := 0
Addr : 04BA:             35  : Constant 1 $00000000
Addr : 04BB:             36  : Constant 2 $00000001
Addr : 04BC:    9A 8D 6A 80  : Memory Op Byte VBASE + POP Index ASSIGN Address = 0D6A Write Push
Addr : 04C0:             4D  : Variable Operation Global Offset - 3 Write
67                        loc  := xloc + yloc*cols
Addr : 04C1:             48  : Variable Operation Global Offset - 2 Read
Addr : 04C2:             4C  : Variable Operation Global Offset - 3 Read
Addr : 04C3:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 04C5:             F4  : Math Op *     
Addr : 04C6:             EC  : Math Op +     
Addr : 04C7:             45  : Variable Operation Global Offset - 1 Write
69                        pos := 0
Addr : 04C8:             35  : Constant 1 $00000000
Addr : 04C9:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
70                        regionTop := 0
Addr : 04CC:             35  : Constant 1 $00000000
Addr : 04CD:       A9 80 94  : Memory Op Word VBASE + WRITE Address = 0094
71                        regionBot := 35 * cols
Addr : 04D0:          38 23  : Constant 1 Bytes - 23 - $00000023 35
Addr : 04D2:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 04D4:             F4  : Math Op *     
Addr : 04D5:       A9 80 96  : Memory Op Word VBASE + WRITE Address = 0096
72                        state := 0
Addr : 04D8:             35  : Constant 1 $00000000
Addr : 04D9:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
73                        statpos := 37 * cols
Addr : 04DC:          38 25  : Constant 1 Bytes - 25 - $00000025 37
Addr : 04DE:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 04E0:             F4  : Math Op *     
Addr : 04E1:       A9 80 98  : Memory Op Word VBASE + WRITE Address = 0098
Addr : 04E4:             32  : Return        
|===========================================================================|
Spin Block inv with 1 Parameters and 0 Extra Stack Longs. Method 2
PUB inv(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
76                        inverse:=c
Addr : 04E5:             64  : Variable Operation Local Offset - 1 Read
Addr : 04E6:       89 8D 70  : Memory Op Byte VBASE + WRITE Address = 0D70
Addr : 04E9:             32  : Return        
|===========================================================================|
Spin Block color with 1 Parameters and 1 Extra Stack Longs. Method 3
PUB color(colorVal) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - colorVal
Local Variable  DBASE:0008 - i
|===========================================================================|
79                        repeat i from 0 to rows - 1
Addr : 04EA:             35  : Constant 1 $00000000
Addr : 04EB:             69  : Variable Operation Local Offset - 2 Write
Addr : 04EC: Label0002
80                          colors[i] := $0000 | colorVal
Addr : 04EC:             35  : Constant 1 $00000000
Addr : 04ED:             64  : Variable Operation Local Offset - 1 Read
Addr : 04EE:             EA  : Math Op |     
Addr : 04EF:             68  : Variable Operation Local Offset - 2 Read
Addr : 04F0:          B9 40  : Memory Op Word VBASE + POP Index WRITE Address = 0040
Addr : 04F2: Label0003
79                        repeat i from 0 to rows - 1
Addr : 04F2:             35  : Constant 1 $00000000
Addr : 04F3:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 04F5:             36  : Constant 2 $00000001
Addr : 04F6:             ED  : Math Op -     
Addr : 04F7: Repeat i Step Label0002
Addr : 04F7:       6A 02 72  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 04EC -14
Addr : 04FA: Label0004
Addr : 04FA:             32  : Return        
|===========================================================================|
Spin Block cursorset with 1 Parameters and 1 Extra Stack Longs. Method 4
PUB cursorset(c) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
Local Variable  DBASE:0008 - i
|===========================================================================|
83                        i:=%000
Addr : 04FB:             35  : Constant 1 $00000000
Addr : 04FC:             69  : Variable Operation Local Offset - 2 Write
84                        if c == 1
Addr : 04FD:             64  : Variable Operation Local Offset - 1 Read
Addr : 04FE:             36  : Constant 2 $00000001
Addr : 04FF:             FC  : Math Op ==    
Addr : 0500: JZ Label0002
Addr : 0500:          0A 02  : jz Address = 0504 2
85                          i:= %001
Addr : 0502:             36  : Constant 2 $00000001
Addr : 0503:             69  : Variable Operation Local Offset - 2 Write
Addr : 0504: Label0002
Addr : 0504: Label0003
86                        if c == 2
Addr : 0504:             64  : Variable Operation Local Offset - 1 Read
Addr : 0505:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0507:             FC  : Math Op ==    
Addr : 0508: JZ Label0004
Addr : 0508:          0A 03  : jz Address = 050D 3
87                          i:= %010
Addr : 050A:          37 00  : Constant Mask Y=0 00000002 2
Addr : 050C:             69  : Variable Operation Local Offset - 2 Write
Addr : 050D: Label0004
Addr : 050D: Label0005
88                        if c == 3
Addr : 050D:             64  : Variable Operation Local Offset - 1 Read
Addr : 050E:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 0510:             FC  : Math Op ==    
Addr : 0511: JZ Label0006
Addr : 0511:          0A 03  : jz Address = 0516 3
89                          i:= %011
Addr : 0513:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 0515:             69  : Variable Operation Local Offset - 2 Write
Addr : 0516: Label0006
Addr : 0516: Label0007
90                        if c == 4
Addr : 0516:             64  : Variable Operation Local Offset - 1 Read
Addr : 0517:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0519:             FC  : Math Op ==    
Addr : 051A: JZ Label0008
Addr : 051A:          0A 03  : jz Address = 051F 3
91                          i:= %101
Addr : 051C:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 051E:             69  : Variable Operation Local Offset - 2 Write
Addr : 051F: Label0008
Addr : 051F: Label0009
92                        if c == 5
Addr : 051F:             64  : Variable Operation Local Offset - 1 Read
Addr : 0520:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 0522:             FC  : Math Op ==    
Addr : 0523: JZ Label000A
Addr : 0523:          0A 03  : jz Address = 0528 3
93                          i:= %110
Addr : 0525:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 0527:             69  : Variable Operation Local Offset - 2 Write
Addr : 0528: Label000A
Addr : 0528: Label000B
94                        if c == 6
Addr : 0528:             64  : Variable Operation Local Offset - 1 Read
Addr : 0529:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 052B:             FC  : Math Op ==    
Addr : 052C: JZ Label000C
Addr : 052C:          0A 03  : jz Address = 0531 3
95                          i:= %111
Addr : 052E:          37 22  : Constant Mask Y=34 Decrement 00000007 7
Addr : 0530:             69  : Variable Operation Local Offset - 2 Write
Addr : 0531: Label000C
Addr : 0531: Label000D
96                        if c == 7
Addr : 0531:             64  : Variable Operation Local Offset - 1 Read
Addr : 0532:          37 22  : Constant Mask Y=34 Decrement 00000007 7
Addr : 0534:             FC  : Math Op ==    
Addr : 0535: JZ Label000E
Addr : 0535:          0A 02  : jz Address = 0539 2
97                          i:= %000  
Addr : 0537:             35  : Constant 1 $00000000
Addr : 0538:             69  : Variable Operation Local Offset - 2 Write
Addr : 0539: Label000E
Addr : 0539: Label000F
98                        cursor[2] := i
Addr : 0539:             68  : Variable Operation Local Offset - 2 Read
Addr : 053A:          37 00  : Constant Mask Y=0 00000002 2
Addr : 053C:       99 8D 6A  : Memory Op Byte VBASE + POP Index WRITE Address = 0D6A
Addr : 053F:             32  : Return        
|===========================================================================|
Spin Block clrbtm with 1 Parameters and 1 Extra Stack Longs. Method 5
PUB clrbtm(ColorVal) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - ColorVal
Local Variable  DBASE:0008 - i
|===========================================================================|
115                         repeat i from 36 to rows - 1                         'was 35
Addr : 0540:          38 24  : Constant 1 Bytes - 24 - $00000024 36
Addr : 0542:             69  : Variable Operation Local Offset - 2 Write
Addr : 0543: Label0003
116                          colors[i] := $0000 + ColorVal
Addr : 0543:             35  : Constant 1 $00000000
Addr : 0544:             64  : Variable Operation Local Offset - 1 Read
Addr : 0545:             EC  : Math Op +     
Addr : 0546:             68  : Variable Operation Local Offset - 2 Read
Addr : 0547:          B9 40  : Memory Op Word VBASE + POP Index WRITE Address = 0040
Addr : 0549: Label0004
115                         repeat i from 36 to rows - 1                         'was 35
Addr : 0549:          38 24  : Constant 1 Bytes - 24 - $00000024 36
Addr : 054B:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 054D:             36  : Constant 2 $00000001
Addr : 054E:             ED  : Math Op -     
Addr : 054F: Repeat i Step Label0003
Addr : 054F:       6A 02 71  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 0543 -15
Addr : 0552: Label0005
Addr : 0552:             32  : Return        
|===========================================================================|
Spin Block cls1 with 5 Parameters and 3 Extra Stack Longs. Method 6
PUB cls1(c,screencolor,pcport,ascii,CR) | i,x,y

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
Local Parameter DBASE:0008 - screencolor
Local Parameter DBASE:000C - pcport
Local Parameter DBASE:0010 - ascii
Local Parameter DBASE:0014 - CR
Local Variable  DBASE:0018 - i
Local Variable  DBASE:001C - x
Local Variable  DBASE:0020 - y
|===========================================================================|
120                        longfill(@screen[0], $20202020, chars / 4)
Addr : 0553:             35  : Constant 1 $00000000
Addr : 0554:       9B 80 9A  : Memory Op Byte VBASE + POP Index ADDRESS Address = 009A
Addr : 0557: 3B 20 20 20 20  : Constant 4 Bytes - 20 20 20 20 - $20202020 538976288
Addr : 055C:       39 0C 80  : Constant 2 Bytes - 0C 80 - $00000C80 3200
Addr : 055F:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0561:             F6  : Math Op /     
Addr : 0562:             1A  : LongFill(Start, Value, Count)
122                        clrbtm(TURQUOISE)
Addr : 0563:             01  : Drop Anchor   
Addr : 0564:          38 29  : Constant 1 Bytes - 29 - $00000029 41
Addr : 0566:          05 05  : Call Sub 5    
124                        inverse := 1
Addr : 0568:             36  : Constant 2 $00000001
Addr : 0569:       89 8D 70  : Memory Op Byte VBASE + WRITE Address = 0D70
126                        statprint(36,0, string("                                 propIO  V 0.90                                 "))
Addr : 056C:             01  : Drop Anchor   
Addr : 056D:          38 24  : Constant 1 Bytes - 24 - $00000024 36
Addr : 056F:             35  : Constant 1 $00000000
Addr : 0570: PBASE Constant Address of Label0002
Addr : 0570:       87 81 BD  : Memory Op Byte PBASE + ADDRESS Address = 01BD
Addr : 0573:          05 0A  : Call Sub 10   
127                        inverse := 0
Addr : 0575:             35  : Constant 1 $00000000
Addr : 0576:       89 8D 70  : Memory Op Byte VBASE + WRITE Address = 0D70
128                        statprint(37,0, string("Baud Rate:  9600  Color    PC Port:  OFF  Force 7 bit:  NO  Cursor   CR W/LF  NO"))
Addr : 0579:             01  : Drop Anchor   
Addr : 057A:          38 25  : Constant 1 Bytes - 25 - $00000025 37
Addr : 057C:             35  : Constant 1 $00000000
Addr : 057D: PBASE Constant Address of Label0003
Addr : 057D:       87 82 0E  : Memory Op Byte PBASE + ADDRESS Address = 020E
Addr : 0580:          05 0A  : Call Sub 10   
129                        statprint(38,0, string("      F1           F2           F3               F4          F5          F6     "))
Addr : 0582:             01  : Drop Anchor   
Addr : 0583:          38 26  : Constant 1 Bytes - 26 - $00000026 38
Addr : 0585:             35  : Constant 1 $00000000
Addr : 0586: PBASE Constant Address of Label0004
Addr : 0586:       87 82 5F  : Memory Op Byte PBASE + ADDRESS Address = 025F
Addr : 0589:          05 0A  : Call Sub 10   
130                        statprint(39,0, string("                                                                                "))
Addr : 058B:             01  : Drop Anchor   
Addr : 058C:          38 27  : Constant 1 Bytes - 27 - $00000027 39
Addr : 058E:             35  : Constant 1 $00000000
Addr : 058F: PBASE Constant Address of Label0005
Addr : 058F:       87 82 B0  : Memory Op Byte PBASE + ADDRESS Address = 02B0
Addr : 0592:          05 0A  : Call Sub 10   
Addr : 0594:             32  : Return        
Addr : 0595: Label0002
Addr : 0595: Data : 20 20 20 20 20 20 20 20          
Addr : 059D: Data : 20 20 20 20 20 20 20 20          
Addr : 05A5: Data : 20 20 20 20 20 20 20 20          
Addr : 05AD: Data : 20 20 20 20 20 20 20 20          
Addr : 05B5: Data : 20 70 72 6F 70 49 4F 20   propIO 
Addr : 05BD: Data : 20 56 20 30 2E 39 30 20   V 0.90 
Addr : 05C5: Data : 20 20 20 20 20 20 20 20          
Addr : 05CD: Data : 20 20 20 20 20 20 20 20          
Addr : 05D5: Data : 20 20 20 20 20 20 20 20          
Addr : 05DD: Data : 20 20 20 20 20 20 20 20          
Addr : 05E5: Data : 00                       .
Addr : 05E6: Label0003
Addr : 05E6: Data : 42 61 75 64 20 52 61 74  Baud Rat
Addr : 05EE: Data : 65 3A 20 20 39 36 30 30  e:  9600
Addr : 05F6: Data : 20 20 43 6F 6C 6F 72 20    Color 
Addr : 05FE: Data : 20 20 20 50 43 20 50 6F     PC Po
Addr : 0606: Data : 72 74 3A 20 20 4F 46 46  rt:  OFF
Addr : 060E: Data : 20 20 46 6F 72 63 65 20    Force 
Addr : 0616: Data : 37 20 62 69 74 3A 20 20  7 bit:  
Addr : 061E: Data : 4E 4F 20 20 43 75 72 73  NO  Curs
Addr : 0626: Data : 6F 72 20 20 20 43 52 20  or   CR 
Addr : 062E: Data : 57 2F 4C 46 20 20 4E 4F  W/LF  NO
Addr : 0636: Data : 00                       .
Addr : 0637: Label0004
Addr : 0637: Data : 20 20 20 20 20 20 46 31        F1
Addr : 063F: Data : 20 20 20 20 20 20 20 20          
Addr : 0647: Data : 20 20 20 46 32 20 20 20     F2   
Addr : 064F: Data : 20 20 20 20 20 20 20 20          
Addr : 0657: Data : 46 33 20 20 20 20 20 20  F3      
Addr : 065F: Data : 20 20 20 20 20 20 20 20          
Addr : 0667: Data : 20 46 34 20 20 20 20 20   F4     
Addr : 066F: Data : 20 20 20 20 20 46 35 20       F5 
Addr : 0677: Data : 20 20 20 20 20 20 20 20          
Addr : 067F: Data : 20 46 36 20 20 20 20 20   F6     
Addr : 0687: Data : 00                       .
Addr : 0688: Label0005
Addr : 0688: Data : 20 20 20 20 20 20 20 20          
Addr : 0690: Data : 20 20 20 20 20 20 20 20          
Addr : 0698: Data : 20 20 20 20 20 20 20 20          
Addr : 06A0: Data : 20 20 20 20 20 20 20 20          
Addr : 06A8: Data : 20 20 20 20 20 20 20 20          
Addr : 06B0: Data : 20 20 20 20 20 20 20 20          
Addr : 06B8: Data : 20 20 20 20 20 20 20 20          
Addr : 06C0: Data : 20 20 20 20 20 20 20 20          
Addr : 06C8: Data : 20 20 20 20 20 20 20 20          
Addr : 06D0: Data : 20 20 20 20 20 20 20 20          
Addr : 06D8: Data : 00                       .
|===========================================================================|
Spin Block dec with 1 Parameters and 1 Extra Stack Longs. Method 7
PUB dec(value) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Variable  DBASE:0008 - i
|===========================================================================|
271                        if value < 0
Addr : 06D9:             64  : Variable Operation Local Offset - 1 Read
Addr : 06DA:             35  : Constant 1 $00000000
Addr : 06DB:             F9  : Math Op <     
Addr : 06DC: JZ Label0002
Addr : 06DC:          0A 07  : jz Address = 06E5 7
272                          -value
Addr : 06DE:          66 46  : Variable Operation Local Offset - 1 Assign LongMathop -
273                          outc("-")
Addr : 06E0:             01  : Drop Anchor   
Addr : 06E1:          38 2D  : Constant 1 Bytes - 2D - $0000002D 45
Addr : 06E3:          05 1A  : Call Sub 26   
Addr : 06E5: Label0002
Addr : 06E5: Label0003
275                        i := 1_000_000_000
Addr : 06E5: 3B 3B 9A CA 00  : Constant 4 Bytes - 3B 9A CA 00 - $3B9ACA00 1000000000
Addr : 06EA:             69  : Variable Operation Local Offset - 2 Write
277                        repeat 10
Addr : 06EB:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 06ED: TJZ Label0006
Addr : 06ED:          08 27  : tjz Address = 0716 39
Addr : 06EF: Label0004
278                          if value => i
Addr : 06EF:             64  : Variable Operation Local Offset - 1 Read
Addr : 06F0:             68  : Variable Operation Local Offset - 2 Read
Addr : 06F1:             FE  : Math Op =>    
Addr : 06F2: JZ Label0007
Addr : 06F2:          0A 10  : jz Address = 0704 16
279                            outc(value/i + "0")
Addr : 06F4:             01  : Drop Anchor   
Addr : 06F5:             64  : Variable Operation Local Offset - 1 Read
Addr : 06F6:             68  : Variable Operation Local Offset - 2 Read
Addr : 06F7:             F6  : Math Op /     
Addr : 06F8:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 06FA:             EC  : Math Op +     
Addr : 06FB:          05 1A  : Call Sub 26   
280                            value //= i
Addr : 06FD:             68  : Variable Operation Local Offset - 2 Read
Addr : 06FE:          66 57  : Variable Operation Local Offset - 1 Assign LongMathop //
281                            result~~
Addr : 0700:          62 1C  : Variable Operation Local Offset - 0 Assign VAR~~ Post-set
Addr : 0702: JMP Label0008
Addr : 0702:          04 0C  : Jmp 0710 12   
Addr : 0704: Label0007
282                          elseif result or i == 1
Addr : 0704:             60  : Variable Operation Local Offset - 0 Read
Addr : 0705:             68  : Variable Operation Local Offset - 2 Read
Addr : 0706:             36  : Constant 2 $00000001
Addr : 0707:             FC  : Math Op ==    
Addr : 0708:             F2  : Math Op OR    
Addr : 0709: JZ Label0009
Addr : 0709:          0A 05  : jz Address = 0710 5
283                            outc("0")
Addr : 070B:             01  : Drop Anchor   
Addr : 070C:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 070E:          05 1A  : Call Sub 26   
Addr : 0710: Label0009
Addr : 0710: Label0008
284                          i /= 10     
Addr : 0710:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 0712:          6A 56  : Variable Operation Local Offset - 2 Assign LongMathop /
Addr : 0714: Label0005
Addr : 0714: DJNZ Label0004
Addr : 0714:          09 59  : djnz Address = 06EF -39
Addr : 0716: Label0006
Addr : 0716:             32  : Return        
|===========================================================================|
Spin Block hex with 2 Parameters and 0 Extra Stack Longs. Method 8
PUB hex(value, digits)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - digits
|===========================================================================|
Addr : 0717: Label0002
# Source File : lib/VGA_1024.spin
290                        repeat while digits > 8
Addr : 0717:             68  : Variable Operation Local Offset - 2 Read
Addr : 0718:          37 02  : Constant Mask Y=2 00000008 8
Addr : 071A:             FA  : Math Op >     
Addr : 071B: JZ Label0004
Addr : 071B:          0A 09  : jz Address = 0726 9
291                          outc("0")
Addr : 071D:             01  : Drop Anchor   
Addr : 071E:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0720:          05 1A  : Call Sub 26   
292                          digits--
Addr : 0722:          6A 3E  : Variable Operation Local Offset - 2 Assign VAR-- post-dec Long
Addr : 0724: Label0003
Addr : 0724: JMP Label0002
Addr : 0724:          04 71  : Jmp 0717 -15  
Addr : 0726: Label0004
294                        value <<= (8 - digits) << 2
Addr : 0726:          37 02  : Constant Mask Y=2 00000008 8
Addr : 0728:             68  : Variable Operation Local Offset - 2 Read
Addr : 0729:             ED  : Math Op -     
Addr : 072A:          37 00  : Constant Mask Y=0 00000002 2
Addr : 072C:             E3  : Math Op <<    
Addr : 072D:          66 43  : Variable Operation Local Offset - 1 Assign ByteMathop <<
296                        repeat digits
Addr : 072F:             68  : Variable Operation Local Offset - 2 Read
Addr : 0730: TJZ Label0007
Addr : 0730:          08 1B  : tjz Address = 074D 27
Addr : 0732: Label0005
297                          outc(lookupz((value <-= 4) & $f : "0".."9", "A".."F"))
Addr : 0732:             01  : Drop Anchor   
Addr : 0733:             35  : Constant 1 $00000000
Addr : 0734: Constant Address of Label0008
Addr : 0734:       39 03 71  : Constant 2 Bytes - 03 71 - $00000371 881
Addr : 0737:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0739:          66 C1  : Variable Operation Local Offset - 1 Assign BitMathop -< Push
Addr : 073B:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 073D:             E8  : Math Op &     
Addr : 073E:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0740:          38 39  : Constant 1 Bytes - 39 - $00000039 57
Addr : 0742:             12  : Range LookUp  
Addr : 0743:          38 41  : Constant 1 Bytes - 41 - $00000041 65
Addr : 0745:          38 46  : Constant 1 Bytes - 46 - $00000046 70
Addr : 0747:             12  : Range LookUp  
Addr : 0748:             0F  : Lookdone      
Addr : 0749: Label0008
Addr : 0749:          05 1A  : Call Sub 26   
Addr : 074B: Label0006
Addr : 074B: DJNZ Label0005
Addr : 074B:          09 65  : djnz Address = 0732 -27
Addr : 074D: Label0007
Addr : 074D:             32  : Return        
|===========================================================================|
Spin Block str with 1 Parameters and 0 Extra Stack Longs. Method 9
PUB str(string_ptr)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - string_ptr
|===========================================================================|
304                        repeat strsize(string_ptr)
Addr : 074E:             64  : Variable Operation Local Offset - 1 Read
Addr : 074F:             16  : StrSize(String)
Addr : 0750: TJZ Label0004
Addr : 0750:          08 08  : tjz Address = 075A 8
Addr : 0752: Label0002
305                          process_char(byte[string_ptr++])
Addr : 0752:             01  : Drop Anchor   
Addr : 0753:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 0755:             80  : Memory Op Byte POP Address READ 
Addr : 0756:          05 15  : Call Sub 21   
Addr : 0758: Label0003
Addr : 0758: DJNZ Label0002
Addr : 0758:          09 78  : djnz Address = 0752 -8
Addr : 075A: Label0004
Addr : 075A:             32  : Return        
|===========================================================================|
Spin Block statprint with 3 Parameters and 2 Extra Stack Longs. Method 10
PUB statprint(r, c, str1) | x, ptr

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - r
Local Parameter DBASE:0008 - c
Local Parameter DBASE:000C - str1
Local Variable  DBASE:0010 - x
Local Variable  DBASE:0014 - ptr
|===========================================================================|
309                        ptr := r * cols + c
Addr : 075B:             64  : Variable Operation Local Offset - 1 Read
Addr : 075C:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 075E:             F4  : Math Op *     
Addr : 075F:             68  : Variable Operation Local Offset - 2 Read
Addr : 0760:             EC  : Math Op +     
Addr : 0761:             75  : Variable Operation Local Offset - 5 Write
310                        repeat x from 0 to STRSIZE(str1) - 1
Addr : 0762:             35  : Constant 1 $00000000
Addr : 0763:             71  : Variable Operation Local Offset - 4 Write
Addr : 0764: Label0002
311                          putc(ptr++, BYTE[str1 + x])
Addr : 0764:             01  : Drop Anchor   
Addr : 0765:          76 AE  : Variable Operation Local Offset - 5 Assign VAR++ post inc Long Push
Addr : 0767:             6C  : Variable Operation Local Offset - 3 Read
Addr : 0768:             70  : Variable Operation Local Offset - 4 Read
Addr : 0769:             EC  : Math Op +     
Addr : 076A:             80  : Memory Op Byte POP Address READ 
Addr : 076B:          05 0B  : Call Sub 11   
Addr : 076D: Label0003
310                        repeat x from 0 to STRSIZE(str1) - 1
Addr : 076D:             35  : Constant 1 $00000000
Addr : 076E:             6C  : Variable Operation Local Offset - 3 Read
Addr : 076F:             16  : StrSize(String)
Addr : 0770:             36  : Constant 2 $00000001
Addr : 0771:             ED  : Math Op -     
Addr : 0772: Repeat x Step Label0002
Addr : 0772:       72 02 6F  : Variable Operation Local Offset - 4 Assign Repeat-Var loop Address= 0764 -17
Addr : 0775: Label0004
Addr : 0775:             32  : Return        
|===========================================================================|
Spin Block putc with 2 Parameters and 0 Extra Stack Longs. Method 11
PUB putc(position, c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Parameter DBASE:0008 - c
|===========================================================================|
333                        if inverse
Addr : 0776:       88 8D 70  : Memory Op Byte VBASE + READ Address = 0D70
Addr : 0779: JZ Label0002
Addr : 0779:          0A 04  : jz Address = 077F 4
334                          c |= $80
Addr : 077B:          37 06  : Constant Mask Y=6 00000080 128
Addr : 077D:          6A 4A  : Variable Operation Local Offset - 2 Assign ByteMathop |
Addr : 077F: Label0002
Addr : 077F: Label0003
335                        screen[position] := c
Addr : 077F:             68  : Variable Operation Local Offset - 2 Read
Addr : 0780:             64  : Variable Operation Local Offset - 1 Read
Addr : 0781:       99 80 9A  : Memory Op Byte VBASE + POP Index WRITE Address = 009A
Addr : 0784:             32  : Return        
|===========================================================================|
Spin Block setInverse with 1 Parameters and 0 Extra Stack Longs. Method 12
PUB setInverse(val)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - val
|===========================================================================|
344                        inverse := val
Addr : 0785:             64  : Variable Operation Local Offset - 1 Read
Addr : 0786:       89 8D 70  : Memory Op Byte VBASE + WRITE Address = 0D70
Addr : 0789:             32  : Return        
|===========================================================================|
Spin Block setInv with 1 Parameters and 0 Extra Stack Longs. Method 13
PUB setInv(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
347                        if c == 7
Addr : 078A:             64  : Variable Operation Local Offset - 1 Read
Addr : 078B:          37 22  : Constant Mask Y=34 Decrement 00000007 7
Addr : 078D:             FC  : Math Op ==    
Addr : 078E: JZ Label0002
Addr : 078E:          0A 06  : jz Address = 0796 6
348                          setInverse(1)
Addr : 0790:             01  : Drop Anchor   
Addr : 0791:             36  : Constant 2 $00000001
Addr : 0792:          05 0C  : Call Sub 12   
Addr : 0794: JMP Label0003
Addr : 0794:          04 04  : Jmp 079A 4    
Addr : 0796: Label0002
350                          setInverse(0)
Addr : 0796:             01  : Drop Anchor   
Addr : 0797:             35  : Constant 1 $00000000
Addr : 0798:          05 0C  : Call Sub 12   
Addr : 079A: Label0004
Addr : 079A: Label0003
Addr : 079A:             32  : Return        
|===========================================================================|
Spin Block clEOL with 1 Parameters and 1 Extra Stack Longs. Method 14
PUB clEOL(position) | count

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - count
|===========================================================================|
Addr : 079B:          38 50  : Constant 1 Bytes - 50 - $00000050 80
# Source File : lib/VGA_1024.spin
353                        count := cols - (position // cols)
Addr : 079D:             64  : Variable Operation Local Offset - 1 Read
Addr : 079E:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07A0:             F7  : Math Op //    
Addr : 07A1:             ED  : Math Op -     
Addr : 07A2:             69  : Variable Operation Local Offset - 2 Write
354                        bytefill(@screen + position, $20, count)
Addr : 07A3:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 07A6:             64  : Variable Operation Local Offset - 1 Read
Addr : 07A7:             EC  : Math Op +     
Addr : 07A8:          37 04  : Constant Mask Y=4 00000020 32
Addr : 07AA:             68  : Variable Operation Local Offset - 2 Read
Addr : 07AB:             18  : ByteFill(Start, Value, Count)
Addr : 07AC:             32  : Return        
|===========================================================================|
Spin Block clBOL with 1 Parameters and 1 Extra Stack Longs. Method 15
PUB clBOL(position) | count

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - count
|===========================================================================|
357                        count := position // cols
Addr : 07AD:             64  : Variable Operation Local Offset - 1 Read
Addr : 07AE:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07B0:             F7  : Math Op //    
Addr : 07B1:             69  : Variable Operation Local Offset - 2 Write
358                        bytefill(@screen + position - count, $20, count)
Addr : 07B2:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 07B5:             64  : Variable Operation Local Offset - 1 Read
Addr : 07B6:             EC  : Math Op +     
Addr : 07B7:             68  : Variable Operation Local Offset - 2 Read
Addr : 07B8:             ED  : Math Op -     
Addr : 07B9:          37 04  : Constant Mask Y=4 00000020 32
Addr : 07BB:             68  : Variable Operation Local Offset - 2 Read
Addr : 07BC:             18  : ByteFill(Start, Value, Count)
Addr : 07BD:             32  : Return        
|===========================================================================|
Spin Block delLine with 1 Parameters and 2 Extra Stack Longs. Method 16
PUB delLine(position) | src, count

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - src
Local Variable  DBASE:000C - count
|===========================================================================|
361                        position -= position // cols
Addr : 07BE:             64  : Variable Operation Local Offset - 1 Read
Addr : 07BF:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07C1:             F7  : Math Op //    
Addr : 07C2:          66 4D  : Variable Operation Local Offset - 1 Assign WordMathop -
363                        src := position + cols
Addr : 07C4:             64  : Variable Operation Local Offset - 1 Read
Addr : 07C5:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07C7:             EC  : Math Op +     
Addr : 07C8:             69  : Variable Operation Local Offset - 2 Write
Addr : 07C9:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
365                        count := (maxChars - src) / 4
Addr : 07CC:             68  : Variable Operation Local Offset - 2 Read
Addr : 07CD:             ED  : Math Op -     
Addr : 07CE:          37 01  : Constant Mask Y=1 00000004 4
Addr : 07D0:             F6  : Math Op /     
Addr : 07D1:             6D  : Variable Operation Local Offset - 3 Write
367                        if count > 0
Addr : 07D2:             6C  : Variable Operation Local Offset - 3 Read
Addr : 07D3:             35  : Constant 1 $00000000
Addr : 07D4:             FA  : Math Op >     
Addr : 07D5: JZ Label0002
Addr : 07D5:          0A 0C  : jz Address = 07E3 12
368                          longmove(@screen + position, @screen + src, count)
Addr : 07D7:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 07DA:             64  : Variable Operation Local Offset - 1 Read
Addr : 07DB:             EC  : Math Op +     
Addr : 07DC:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 07DF:             68  : Variable Operation Local Offset - 2 Read
Addr : 07E0:             EC  : Math Op +     
Addr : 07E1:             6C  : Variable Operation Local Offset - 3 Read
Addr : 07E2:             1E  : LongMove(To, From, Count)
Addr : 07E3: Label0002
Addr : 07E3: Label0003
370                        longfill(@screen + lastLine, $20202020, lcols)
Addr : 07E3:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 07E6:       39 0A F0  : Constant 2 Bytes - 0A F0 - $00000AF0 2800
Addr : 07E9:             EC  : Math Op +     
Addr : 07EA: 3B 20 20 20 20  : Constant 4 Bytes - 20 20 20 20 - $20202020 538976288
Addr : 07EF:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 07F1:             1A  : LongFill(Start, Value, Count)
Addr : 07F2:             32  : Return        
|===========================================================================|
Spin Block setCursorPos with 1 Parameters and 0 Extra Stack Longs. Method 17
PUB setCursorPos(position)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
|===========================================================================|
380                        cursor[0] := position // cols
Addr : 07F3:             64  : Variable Operation Local Offset - 1 Read
Addr : 07F4:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07F6:             F7  : Math Op //    
Addr : 07F7:             35  : Constant 1 $00000000
Addr : 07F8:       99 8D 6A  : Memory Op Byte VBASE + POP Index WRITE Address = 0D6A
381                        cursor[1] := position / cols
Addr : 07FB:             64  : Variable Operation Local Offset - 1 Read
Addr : 07FC:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 07FE:             F6  : Math Op /     
Addr : 07FF:             36  : Constant 2 $00000001
Addr : 0800:       99 8D 6A  : Memory Op Byte VBASE + POP Index WRITE Address = 0D6A
Addr : 0803:             32  : Return        
|===========================================================================|
Spin Block insLine with 1 Parameters and 2 Extra Stack Longs. Method 18
PUB insLine(position) | base, nxt

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - base
Local Variable  DBASE:000C - nxt
|===========================================================================|
384                        base := position - (position // cols)
Addr : 0804:             64  : Variable Operation Local Offset - 1 Read
Addr : 0805:             64  : Variable Operation Local Offset - 1 Read
Addr : 0806:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0808:             F7  : Math Op //    
Addr : 0809:             ED  : Math Op -     
Addr : 080A:             69  : Variable Operation Local Offset - 2 Write
Addr : 080B:       39 0A F0  : Constant 2 Bytes - 0A F0 - $00000AF0 2800
385                        position := lastLine
Addr : 080E:             65  : Variable Operation Local Offset - 1 Write
Addr : 080F: Label0002
386                        repeat while position > base
Addr : 080F:             64  : Variable Operation Local Offset - 1 Read
Addr : 0810:             68  : Variable Operation Local Offset - 2 Read
Addr : 0811:             FA  : Math Op >     
Addr : 0812: JZ Label0004
Addr : 0812:          0A 16  : jz Address = 082A 22
387                          nxt := position - cols
Addr : 0814:             64  : Variable Operation Local Offset - 1 Read
Addr : 0815:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0817:             ED  : Math Op -     
Addr : 0818:             6D  : Variable Operation Local Offset - 3 Write
388                          longmove(@screen + position, @screen + nxt, lcols)
Addr : 0819:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 081C:             64  : Variable Operation Local Offset - 1 Read
Addr : 081D:             EC  : Math Op +     
Addr : 081E:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 0821:             6C  : Variable Operation Local Offset - 3 Read
Addr : 0822:             EC  : Math Op +     
Addr : 0823:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 0825:             1E  : LongMove(To, From, Count)
389                          position := nxt
Addr : 0826:             6C  : Variable Operation Local Offset - 3 Read
Addr : 0827:             65  : Variable Operation Local Offset - 1 Write
Addr : 0828: Label0003
Addr : 0828: JMP Label0002
Addr : 0828:          04 65  : Jmp 080F -27  
Addr : 082A: Label0004
390                        clEOL(base)
Addr : 082A:             01  : Drop Anchor   
Addr : 082B:             68  : Variable Operation Local Offset - 2 Read
Addr : 082C:          05 0E  : Call Sub 14   
Addr : 082E:             32  : Return        
|===========================================================================|
Spin Block insChar with 1 Parameters and 1 Extra Stack Longs. Method 19
PUB insChar(position) | count

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - count
|===========================================================================|
Addr : 082F:          38 50  : Constant 1 Bytes - 50 - $00000050 80
# Source File : lib/VGA_1024.spin
393                        count := (cols - (position // cols)) - 1
Addr : 0831:             64  : Variable Operation Local Offset - 1 Read
Addr : 0832:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0834:             F7  : Math Op //    
Addr : 0835:             ED  : Math Op -     
Addr : 0836:             36  : Constant 2 $00000001
Addr : 0837:             ED  : Math Op -     
Addr : 0838:             69  : Variable Operation Local Offset - 2 Write
394                        bytemove(@tmpl, @screen + position, count)
Addr : 0839:       8B 8D 1A  : Memory Op Byte VBASE + ADDRESS Address = 0D1A
Addr : 083C:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 083F:             64  : Variable Operation Local Offset - 1 Read
Addr : 0840:             EC  : Math Op +     
Addr : 0841:             68  : Variable Operation Local Offset - 2 Read
Addr : 0842:             1C  : ByteMove(To, From, Count)
395                        screen[position] := " "
Addr : 0843:          37 04  : Constant Mask Y=4 00000020 32
Addr : 0845:             64  : Variable Operation Local Offset - 1 Read
Addr : 0846:       99 80 9A  : Memory Op Byte VBASE + POP Index WRITE Address = 009A
396                        bytemove(@screen + position + 1, @tmpl, count)
Addr : 0849:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 084C:             64  : Variable Operation Local Offset - 1 Read
Addr : 084D:             EC  : Math Op +     
Addr : 084E:             36  : Constant 2 $00000001
Addr : 084F:             EC  : Math Op +     
Addr : 0850:       8B 8D 1A  : Memory Op Byte VBASE + ADDRESS Address = 0D1A
Addr : 0853:             68  : Variable Operation Local Offset - 2 Read
Addr : 0854:             1C  : ByteMove(To, From, Count)
Addr : 0855:             32  : Return        
|===========================================================================|
Spin Block delChar with 1 Parameters and 1 Extra Stack Longs. Method 20
PUB delChar(position) | count

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - position
Local Variable  DBASE:0008 - count
|===========================================================================|
Addr : 0856:          38 50  : Constant 1 Bytes - 50 - $00000050 80
# Source File : lib/VGA_1024.spin
399                        count := (cols - (position // cols)) - 1
Addr : 0858:             64  : Variable Operation Local Offset - 1 Read
Addr : 0859:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 085B:             F7  : Math Op //    
Addr : 085C:             ED  : Math Op -     
Addr : 085D:             36  : Constant 2 $00000001
Addr : 085E:             ED  : Math Op -     
Addr : 085F:             69  : Variable Operation Local Offset - 2 Write
400                        bytemove(@screen + position, @screen + position + 1, count)
Addr : 0860:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 0863:             64  : Variable Operation Local Offset - 1 Read
Addr : 0864:             EC  : Math Op +     
Addr : 0865:       8B 80 9A  : Memory Op Byte VBASE + ADDRESS Address = 009A
Addr : 0868:             64  : Variable Operation Local Offset - 1 Read
Addr : 0869:             EC  : Math Op +     
Addr : 086A:             36  : Constant 2 $00000001
Addr : 086B:             EC  : Math Op +     
Addr : 086C:             68  : Variable Operation Local Offset - 2 Read
Addr : 086D:             1C  : ByteMove(To, From, Count)
401                        screen[position + count] := " "
Addr : 086E:          37 04  : Constant Mask Y=4 00000020 32
Addr : 0870:             64  : Variable Operation Local Offset - 1 Read
Addr : 0871:             68  : Variable Operation Local Offset - 2 Read
Addr : 0872:             EC  : Math Op +     
Addr : 0873:       99 80 9A  : Memory Op Byte VBASE + POP Index WRITE Address = 009A
Addr : 0876:             32  : Return        
|===========================================================================|
Spin Block process_char with 1 Parameters and 0 Extra Stack Longs. Method 21
PUB process_char(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
Addr : 0877: Constant Address of Label0002
Addr : 0877:       39 06 BB  : Constant 2 Bytes - 06 BB - $000006BB 1723
# Source File : lib/VGA_1024.spin
562                        case state
Addr : 087A:       88 8D 72  : Memory Op Byte VBASE + READ Address = 0D72
564                          0:
Addr : 087D:             35  : Constant 1 $00000000
Addr : 087E: Case_Value Label0003
Addr : 087E:          0D 19  : Value Case Address = 0899 25
611                          1:
Addr : 0880:             36  : Constant 2 $00000001
Addr : 0881: Case_Value Label001D
Addr : 0881:       0D 80 DC  : Value Case Address = 0960 220
650                         2:
Addr : 0884:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0886: Case_Value Label0031
Addr : 0886:       0D 81 69  : Value Case Address = 09F2 361
666                         3:
Addr : 0889:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 088B: Case_Value Label0039
Addr : 088B:       0D 81 A2  : Value Case Address = 0A30 418
682                         4:
Addr : 088E:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0890: Case_Value Label0041
Addr : 0890:       0D 81 DB  : Value Case Address = 0A6E 475
692                         5:
Addr : 0893:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 0895: Case_Value Label0046
Addr : 0895:       0D 81 F5  : Value Case Address = 0A8D 501
Addr : 0898: CaseDone Label0046
Addr : 0898:             0C  : Casedone      
Addr : 0899: Label0003
565                            if c > 127
Addr : 0899:             64  : Variable Operation Local Offset - 1 Read
Addr : 089A:          37 26  : Constant Mask Y=38 Decrement 0000007F 127
Addr : 089C:             FA  : Math Op >     
Addr : 089D: JZ Label0004
Addr : 089D:          0A 03  : jz Address = 08A2 3
566                              c := $20
Addr : 089F:          37 04  : Constant Mask Y=4 00000020 32
Addr : 08A1:             65  : Variable Operation Local Offset - 1 Write
Addr : 08A2: Label0004
Addr : 08A2: Label0005
568                            if c => $20
Addr : 08A2:             64  : Variable Operation Local Offset - 1 Read
Addr : 08A3:          37 04  : Constant Mask Y=4 00000020 32
Addr : 08A5:             FE  : Math Op =>    
Addr : 08A6: JZ Label0006
Addr : 08A6:          0A 0B  : jz Address = 08B3 11
569                              outc(c)
Addr : 08A8:             01  : Drop Anchor   
Addr : 08A9:             64  : Variable Operation Local Offset - 1 Read
Addr : 08AA:          05 1A  : Call Sub 26   
570                              setCursorPos(pos)
Addr : 08AC:             01  : Drop Anchor   
Addr : 08AD:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 08B0:          05 11  : Call Sub 17   
Addr : 08B2:             32  : Return        
Addr : 08B3: Label0006
Addr : 08B3: Label0007
573                            if c == $1B
Addr : 08B3:             64  : Variable Operation Local Offset - 1 Read
Addr : 08B4:          38 1B  : Constant 1 Bytes - 1B - $0000001B 27
Addr : 08B6:             FC  : Math Op ==    
Addr : 08B7: JZ Label0008
Addr : 08B7:          0A 05  : jz Address = 08BE 5
574                              state := 1
Addr : 08B9:             36  : Constant 2 $00000001
Addr : 08BA:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 08BD:             32  : Return        
Addr : 08BE: Label0008
Addr : 08BE: Label0009
577                            if c == $0D
Addr : 08BE:             64  : Variable Operation Local Offset - 1 Read
Addr : 08BF:          38 0D  : Constant 1 Bytes - 0D - $0000000D 13
Addr : 08C1:             FC  : Math Op ==    
Addr : 08C2: JZ Label000A
Addr : 08C2:          0A 14  : jz Address = 08D8 20
578                              pos := pos - (pos // cols)
Addr : 08C4:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 08C7:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 08CA:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 08CC:             F7  : Math Op //    
Addr : 08CD:             ED  : Math Op -     
Addr : 08CE:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
579                              setCursorPos(pos)
Addr : 08D1:             01  : Drop Anchor   
Addr : 08D2:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 08D5:          05 11  : Call Sub 17   
Addr : 08D7:             32  : Return        
Addr : 08D8: Label000A
Addr : 08D8: Label000B
582                            if c == $0A
Addr : 08D8:             64  : Variable Operation Local Offset - 1 Read
Addr : 08D9:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 08DB:             FC  : Math Op ==    
Addr : 08DC: JZ Label000C
Addr : 08DC:          0A 3B  : jz Address = 0919 59
583                              if inRegion
Addr : 08DE:             00  : Drop Anchor Push 
Addr : 08DF:          05 16  : Call Sub 22   
Addr : 08E1: JZ Label000E
Addr : 08E1:          0A 1A  : jz Address = 08FD 26
Addr : 08E3:          38 50  : Constant 1 Bytes - 50 - $00000050 80
584                                  pos += cols
Addr : 08E5:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
585                                  if pos => regionBot
Addr : 08E9:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 08EC:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 08EF:             FE  : Math Op =>    
Addr : 08F0: JZ Label0010
Addr : 08F0:          0A 09  : jz Address = 08FB 9
586                                     scrollUp
Addr : 08F2:             01  : Drop Anchor   
Addr : 08F3:          05 17  : Call Sub 23   
Addr : 08F5:          38 50  : Constant 1 Bytes - 50 - $00000050 80
587                                     pos -= cols
Addr : 08F7:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 08FB: Label0010
Addr : 08FB: Label0011
Addr : 08FB: JMP Label000F
Addr : 08FB:          04 15  : Jmp 0912 21   
Addr : 08FD: Label000E
Addr : 08FD:          38 50  : Constant 1 Bytes - 50 - $00000050 80
589                                pos += cols
Addr : 08FF:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
590                                if pos => maxChars
Addr : 0903:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0906:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0909:             FE  : Math Op =>    
Addr : 090A: JZ Label0013
Addr : 090A:          0A 06  : jz Address = 0912 6
Addr : 090C:          38 50  : Constant 1 Bytes - 50 - $00000050 80
591                                  pos -= cols
Addr : 090E:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 0912: Label0013
Addr : 0912: Label0014
Addr : 0912: Label0012
Addr : 0912: Label000F
592                              setCursorPos(pos)
Addr : 0912:             01  : Drop Anchor   
Addr : 0913:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0916:          05 11  : Call Sub 17   
Addr : 0918:             32  : Return        
Addr : 0919: Label000C
Addr : 0919: Label000D
595                            if c == 9
Addr : 0919:             64  : Variable Operation Local Offset - 1 Read
Addr : 091A:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 091C:             FC  : Math Op ==    
Addr : 091D: JZ Label0015
Addr : 091D:          0A 27  : jz Address = 0946 39
596                              pos += (8 - (pos // 8))
Addr : 091F:          37 02  : Constant Mask Y=2 00000008 8
Addr : 0921:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0924:          37 02  : Constant Mask Y=2 00000008 8
Addr : 0926:             F7  : Math Op //    
Addr : 0927:             ED  : Math Op -     
Addr : 0928:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
598                              if pos => maxChars
Addr : 092C:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 092F:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0932:             FE  : Math Op =>    
Addr : 0933: JZ Label0017
Addr : 0933:          0A 0A  : jz Address = 093F 10
Addr : 0935:       39 0A F0  : Constant 2 Bytes - 0A F0 - $00000AF0 2800
599                               pos := lastLine
Addr : 0938:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
600                               delLine(0)
Addr : 093B:             01  : Drop Anchor   
Addr : 093C:             35  : Constant 1 $00000000
Addr : 093D:          05 10  : Call Sub 16   
Addr : 093F: Label0017
Addr : 093F: Label0018
602                              setCursorPos(pos)
Addr : 093F:             01  : Drop Anchor   
Addr : 0940:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0943:          05 11  : Call Sub 17   
Addr : 0945:             32  : Return        
Addr : 0946: Label0015
Addr : 0946: Label0016
605                           if c == 8
Addr : 0946:             64  : Variable Operation Local Offset - 1 Read
Addr : 0947:          37 02  : Constant Mask Y=2 00000008 8
Addr : 0949:             FC  : Math Op ==    
Addr : 094A: JZ Label0019
Addr : 094A:          0A 13  : jz Address = 095F 19
606                             if pos > 0
Addr : 094C:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 094F:             35  : Constant 1 $00000000
Addr : 0950:             FA  : Math Op >     
Addr : 0951: JZ Label001B
Addr : 0951:          0A 05  : jz Address = 0958 5
607                               pos -= 1
Addr : 0953:             36  : Constant 2 $00000001
Addr : 0954:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 0958: Label001B
Addr : 0958: Label001C
608                             setCursorPos(pos)
Addr : 0958:             01  : Drop Anchor   
Addr : 0959:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 095C:          05 11  : Call Sub 17   
Addr : 095E:             32  : Return        
Addr : 095F: Label0019
Addr : 095F: Label001A
Addr : 095F: CaseDone Label0003
Addr : 095F:             0C  : Casedone      
Addr : 0960: Label001D
Addr : 0960: Constant Address of Label001E
Addr : 0960:       39 06 14  : Constant 2 Bytes - 06 14 - $00000614 1556
612                            case c
Addr : 0963:             64  : Variable Operation Local Offset - 1 Read
613                                "[":
Addr : 0964:          38 5B  : Constant 1 Bytes - 5B - $0000005B 91
Addr : 0966: Case_Value Label001F
Addr : 0966:          0D 22  : Value Case Address = 098A 34
618                                "P":
Addr : 0968:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 096A: Case_Value Label0020
Addr : 096A:          0D 2B  : Value Case Address = 0997 43
623                                "K":
Addr : 096C:          38 4B  : Constant 1 Bytes - 4B - $0000004B 75
Addr : 096E: Case_Value Label0023
Addr : 096E:          0D 3D  : Value Case Address = 09AD 61
627                                "H":
Addr : 0970:          38 48  : Constant 1 Bytes - 48 - $00000048 72
Addr : 0972: Case_Value Label0026
Addr : 0972:       0D 80 45  : Value Case Address = 09BA 69
632                                "D":
Addr : 0975:          38 44  : Constant 1 Bytes - 44 - $00000044 68
Addr : 0977: Case_Value Label0029
Addr : 0977:       0D 80 54  : Value Case Address = 09CE 84
636                                "M":
Addr : 097A:          38 4D  : Constant 1 Bytes - 4D - $0000004D 77
Addr : 097C: Case_Value Label002C
Addr : 097C:       0D 80 58  : Value Case Address = 09D7 88
640                                "G":
Addr : 097F:          38 47  : Constant 1 Bytes - 47 - $00000047 71
Addr : 0981: Case_Value Label002F
Addr : 0981:       0D 80 5C  : Value Case Address = 09E0 92
643                                "(":
Addr : 0984:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 0986: Case_Value Label0030
Addr : 0986:       0D 80 5C  : Value Case Address = 09E5 92
Addr : 0989: CaseDone Label0030
Addr : 0989:             0C  : Casedone      
Addr : 098A: Label001F
614                                    arg0 := arg1 := -1
Addr : 098A:             34  : Constant 0 $FFFFFFFF
Addr : 098B:       CA 3C 80  : Memory Op Long VBASE + ASSIGN Address = 003C Write Push
Addr : 098E:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
615                                    state := 2
Addr : 0990:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0992:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 0995:             32  : Return        
Addr : 0996: CaseDone Label001F
Addr : 0996:             0C  : Casedone      
Addr : 0997: Label0020
Addr : 0997:          38 50  : Constant 1 Bytes - 50 - $00000050 80
619                                    pos += cols
Addr : 0999:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
620                                    if pos => maxChars
Addr : 099D:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 09A0:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 09A3:             FE  : Math Op =>    
Addr : 09A4: JZ Label0021
Addr : 09A4:          0A 06  : jz Address = 09AC 6
Addr : 09A6:          38 50  : Constant 1 Bytes - 50 - $00000050 80
621                                        pos -= cols
Addr : 09A8:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 09AC: Label0021
Addr : 09AC: Label0022
Addr : 09AC: CaseDone Label0020
Addr : 09AC:             0C  : Casedone      
Addr : 09AD: Label0023
624                                    if pos > 0
Addr : 09AD:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 09B0:             35  : Constant 1 $00000000
Addr : 09B1:             FA  : Math Op >     
Addr : 09B2: JZ Label0024
Addr : 09B2:          0A 05  : jz Address = 09B9 5
625                                        pos -= 1
Addr : 09B4:             36  : Constant 2 $00000001
Addr : 09B5:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 09B9: Label0024
Addr : 09B9: Label0025
Addr : 09B9: CaseDone Label0023
Addr : 09B9:             0C  : Casedone      
Addr : 09BA: Label0026
Addr : 09BA:          38 50  : Constant 1 Bytes - 50 - $00000050 80
628                                    pos -= cols
Addr : 09BC:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
629                                    if pos < 0
Addr : 09C0:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 09C3:             35  : Constant 1 $00000000
Addr : 09C4:             F9  : Math Op <     
Addr : 09C5: JZ Label0027
Addr : 09C5:          0A 06  : jz Address = 09CD 6
Addr : 09C7:          38 50  : Constant 1 Bytes - 50 - $00000050 80
630                                        pos += cols
Addr : 09C9:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
Addr : 09CD: Label0027
Addr : 09CD: Label0028
Addr : 09CD: CaseDone Label0026
Addr : 09CD:             0C  : Casedone      
Addr : 09CE: Label0029
633                                    if inRegion
Addr : 09CE:             00  : Drop Anchor Push 
Addr : 09CF:          05 16  : Call Sub 22   
Addr : 09D1: JZ Label002A
Addr : 09D1:          0A 03  : jz Address = 09D6 3
634                                        scrollUp
Addr : 09D3:             01  : Drop Anchor   
Addr : 09D4:          05 17  : Call Sub 23   
Addr : 09D6: Label002A
Addr : 09D6: Label002B
Addr : 09D6: CaseDone Label0029
Addr : 09D6:             0C  : Casedone      
Addr : 09D7: Label002C
637                                    if inRegion
Addr : 09D7:             00  : Drop Anchor Push 
Addr : 09D8:          05 16  : Call Sub 22   
Addr : 09DA: JZ Label002D
Addr : 09DA:          0A 03  : jz Address = 09DF 3
638                                        scrollDown
Addr : 09DC:             01  : Drop Anchor   
Addr : 09DD:          05 18  : Call Sub 24   
Addr : 09DF: Label002D
Addr : 09DF: Label002E
Addr : 09DF: CaseDone Label002C
Addr : 09DF:             0C  : Casedone      
Addr : 09E0: Label002F
641                                    pos := 0
Addr : 09E0:             35  : Constant 1 $00000000
Addr : 09E1:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 09E4: CaseDone Label002F
Addr : 09E4:             0C  : Casedone      
Addr : 09E5: Label0030
644                                    state := 5
Addr : 09E5:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 09E7:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 09EA:             32  : Return        
Addr : 09EB: CaseDone Label0030
Addr : 09EB:             0C  : Casedone      
Addr : 09EC: Label001E
647                            state := 0
Addr : 09EC:             35  : Constant 1 $00000000
Addr : 09ED:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 09F0:             32  : Return        
Addr : 09F1: CaseDone Label001D
Addr : 09F1:             0C  : Casedone      
Addr : 09F2: Label0031
651                            if (c => "0") AND (c =< "9")
Addr : 09F2:             64  : Variable Operation Local Offset - 1 Read
Addr : 09F3:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 09F5:             FE  : Math Op =>    
Addr : 09F6:             64  : Variable Operation Local Offset - 1 Read
Addr : 09F7:          38 39  : Constant 1 Bytes - 39 - $00000039 57
Addr : 09F9:             FD  : Math Op =<    
Addr : 09FA:             F0  : Math Op AND   
Addr : 09FB: JZ Label0032
Addr : 09FB:          0A 1B  : jz Address = 0A18 27
652                                if arg0 == -1
Addr : 09FD:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 09FF:             34  : Constant 0 $FFFFFFFF
Addr : 0A00:             FC  : Math Op ==    
Addr : 0A01: JZ Label0034
Addr : 0A01:          0A 08  : jz Address = 0A0B 8
653                                    arg0 := c - "0"
Addr : 0A03:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A04:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A06:             ED  : Math Op -     
Addr : 0A07:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0A09: JMP Label0035
Addr : 0A09:          04 0C  : Jmp 0A17 12   
Addr : 0A0B: Label0034
655                                    arg0 := (arg0 * 10) + (c - "0")
Addr : 0A0B:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0A0D:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 0A0F:             F4  : Math Op *     
Addr : 0A10:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A11:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A13:             ED  : Math Op -     
Addr : 0A14:             EC  : Math Op +     
Addr : 0A15:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0A17: Label0036
Addr : 0A17: Label0035
Addr : 0A17:             32  : Return        
Addr : 0A18: Label0032
Addr : 0A18: Label0033
658                            if c == ";"
Addr : 0A18:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A19:          38 3B  : Constant 1 Bytes - 3B - $0000003B 59
Addr : 0A1B:             FC  : Math Op ==    
Addr : 0A1C: JZ Label0037
Addr : 0A1C:          0A 06  : jz Address = 0A24 6
659                                state := 3
Addr : 0A1E:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 0A20:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 0A23:             32  : Return        
Addr : 0A24: Label0037
Addr : 0A24: Label0038
662                            ansi(c)
Addr : 0A24:             01  : Drop Anchor   
Addr : 0A25:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A26:          05 19  : Call Sub 25   
663                            setCursorPos(pos)
Addr : 0A28:             01  : Drop Anchor   
Addr : 0A29:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0A2C:          05 11  : Call Sub 17   
Addr : 0A2E:             32  : Return        
Addr : 0A2F: CaseDone Label0031
Addr : 0A2F:             0C  : Casedone      
Addr : 0A30: Label0039
667                            if (c => "0") AND (c =< "9")
Addr : 0A30:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A31:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A33:             FE  : Math Op =>    
Addr : 0A34:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A35:          38 39  : Constant 1 Bytes - 39 - $00000039 57
Addr : 0A37:             FD  : Math Op =<    
Addr : 0A38:             F0  : Math Op AND   
Addr : 0A39: JZ Label003A
Addr : 0A39:          0A 1B  : jz Address = 0A56 27
668                                if arg1 == -1
Addr : 0A3B:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0A3D:             34  : Constant 0 $FFFFFFFF
Addr : 0A3E:             FC  : Math Op ==    
Addr : 0A3F: JZ Label003C
Addr : 0A3F:          0A 08  : jz Address = 0A49 8
669                                    arg1 := c - "0"
Addr : 0A41:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A42:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A44:             ED  : Math Op -     
Addr : 0A45:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0A47: JMP Label003D
Addr : 0A47:          04 0C  : Jmp 0A55 12   
Addr : 0A49: Label003C
671                                    arg1 := (arg1 * 10) + (c - "0")
Addr : 0A49:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0A4B:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 0A4D:             F4  : Math Op *     
Addr : 0A4E:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A4F:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A51:             ED  : Math Op -     
Addr : 0A52:             EC  : Math Op +     
Addr : 0A53:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0A55: Label003E
Addr : 0A55: Label003D
Addr : 0A55:             32  : Return        
Addr : 0A56: Label003A
Addr : 0A56: Label003B
674                            if c == ";"
Addr : 0A56:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A57:          38 3B  : Constant 1 Bytes - 3B - $0000003B 59
Addr : 0A59:             FC  : Math Op ==    
Addr : 0A5A: JZ Label003F
Addr : 0A5A:          0A 06  : jz Address = 0A62 6
675                                state := 4
Addr : 0A5C:          37 01  : Constant Mask Y=1 00000004 4
Addr : 0A5E:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 0A61:             32  : Return        
Addr : 0A62: Label003F
Addr : 0A62: Label0040
678                            ansi(c)
Addr : 0A62:             01  : Drop Anchor   
Addr : 0A63:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A64:          05 19  : Call Sub 25   
679                            setCursorPos(pos)
Addr : 0A66:             01  : Drop Anchor   
Addr : 0A67:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0A6A:          05 11  : Call Sub 17   
Addr : 0A6C:             32  : Return        
Addr : 0A6D: CaseDone Label0039
Addr : 0A6D:             0C  : Casedone      
Addr : 0A6E: Label0041
683                            if (c => "0") AND (c =< "9")
Addr : 0A6E:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A6F:          38 30  : Constant 1 Bytes - 30 - $00000030 48
Addr : 0A71:             FE  : Math Op =>    
Addr : 0A72:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A73:          38 39  : Constant 1 Bytes - 39 - $00000039 57
Addr : 0A75:             FD  : Math Op =<    
Addr : 0A76:             F0  : Math Op AND   
Addr : 0A77: JZ Label0042
Addr : 0A77:          0A 01  : jz Address = 0A7A 1
Addr : 0A79:             32  : Return        
Addr : 0A7A: Label0042
Addr : 0A7A: Label0043
686                            if c == ";"
Addr : 0A7A:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A7B:          38 3B  : Constant 1 Bytes - 3B - $0000003B 59
Addr : 0A7D:             FC  : Math Op ==    
Addr : 0A7E: JZ Label0044
Addr : 0A7E:          0A 01  : jz Address = 0A81 1
Addr : 0A80:             32  : Return        
Addr : 0A81: Label0044
Addr : 0A81: Label0045
688                            ansi(c)
Addr : 0A81:             01  : Drop Anchor   
Addr : 0A82:             64  : Variable Operation Local Offset - 1 Read
Addr : 0A83:          05 19  : Call Sub 25   
689                            setCursorPos(pos)
Addr : 0A85:             01  : Drop Anchor   
Addr : 0A86:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0A89:          05 11  : Call Sub 17   
Addr : 0A8B:             32  : Return        
Addr : 0A8C: CaseDone Label0041
Addr : 0A8C:             0C  : Casedone      
Addr : 0A8D: Label0046
693                          state := 0
Addr : 0A8D:             35  : Constant 1 $00000000
Addr : 0A8E:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
Addr : 0A91:             32  : Return        
Addr : 0A92: CaseDone Label0046
Addr : 0A92: Data : 0C                       .
Addr : 0A93: Label0002
Addr : 0A93: Data : 32                       2
Addr : 0A94: Data : 32                       2
|===========================================================================|
Spin Block inRegion with 0 Parameters and 0 Extra Stack Longs. Method 22
PRI inRegion : answer

Local Parameter DBASE:0000 - answer
|===========================================================================|
404                        answer := (pos => regionTop) AND (pos < regionBot)
Addr : 0A95:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0A98:       A8 80 94  : Memory Op Word VBASE + READ Address = 0094
Addr : 0A9B:             FE  : Math Op =>    
Addr : 0A9C:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0A9F:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0AA2:             F9  : Math Op <     
Addr : 0AA3:             F0  : Math Op AND   
Addr : 0AA4:             61  : Variable Operation Local Offset - 0 Write
Addr : 0AA5:             32  : Return        
|===========================================================================|
Spin Block scrollUp with 0 Parameters and 0 Extra Stack Longs. Method 23
PRI scrollUp

Local Parameter DBASE:0000 - Result
|===========================================================================|
407                        delLine(regionTop)
Addr : 0AA6:             01  : Drop Anchor   
Addr : 0AA7:       A8 80 94  : Memory Op Word VBASE + READ Address = 0094
Addr : 0AAA:          05 10  : Call Sub 16   
408                        if regionBot < maxChars
Addr : 0AAC:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0AAF:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0AB2:             F9  : Math Op <     
Addr : 0AB3: JZ Label0002
Addr : 0AB3:          0A 06  : jz Address = 0ABB 6
409                          insLine(regionBot)
Addr : 0AB5:             01  : Drop Anchor   
Addr : 0AB6:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0AB9:          05 12  : Call Sub 18   
Addr : 0ABB: Label0002
Addr : 0ABB: Label0003
Addr : 0ABB:             32  : Return        
|===========================================================================|
Spin Block scrollDown with 0 Parameters and 0 Extra Stack Longs. Method 24
PRI scrollDown

Local Parameter DBASE:0000 - Result
|===========================================================================|
412                        if regionBot < maxChars
Addr : 0ABC:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0ABF:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0AC2:             F9  : Math Op <     
Addr : 0AC3: JZ Label0002
Addr : 0AC3:          0A 06  : jz Address = 0ACB 6
413                          delLine(regionBot)
Addr : 0AC5:             01  : Drop Anchor   
Addr : 0AC6:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0AC9:          05 10  : Call Sub 16   
Addr : 0ACB: Label0002
Addr : 0ACB: Label0003
414                        insLine(regionTop)
Addr : 0ACB:             01  : Drop Anchor   
Addr : 0ACC:       A8 80 94  : Memory Op Word VBASE + READ Address = 0094
Addr : 0ACF:          05 12  : Call Sub 18   
Addr : 0AD1:             32  : Return        
|===========================================================================|
Spin Block ansi with 1 Parameters and 2 Extra Stack Longs. Method 25
PRI ansi(c) | x, defVal

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
Local Variable  DBASE:0008 - x
Local Variable  DBASE:000C - defVal
|===========================================================================|
418                        state := 0
Addr : 0AD2:             35  : Constant 1 $00000000
Addr : 0AD3:       89 8D 72  : Memory Op Byte VBASE + WRITE Address = 0D72
420                        if (c <> "r") AND (c <> "J") AND (c <> "m") AND (c <> "K")
Addr : 0AD6:             64  : Variable Operation Local Offset - 1 Read
Addr : 0AD7:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 0AD9:             FB  : Math Op <>    
Addr : 0ADA:             64  : Variable Operation Local Offset - 1 Read
Addr : 0ADB:          38 4A  : Constant 1 Bytes - 4A - $0000004A 74
Addr : 0ADD:             FB  : Math Op <>    
Addr : 0ADE:             F0  : Math Op AND   
Addr : 0ADF:             64  : Variable Operation Local Offset - 1 Read
Addr : 0AE0:          38 6D  : Constant 1 Bytes - 6D - $0000006D 109
Addr : 0AE2:             FB  : Math Op <>    
Addr : 0AE3:             F0  : Math Op AND   
Addr : 0AE4:             64  : Variable Operation Local Offset - 1 Read
Addr : 0AE5:          38 4B  : Constant 1 Bytes - 4B - $0000004B 75
Addr : 0AE7:             FB  : Math Op <>    
Addr : 0AE8:             F0  : Math Op AND   
Addr : 0AE9: JZ Label0002
Addr : 0AE9:          0A 12  : jz Address = 0AFD 18
421                            if arg0 == -1
Addr : 0AEB:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0AED:             34  : Constant 0 $FFFFFFFF
Addr : 0AEE:             FC  : Math Op ==    
Addr : 0AEF: JZ Label0004
Addr : 0AEF:          0A 03  : jz Address = 0AF4 3
422                                arg0 := 1
Addr : 0AF1:             36  : Constant 2 $00000001
Addr : 0AF2:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0AF4: Label0004
Addr : 0AF4: Label0005
423                            if arg1 == -1
Addr : 0AF4:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0AF6:             34  : Constant 0 $FFFFFFFF
Addr : 0AF7:             FC  : Math Op ==    
Addr : 0AF8: JZ Label0006
Addr : 0AF8:          0A 03  : jz Address = 0AFD 3
424                                arg1 := 1
Addr : 0AFA:             36  : Constant 2 $00000001
Addr : 0AFB:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0AFD: Label0006
Addr : 0AFD: Label0007
Addr : 0AFD: Label0002
Addr : 0AFD: Label0003
Addr : 0AFD: Constant Address of Label0008
Addr : 0AFD:       39 09 CC  : Constant 2 Bytes - 09 CC - $000009CC 2508
426                        case c
Addr : 0B00:             64  : Variable Operation Local Offset - 1 Read
427                          "@":
Addr : 0B01:          37 05  : Constant Mask Y=5 00000040 64
Addr : 0B03: Case_Value Label0009
Addr : 0B03:       0D 80 4C  : Value Case Address = 0B52 76
431                          "b":
Addr : 0B06:          38 62  : Constant 1 Bytes - 62 - $00000062 98
Addr : 0B08: Case_Value Label000D
Addr : 0B08:       0D 80 57  : Value Case Address = 0B62 87
435                          "d":
Addr : 0B0B:          38 64  : Constant 1 Bytes - 64 - $00000064 100
Addr : 0B0D: Case_Value Label0011
Addr : 0B0D:       0D 80 62  : Value Case Address = 0B72 98
440                          "m":
Addr : 0B10:          38 6D  : Constant 1 Bytes - 6D - $0000006D 109
Addr : 0B12: Case_Value Label0014
Addr : 0B12:       0D 80 7F  : Value Case Address = 0B94 127
445                          "r":
Addr : 0B15:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 0B17: Case_Value Label0017
Addr : 0B17:       0D 80 8B  : Value Case Address = 0BA5 139
461                          "A":
Addr : 0B1A:          38 41  : Constant 1 Bytes - 41 - $00000041 65
Addr : 0B1C: Case_Value Label0020
Addr : 0B1C:       0D 80 D4  : Value Case Address = 0BF3 212
468                          "B":
Addr : 0B1F:          38 42  : Constant 1 Bytes - 42 - $00000042 66
Addr : 0B21: Case_Value Label0026
Addr : 0B21:       0D 80 ED  : Value Case Address = 0C11 237
475                          "C":
Addr : 0B24:          38 43  : Constant 1 Bytes - 43 - $00000043 67
Addr : 0B26: Case_Value Label002C
Addr : 0B26:       0D 81 08  : Value Case Address = 0C31 264
482                          "D":
Addr : 0B29:          38 44  : Constant 1 Bytes - 44 - $00000044 68
Addr : 0B2B: Case_Value Label0032
Addr : 0B2B:       0D 81 21  : Value Case Address = 0C4F 289
489                          "G":
Addr : 0B2E:          38 47  : Constant 1 Bytes - 47 - $00000047 71
Addr : 0B30: Case_Value Label0038
Addr : 0B30:       0D 81 37  : Value Case Address = 0C6A 311
494                          "H":
Addr : 0B33:          38 48  : Constant 1 Bytes - 48 - $00000048 72
Addr : 0B35: Case_Value Label003B
Addr : 0B35:       0D 81 55  : Value Case Address = 0C8D 341
505                          "J":
Addr : 0B38:          38 4A  : Constant 1 Bytes - 4A - $0000004A 74
Addr : 0B3A: Case_Value Label0044
Addr : 0B3A:       0D 81 8E  : Value Case Address = 0CCB 398
525                          "K":
Addr : 0B3D:          38 4B  : Constant 1 Bytes - 4B - $0000004B 75
Addr : 0B3F: Case_Value Label004F
Addr : 0B3F:       0D 81 E2  : Value Case Address = 0D24 482
533                          "L":
Addr : 0B42:          38 4C  : Constant 1 Bytes - 4C - $0000004C 76
Addr : 0B44: Case_Value Label0054
Addr : 0B44:       0D 82 07  : Value Case Address = 0D4E 519
540                          "M":
Addr : 0B47:          38 4D  : Constant 1 Bytes - 4D - $0000004D 77
Addr : 0B49: Case_Value Label005C
Addr : 0B49:       0D 82 26  : Value Case Address = 0D72 550
547                          "P":
Addr : 0B4C:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0B4E: Case_Value Label0064
Addr : 0B4E:       0D 82 45  : Value Case Address = 0D96 581
Addr : 0B51: CaseDone Label0064
Addr : 0B51:             0C  : Casedone      
Addr : 0B52: Label0009
Addr : 0B52: Label000A
428                            repeat while arg0-- > 0
Addr : 0B52:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0B55:             35  : Constant 1 $00000000
Addr : 0B56:             FA  : Math Op >     
Addr : 0B57: JZ Label000C
Addr : 0B57:          0A 08  : jz Address = 0B61 8
429                              insChar(pos)
Addr : 0B59:             01  : Drop Anchor   
Addr : 0B5A:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0B5D:          05 13  : Call Sub 19   
Addr : 0B5F: Label000B
Addr : 0B5F: JMP Label000A
Addr : 0B5F:          04 71  : Jmp 0B52 -15  
Addr : 0B61: Label000C
Addr : 0B61: CaseDone Label0009
Addr : 0B61:             0C  : Casedone      
Addr : 0B62: Label000D
Addr : 0B62: Label000E
432                            repeat while arg0-- > 0
Addr : 0B62:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0B65:             35  : Constant 1 $00000000
Addr : 0B66:             FA  : Math Op >     
Addr : 0B67: JZ Label0010
Addr : 0B67:          0A 08  : jz Address = 0B71 8
433                              outc(lastc)
Addr : 0B69:             01  : Drop Anchor   
Addr : 0B6A:       88 8D 73  : Memory Op Byte VBASE + READ Address = 0D73
Addr : 0B6D:          05 1A  : Call Sub 26   
Addr : 0B6F: Label000F
Addr : 0B6F: JMP Label000E
Addr : 0B6F:          04 71  : Jmp 0B62 -15  
Addr : 0B71: Label0010
Addr : 0B71: CaseDone Label000D
Addr : 0B71:             0C  : Casedone      
Addr : 0B72: Label0011
436                            if (arg0 < 1) OR (arg0 > rows)
Addr : 0B72:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0B74:             36  : Constant 2 $00000001
Addr : 0B75:             F9  : Math Op <     
Addr : 0B76:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0B78:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 0B7A:             FA  : Math Op >     
Addr : 0B7B:             F2  : Math Op OR    
Addr : 0B7C: JZ Label0012
Addr : 0B7C:          0A 04  : jz Address = 0B82 4
Addr : 0B7E:          38 28  : Constant 1 Bytes - 28 - $00000028 40
437                              arg0 := rows
Addr : 0B80:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0B82: Label0012
Addr : 0B82: Label0013
438                            pos := ((arg0 - 1) * cols) + (pos // cols)
Addr : 0B82:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0B84:             36  : Constant 2 $00000001
Addr : 0B85:             ED  : Math Op -     
Addr : 0B86:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0B88:             F4  : Math Op *     
Addr : 0B89:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0B8C:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0B8E:             F7  : Math Op //    
Addr : 0B8F:             EC  : Math Op +     
Addr : 0B90:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0B93: CaseDone Label0011
Addr : 0B93:             0C  : Casedone      
Addr : 0B94: Label0014
441                            setInv(arg0)
Addr : 0B94:             01  : Drop Anchor   
Addr : 0B95:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0B97:          05 0D  : Call Sub 13   
442                            if arg1 <> -1
Addr : 0B99:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0B9B:             34  : Constant 0 $FFFFFFFF
Addr : 0B9C:             FB  : Math Op <>    
Addr : 0B9D: JZ Label0015
Addr : 0B9D:          0A 05  : jz Address = 0BA4 5
443                              setInv(arg1)
Addr : 0B9F:             01  : Drop Anchor   
Addr : 0BA0:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0BA2:          05 0D  : Call Sub 13   
Addr : 0BA4: Label0015
Addr : 0BA4: Label0016
Addr : 0BA4: CaseDone Label0014
Addr : 0BA4:             0C  : Casedone      
Addr : 0BA5: Label0017
446                            if arg0 < 1
Addr : 0BA5:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0BA7:             36  : Constant 2 $00000001
Addr : 0BA8:             F9  : Math Op <     
Addr : 0BA9: JZ Label0018
Addr : 0BA9:          0A 05  : jz Address = 0BB0 5
447                              arg0 := 1
Addr : 0BAB:             36  : Constant 2 $00000001
Addr : 0BAC:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0BAE: JMP Label0019
Addr : 0BAE:          04 0B  : Jmp 0BBB 11   
Addr : 0BB0: Label0018
448                            elseif arg0 > cols
Addr : 0BB0:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0BB2:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0BB4:             FA  : Math Op >     
Addr : 0BB5: JZ Label001A
Addr : 0BB5:          0A 04  : jz Address = 0BBB 4
Addr : 0BB7:          38 50  : Constant 1 Bytes - 50 - $00000050 80
449                              arg0 := cols
Addr : 0BB9:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0BBB: Label001A
Addr : 0BBB: Label0019
450                            if arg1 < 1
Addr : 0BBB:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0BBD:             36  : Constant 2 $00000001
Addr : 0BBE:             F9  : Math Op <     
Addr : 0BBF: JZ Label001B
Addr : 0BBF:          0A 05  : jz Address = 0BC6 5
451                              arg1 := 1
Addr : 0BC1:             36  : Constant 2 $00000001
Addr : 0BC2:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0BC4: JMP Label001C
Addr : 0BC4:          04 0B  : Jmp 0BD1 11   
Addr : 0BC6: Label001B
452                            elseif arg1 > cols
Addr : 0BC6:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0BC8:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0BCA:             FA  : Math Op >     
Addr : 0BCB: JZ Label001D
Addr : 0BCB:          0A 04  : jz Address = 0BD1 4
Addr : 0BCD:          38 50  : Constant 1 Bytes - 50 - $00000050 80
453                              arg1 := cols
Addr : 0BCF:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0BD1: Label001D
Addr : 0BD1: Label001C
454                            if arg1 < arg0
Addr : 0BD1:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0BD3:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0BD5:             F9  : Math Op <     
Addr : 0BD6: JZ Label001E
Addr : 0BD6:          0A 04  : jz Address = 0BDC 4
455                              arg1 := arg0
Addr : 0BD8:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0BDA:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0BDC: Label001E
Addr : 0BDC: Label001F
457                            regionTop := (arg0 - 1) * cols
Addr : 0BDC:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0BDE:             36  : Constant 2 $00000001
Addr : 0BDF:             ED  : Math Op -     
Addr : 0BE0:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0BE2:             F4  : Math Op *     
Addr : 0BE3:       A9 80 94  : Memory Op Word VBASE + WRITE Address = 0094
458                            regionBot := arg1 * cols
Addr : 0BE6:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0BE8:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0BEA:             F4  : Math Op *     
Addr : 0BEB:       A9 80 96  : Memory Op Word VBASE + WRITE Address = 0096
459                            pos := 0
Addr : 0BEE:             35  : Constant 1 $00000000
Addr : 0BEF:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0BF2: CaseDone Label0017
Addr : 0BF2:             0C  : Casedone      
Addr : 0BF3: Label0020
Addr : 0BF3: Label0021
462                            repeat while arg0-- > 0
Addr : 0BF3:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0BF6:             35  : Constant 1 $00000000
Addr : 0BF7:             FA  : Math Op >     
Addr : 0BF8: JZ Label0023
Addr : 0BF8:          0A 16  : jz Address = 0C10 22
Addr : 0BFA:          38 50  : Constant 1 Bytes - 50 - $00000050 80
463                              pos -= cols
Addr : 0BFC:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
464                              if pos < 0
Addr : 0C00:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C03:             35  : Constant 1 $00000000
Addr : 0C04:             F9  : Math Op <     
Addr : 0C05: JZ Label0024
Addr : 0C05:          0A 07  : jz Address = 0C0E 7
Addr : 0C07:          38 50  : Constant 1 Bytes - 50 - $00000050 80
465                                pos += cols
Addr : 0C09:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
Addr : 0C0D:             32  : Return        
Addr : 0C0E: Label0024
Addr : 0C0E: Label0025
Addr : 0C0E: Label0022
Addr : 0C0E: JMP Label0021
Addr : 0C0E:          04 63  : Jmp 0BF3 -29  
Addr : 0C10: Label0023
Addr : 0C10: CaseDone Label0020
Addr : 0C10:             0C  : Casedone      
Addr : 0C11: Label0026
Addr : 0C11: Label0027
469                            repeat while arg0-- > 0
Addr : 0C11:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0C14:             35  : Constant 1 $00000000
Addr : 0C15:             FA  : Math Op >     
Addr : 0C16: JZ Label0029
Addr : 0C16:          0A 18  : jz Address = 0C30 24
Addr : 0C18:          38 50  : Constant 1 Bytes - 50 - $00000050 80
470                              pos += cols
Addr : 0C1A:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
471                              if pos => maxChars
Addr : 0C1E:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C21:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0C24:             FE  : Math Op =>    
Addr : 0C25: JZ Label002A
Addr : 0C25:          0A 07  : jz Address = 0C2E 7
Addr : 0C27:          38 50  : Constant 1 Bytes - 50 - $00000050 80
472                                pos -= cols
Addr : 0C29:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 0C2D:             32  : Return        
Addr : 0C2E: Label002A
Addr : 0C2E: Label002B
Addr : 0C2E: Label0028
Addr : 0C2E: JMP Label0027
Addr : 0C2E:          04 61  : Jmp 0C11 -31  
Addr : 0C30: Label0029
Addr : 0C30: CaseDone Label0026
Addr : 0C30:             0C  : Casedone      
Addr : 0C31: Label002C
Addr : 0C31: Label002D
476                            repeat while arg0-- > 0
Addr : 0C31:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0C34:             35  : Constant 1 $00000000
Addr : 0C35:             FA  : Math Op >     
Addr : 0C36: JZ Label002F
Addr : 0C36:          0A 16  : jz Address = 0C4E 22
477                              pos += 1
Addr : 0C38:             36  : Constant 2 $00000001
Addr : 0C39:    AA 80 90 4C  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop +
478                              if pos => maxChars
Addr : 0C3D:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C40:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0C43:             FE  : Math Op =>    
Addr : 0C44: JZ Label0030
Addr : 0C44:          0A 06  : jz Address = 0C4C 6
479                                pos -= 1
Addr : 0C46:             36  : Constant 2 $00000001
Addr : 0C47:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 0C4B:             32  : Return        
Addr : 0C4C: Label0030
Addr : 0C4C: Label0031
Addr : 0C4C: Label002E
Addr : 0C4C: JMP Label002D
Addr : 0C4C:          04 63  : Jmp 0C31 -29  
Addr : 0C4E: Label002F
Addr : 0C4E: CaseDone Label002C
Addr : 0C4E:             0C  : Casedone      
Addr : 0C4F: Label0032
Addr : 0C4F: Label0033
483                            repeat while arg0-- > 0
Addr : 0C4F:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0C52:             35  : Constant 1 $00000000
Addr : 0C53:             FA  : Math Op >     
Addr : 0C54: JZ Label0035
Addr : 0C54:          0A 13  : jz Address = 0C69 19
484                              pos -= 1
Addr : 0C56:             36  : Constant 2 $00000001
Addr : 0C57:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
485                              if pos < 0
Addr : 0C5B:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C5E:             35  : Constant 1 $00000000
Addr : 0C5F:             F9  : Math Op <     
Addr : 0C60: JZ Label0036
Addr : 0C60:          0A 05  : jz Address = 0C67 5
486                                pos := 0
Addr : 0C62:             35  : Constant 1 $00000000
Addr : 0C63:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0C66:             32  : Return        
Addr : 0C67: Label0036
Addr : 0C67: Label0037
Addr : 0C67: Label0034
Addr : 0C67: JMP Label0033
Addr : 0C67:          04 66  : Jmp 0C4F -26  
Addr : 0C69: Label0035
Addr : 0C69: CaseDone Label0032
Addr : 0C69:             0C  : Casedone      
Addr : 0C6A: Label0038
490                            if (arg0 < 1) OR (arg0 > cols)
Addr : 0C6A:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0C6C:             36  : Constant 2 $00000001
Addr : 0C6D:             F9  : Math Op <     
Addr : 0C6E:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0C70:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0C72:             FA  : Math Op >     
Addr : 0C73:             F2  : Math Op OR    
Addr : 0C74: JZ Label0039
Addr : 0C74:          0A 04  : jz Address = 0C7A 4
Addr : 0C76:          38 50  : Constant 1 Bytes - 50 - $00000050 80
491                              arg0 := cols
Addr : 0C78:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0C7A: Label0039
Addr : 0C7A: Label003A
492                           pos := (pos - (pos // cols)) + (arg0 - 1)
Addr : 0C7A:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C7D:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0C80:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0C82:             F7  : Math Op //    
Addr : 0C83:             ED  : Math Op -     
Addr : 0C84:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0C86:             36  : Constant 2 $00000001
Addr : 0C87:             ED  : Math Op -     
Addr : 0C88:             EC  : Math Op +     
Addr : 0C89:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0C8C: CaseDone Label0038
Addr : 0C8C:             0C  : Casedone      
Addr : 0C8D: Label003B
495                            if arg0 =< 0
Addr : 0C8D:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0C8F:             35  : Constant 1 $00000000
Addr : 0C90:             FD  : Math Op =<    
Addr : 0C91: JZ Label003C
Addr : 0C91:          0A 03  : jz Address = 0C96 3
496                              arg0 := 1
Addr : 0C93:             36  : Constant 2 $00000001
Addr : 0C94:          C9 38  : Memory Op Long VBASE + WRITE Address = 0038
Addr : 0C96: Label003C
Addr : 0C96: Label003D
497                            if arg1 =< 0
Addr : 0C96:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0C98:             35  : Constant 1 $00000000
Addr : 0C99:             FD  : Math Op =<    
Addr : 0C9A: JZ Label003E
Addr : 0C9A:          0A 03  : jz Address = 0C9F 3
498                              arg1 := 1
Addr : 0C9C:             36  : Constant 2 $00000001
Addr : 0C9D:          C9 3C  : Memory Op Long VBASE + WRITE Address = 003C
Addr : 0C9F: Label003E
Addr : 0C9F: Label003F
Addr : 0C9F:          38 50  : Constant 1 Bytes - 50 - $00000050 80
499                            pos := (cols * (arg0 - 1)) + (arg1 - 1)
Addr : 0CA1:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0CA3:             36  : Constant 2 $00000001
Addr : 0CA4:             ED  : Math Op -     
Addr : 0CA5:             F4  : Math Op *     
Addr : 0CA6:          C8 3C  : Memory Op Long VBASE + READ Address = 003C
Addr : 0CA8:             36  : Constant 2 $00000001
Addr : 0CA9:             ED  : Math Op -     
Addr : 0CAA:             EC  : Math Op +     
Addr : 0CAB:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
500                            if pos < 0
Addr : 0CAE:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0CB1:             35  : Constant 1 $00000000
Addr : 0CB2:             F9  : Math Op <     
Addr : 0CB3: JZ Label0040
Addr : 0CB3:          0A 04  : jz Address = 0CB9 4
501                              pos := 0
Addr : 0CB5:             35  : Constant 1 $00000000
Addr : 0CB6:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0CB9: Label0040
Addr : 0CB9: Label0041
502                            if pos => maxChars
Addr : 0CB9:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0CBC:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0CBF:             FE  : Math Op =>    
Addr : 0CC0: JZ Label0042
Addr : 0CC0:          0A 08  : jz Address = 0CCA 8
Addr : 0CC2:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
503                              pos := maxChars - 1
Addr : 0CC5:             36  : Constant 2 $00000001
Addr : 0CC6:             ED  : Math Op -     
Addr : 0CC7:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0CCA: Label0042
Addr : 0CCA: Label0043
Addr : 0CCA: CaseDone Label003B
Addr : 0CCA:             0C  : Casedone      
Addr : 0CCB: Label0044
506                            if arg0 == 1
Addr : 0CCB:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0CCD:             36  : Constant 2 $00000001
Addr : 0CCE:             FC  : Math Op ==    
Addr : 0CCF: JZ Label0045
Addr : 0CCF:          0A 23  : jz Address = 0CF4 35
507                              clBOL(pos)
Addr : 0CD1:             01  : Drop Anchor   
Addr : 0CD2:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0CD5:          05 0F  : Call Sub 15   
508                              x := pos - cols
Addr : 0CD7:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0CDA:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0CDC:             ED  : Math Op -     
Addr : 0CDD:             69  : Variable Operation Local Offset - 2 Write
509                              x -= x // cols
Addr : 0CDE:             68  : Variable Operation Local Offset - 2 Read
Addr : 0CDF:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0CE1:             F7  : Math Op //    
Addr : 0CE2:          6A 4D  : Variable Operation Local Offset - 2 Assign WordMathop -
Addr : 0CE4: Label0047
510                              repeat while x => 0
Addr : 0CE4:             68  : Variable Operation Local Offset - 2 Read
Addr : 0CE5:             35  : Constant 1 $00000000
Addr : 0CE6:             FE  : Math Op =>    
Addr : 0CE7: JZ Label0049
Addr : 0CE7:          0A 0A  : jz Address = 0CF3 10
511                                clEOL(x)
Addr : 0CE9:             01  : Drop Anchor   
Addr : 0CEA:             68  : Variable Operation Local Offset - 2 Read
Addr : 0CEB:          05 0E  : Call Sub 14   
Addr : 0CED:          38 50  : Constant 1 Bytes - 50 - $00000050 80
512                                x -= cols
Addr : 0CEF:          6A 4D  : Variable Operation Local Offset - 2 Assign WordMathop -
Addr : 0CF1: Label0048
Addr : 0CF1: JMP Label0047
Addr : 0CF1:          04 71  : Jmp 0CE4 -15  
Addr : 0CF3: Label0049
Addr : 0CF3:             32  : Return        
Addr : 0CF4: Label0045
Addr : 0CF4: Label0046
515                            if arg0 == 2
Addr : 0CF4:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0CF6:          37 00  : Constant Mask Y=0 00000002 2
Addr : 0CF8:             FC  : Math Op ==    
Addr : 0CF9: JZ Label004A
Addr : 0CF9:          0A 04  : jz Address = 0CFF 4
516                              pos := 0
Addr : 0CFB:             35  : Constant 1 $00000000
Addr : 0CFC:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0CFF: Label004A
Addr : 0CFF: Label004B
518                            clEOL(pos)
Addr : 0CFF:             01  : Drop Anchor   
Addr : 0D00:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D03:          05 0E  : Call Sub 14   
519                            x := pos + cols
Addr : 0D05:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D08:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0D0A:             EC  : Math Op +     
Addr : 0D0B:             69  : Variable Operation Local Offset - 2 Write
520                            x -= (x // cols)
Addr : 0D0C:             68  : Variable Operation Local Offset - 2 Read
Addr : 0D0D:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0D0F:             F7  : Math Op //    
Addr : 0D10:          6A 4D  : Variable Operation Local Offset - 2 Assign WordMathop -
Addr : 0D12: Label004C
521                            repeat while x < maxChars
Addr : 0D12:             68  : Variable Operation Local Offset - 2 Read
Addr : 0D13:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0D16:             F9  : Math Op <     
Addr : 0D17: JZ Label004E
Addr : 0D17:          0A 0A  : jz Address = 0D23 10
522                              clEOL(x)
Addr : 0D19:             01  : Drop Anchor   
Addr : 0D1A:             68  : Variable Operation Local Offset - 2 Read
Addr : 0D1B:          05 0E  : Call Sub 14   
Addr : 0D1D:          38 50  : Constant 1 Bytes - 50 - $00000050 80
523                              x += cols
Addr : 0D1F:          6A 4C  : Variable Operation Local Offset - 2 Assign WordMathop +
Addr : 0D21: Label004D
Addr : 0D21: JMP Label004C
Addr : 0D21:          04 6F  : Jmp 0D12 -17  
Addr : 0D23: Label004E
Addr : 0D23: CaseDone Label0044
Addr : 0D23:             0C  : Casedone      
Addr : 0D24: Label004F
526                            if arg0 == -1
Addr : 0D24:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0D26:             34  : Constant 0 $FFFFFFFF
Addr : 0D27:             FC  : Math Op ==    
Addr : 0D28: JZ Label0050
Addr : 0D28:          0A 08  : jz Address = 0D32 8
527                                clEOL(pos)
Addr : 0D2A:             01  : Drop Anchor   
Addr : 0D2B:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D2E:          05 0E  : Call Sub 14   
Addr : 0D30: JMP Label0051
Addr : 0D30:          04 1B  : Jmp 0D4D 27   
Addr : 0D32: Label0050
528                            elseif arg0 == 1
Addr : 0D32:          C8 38  : Memory Op Long VBASE + READ Address = 0038
Addr : 0D34:             36  : Constant 2 $00000001
Addr : 0D35:             FC  : Math Op ==    
Addr : 0D36: JZ Label0052
Addr : 0D36:          0A 08  : jz Address = 0D40 8
529                                clBOL(pos)
Addr : 0D38:             01  : Drop Anchor   
Addr : 0D39:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D3C:          05 0F  : Call Sub 15   
Addr : 0D3E: JMP Label0051
Addr : 0D3E:          04 0D  : Jmp 0D4D 13   
Addr : 0D40: Label0052
531                                clEOL(pos - (pos // cols))
Addr : 0D40:             01  : Drop Anchor   
Addr : 0D41:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D44:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D47:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 0D49:             F7  : Math Op //    
Addr : 0D4A:             ED  : Math Op -     
Addr : 0D4B:          05 0E  : Call Sub 14   
Addr : 0D4D: Label0053
Addr : 0D4D: Label0051
Addr : 0D4D: CaseDone Label004F
Addr : 0D4D:             0C  : Casedone      
Addr : 0D4E: Label0054
534                            if inRegion
Addr : 0D4E:             00  : Drop Anchor Push 
Addr : 0D4F:          05 16  : Call Sub 22   
Addr : 0D51: JZ Label0055
Addr : 0D51:          0A 1E  : jz Address = 0D71 30
Addr : 0D53: Label0057
535                              repeat while arg0-- > 0
Addr : 0D53:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0D56:             35  : Constant 1 $00000000
Addr : 0D57:             FA  : Math Op >     
Addr : 0D58: JZ Label0059
Addr : 0D58:          0A 17  : jz Address = 0D71 23
536                                if regionBot < maxChars
Addr : 0D5A:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0D5D:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0D60:             F9  : Math Op <     
Addr : 0D61: JZ Label005A
Addr : 0D61:          0A 06  : jz Address = 0D69 6
537                                  delLine(regionBot)
Addr : 0D63:             01  : Drop Anchor   
Addr : 0D64:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0D67:          05 10  : Call Sub 16   
Addr : 0D69: Label005A
Addr : 0D69: Label005B
538                                insLine(pos)
Addr : 0D69:             01  : Drop Anchor   
Addr : 0D6A:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D6D:          05 12  : Call Sub 18   
Addr : 0D6F: Label0058
Addr : 0D6F: JMP Label0057
Addr : 0D6F:          04 62  : Jmp 0D53 -30  
Addr : 0D71: Label0059
Addr : 0D71: Label0055
Addr : 0D71: Label0056
Addr : 0D71: CaseDone Label0054
Addr : 0D71:             0C  : Casedone      
Addr : 0D72: Label005C
541                            if inRegion
Addr : 0D72:             00  : Drop Anchor Push 
Addr : 0D73:          05 16  : Call Sub 22   
Addr : 0D75: JZ Label005D
Addr : 0D75:          0A 1E  : jz Address = 0D95 30
Addr : 0D77: Label005F
542                              repeat while arg0-- > 0
Addr : 0D77:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0D7A:             35  : Constant 1 $00000000
Addr : 0D7B:             FA  : Math Op >     
Addr : 0D7C: JZ Label0061
Addr : 0D7C:          0A 17  : jz Address = 0D95 23
543                                delLine(pos)
Addr : 0D7E:             01  : Drop Anchor   
Addr : 0D7F:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D82:          05 10  : Call Sub 16   
544                                if regionBot < maxChars
Addr : 0D84:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0D87:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0D8A:             F9  : Math Op <     
Addr : 0D8B: JZ Label0062
Addr : 0D8B:          0A 06  : jz Address = 0D93 6
545                                  insLine(regionBot)            
Addr : 0D8D:             01  : Drop Anchor   
Addr : 0D8E:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0D91:          05 12  : Call Sub 18   
Addr : 0D93: Label0062
Addr : 0D93: Label0063
Addr : 0D93: Label0060
Addr : 0D93: JMP Label005F
Addr : 0D93:          04 62  : Jmp 0D77 -30  
Addr : 0D95: Label0061
Addr : 0D95: Label005D
Addr : 0D95: Label005E
Addr : 0D95: CaseDone Label005C
Addr : 0D95:             0C  : Casedone      
Addr : 0D96: Label0064
Addr : 0D96: Label0065
548                            repeat while arg0--
Addr : 0D96:       CA 38 BE  : Memory Op Long VBASE + ASSIGN Address = 0038 VAR-- post-dec Long Push
Addr : 0D99: JZ Label0067
Addr : 0D99:          0A 08  : jz Address = 0DA3 8
549                              delChar(pos)
Addr : 0D9B:             01  : Drop Anchor   
Addr : 0D9C:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0D9F:          05 14  : Call Sub 20   
Addr : 0DA1: Label0066
Addr : 0DA1: JMP Label0065
Addr : 0DA1:          04 73  : Jmp 0D96 -13  
Addr : 0DA3: Label0067
Addr : 0DA3: CaseDone Label0064
Addr : 0DA3:             0C  : Casedone      
Addr : 0DA4: Label0008
Addr : 0DA4:             32  : Return        
|===========================================================================|
Spin Block outc with 1 Parameters and 0 Extra Stack Longs. Method 26
PRI outc(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
553                        putc(pos++, lastc := c)  
Addr : 0DA5:             01  : Drop Anchor   
Addr : 0DA6:    AA 80 90 AC  : Memory Op Word VBASE + ASSIGN Address = 0090 VAR++ post inc Word Push
Addr : 0DAA:             64  : Variable Operation Local Offset - 1 Read
Addr : 0DAB:    8A 8D 73 80  : Memory Op Byte VBASE + ASSIGN Address = 0D73 Write Push
Addr : 0DAF:          05 0B  : Call Sub 11   
554                        if pos == regionBot
Addr : 0DB1:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0DB4:       A8 80 96  : Memory Op Word VBASE + READ Address = 0096
Addr : 0DB7:             FC  : Math Op ==    
Addr : 0DB8: JZ Label0002
Addr : 0DB8:          0A 0B  : jz Address = 0DC5 11
555                          scrollUp
Addr : 0DBA:             01  : Drop Anchor   
Addr : 0DBB:          05 17  : Call Sub 23   
Addr : 0DBD:          38 50  : Constant 1 Bytes - 50 - $00000050 80
556                          pos -= cols
Addr : 0DBF:    AA 80 90 4D  : Memory Op Word VBASE + ASSIGN Address = 0090 WordMathop -
Addr : 0DC3: JMP Label0003
Addr : 0DC3:          04 0F  : Jmp 0DD4 15   
Addr : 0DC5: Label0002
557                        elseif pos == maxChars
Addr : 0DC5:       A8 80 90  : Memory Op Word VBASE + READ Address = 0090
Addr : 0DC8:       39 0B 40  : Constant 2 Bytes - 0B 40 - $00000B40 2880
Addr : 0DCB:             FC  : Math Op ==    
Addr : 0DCC: JZ Label0004
Addr : 0DCC:          0A 06  : jz Address = 0DD4 6
Addr : 0DCE:       39 0A F0  : Constant 2 Bytes - 0A F0 - $00000AF0 2800
558                          pos := lastLine
Addr : 0DD1:       A9 80 90  : Memory Op Word VBASE + WRITE Address = 0090
Addr : 0DD4: Label0004
Addr : 0DD4: Label0003
Addr : 0DD4:             32  : Return        
|===========================================================================|
Object vga_Hires_Text
Object Base is 0DD8
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0008 Variable cog
|===========================================================================|
Object DAT Blocks
|===========================================================================|
0DE4(0000)             |                         org                             'set origin to $000 for start of program
0DE4(0000) 00 02 00 00 | d0                      long    1 << 9                  'd0 always resides here at $000, executes as NOP
0DE8(0001) 91 DE BF A0 | :move                   mov     $1EF,main_begin+main_size-1
0DEC(0002) 18 02 BC 84 |                         sub     :move,d0s0              '(do reverse move to avoid overwrite)
0DF0(0003) 01 34 FC E4 |                         djnz    main_ctr,#:move
0DF4(0004) 1C 02 BD A0 | :waitvid                mov     scancode+0,i0           'org     scancode
0DF8(0005) 1D 04 BD A0 | :shr                    mov     scancode+1,i1           'waitvid color,scanbuff+0
0DFC(0006) 19 08 BC 80 |                         add     :waitvid,d1             'shr     scanbuff+0,#8
0E00(0007) 19 0A BC 80 |                         add     :shr,d1                 'waitvid color,scanbuff+1
0E04(0008) 01 38 FC 80 |                         add     i0,#1                   'shr     scanbuff+1,#8
0E08(0009) 00 3A BC 80 |                         add     i1,d0                   '...
0E0C(000A) 04 36 FC E4 |                         djnz    scan_ctr,#:waitvid      'waitvid color,scanbuff+cols-1
0E10(000B) 1E 40 BE A0 |                         mov     scancode+cols*2-1,i2    'mov     vscl,#hf
0E14(000C) 1F 42 BE A0 |                         mov     scancode+cols*2+0,i3    'waitvid hvsync,#0
0E18(000D) 20 44 BE A0 |                         mov     scancode+cols*2+1,i4    'jmp     #scanret
0E1C(000E) 21 EC BF A0 |                         mov     dira,reg_dira           'set pin directions
0E20(000F) 22 EE BF A0 |                         mov     dirb,reg_dirb
0E24(0010) 18 F4 FF 58 |                         movi    frqa,#(pr / 5) << 2     'set pixel rate
0E28(0011) 23 FC BF A0 |                         mov     vcfg,reg_vcfg           'set video configuration
0E2C(0012) 01 FE FF A0 |                         mov     vscl,#1                 'set video to reload on every pixel
0E30(0013) E1 49 BC F8 |                         waitcnt sync_cnt,colormask      'wait for start value in cnt, add ~1ms
0E34(0014) 0E F0 FF 58 |                         movi    ctra,#%00001_110        'COGs in sync! enable PLLs now - NCOs locked!
0E38(0015) 00 48 FC F8 |                         waitcnt sync_cnt,#0             'wait ~1ms for PLLs to stabilize - PLLs locked!
0E3C(0016) 64 FE FF A0 |                         mov     vscl,#100               'insure initial WAITVIDs lock cleanly
0E40(0017) 83 01 7C 5C |                         jmp     #vsync                  'jump to vsync - WAITVIDs will now be locked!
0E44(0018) 01 02 00 00 | d0s0                    long    1 << 9 + 1
0E48(0019) 00 04 00 00 | d1                      long    1 << 10
0E4C(001A) 6D 00 00 00 | main_ctr                long    main_size
0E50(001B) 50 00 00 00 | scan_ctr                long    cols
0E54(001C) 01 D6 3F FC | i0                      waitvid x,scanbuff+0
0E58(001D) 08 02 FC 28 | i1                      shr     scanbuff+0,#8
0E5C(001E) 18 FE FF A0 | i2                      mov     vscl,#hf
0E60(001F) 00 CE 7F FC | i3                      waitvid hvsync,#0
0E64(0020) BE 01 7C 5C | i4                      jmp     #scanret
0E68(0021) 00 00 00 00 | reg_dira                long    0                       'set at runtime
0E6C(0022) 00 00 00 00 | reg_dirb                long    0                       'set at runtime
0E70(0023) 00 00 00 00 | reg_vcfg                long    0                       'set at runtime
0E74(0024) 00 00 00 00 | sync_cnt                long    0                       'set at runtime
0E78(0025)             |                         fit     scancode                'make sure initialization code and data fit
0E78(0025)             | There are 92 ($05C) Longs left in the cog
0E78(0025)             | main_begin              org     maincode                'main code follows (gets moved into maincode)
0E78(0183) 03 D6 FF A0 | vsync                   mov     x,#vs                   'do vertical sync lines
0E7C(0184) CE B1 FF 5C |                         call    #blank_vsync
0E80(0185) 1C D6 FF A0 | vb_lines                mov     x,#vb                   'do vertical back porch lines (# set at runtime)
0E84(0186) CE B1 FF 5C |                         call    #blank_vsync
0E88(0187) D9 D1 BF A0 |                         mov     screen_ptr,screen_base  'reset screen pointer to upper-left character
0E8C(0188) DA D3 BF A0 |                         mov     color_ptr,color_base    'reset color pointer to first row
0E90(0189) 00 DC FF A0 |                         mov     row,#0                  'reset row counter for cursor insertion
0E94(018A) 3C DE FF A0 |                         mov     fours,#rows * 3 / 2     'set number of 4-line builds for whole screen
0E98(018B) DD D5 BF A0 | fourline                mov     font_ptr,font_third     'get address of appropriate font section
0E9C(018C) 09 D4 FF 2C |                         shl     font_ptr,#7+2
0EA0(018D) DC D5 BF 80 |                         add     font_ptr,font_base
0EA4(018E) 00 36 FF 54 |                         movd    :pixa,#scanbuff-1       'reset scanbuff address (pre-decremented)
0EA8(018F) 00 38 FF 54 |                         movd    :pixb,#scanbuff-1
0EAC(0190) 02 D8 FF A0 |                         mov     y,#2                    'must build scanbuff in two sections because
0EB0(0191) DF FF BF A0 |                         mov     vscl,vscl_line2x        '..pixel counter is limited to twelve bits
0EB4(0192) 00 CA 7F FC | :halfrow                waitvid underscore,#0           'output lows to let other COG drive VGA pins
0EB8(0193) 28 D6 FF A0 |                         mov     x,#cols/2               '..for 2 scan lines, ready for half a row
0EBC(0194) E8 DB BF 00 | :column                 rdbyte  z,screen_ptr            'get character from screen memory
0EC0(0195) 07 DA FF 20 |                         ror     z,#7                    'get inverse flag into bit 0, keep chr high
0EC4(0196) 17 DA FF 29 |                         shr     z,#32-7-2       wc      'get inverse flag into c, chr into bits 8..2
0EC8(0197) EA DB BF 80 |                         add     z,font_ptr              'add font section address to point to 8*4 pixels
0ECC(0198) 00 36 BF 80 |                         add     :pixa,d0                'increment scanbuff destination addresses
0ED0(0199) 00 38 BF 80 |                         add     :pixb,d0
0ED4(019A) 01 D0 FF 80 |                         add     screen_ptr,#1           'increment screen memory address
0ED8(019B) ED 03 BC 08 | :pixa                   rdlong  scanbuff,z              'read pixel long (8*4) into scanbuff
0EDC(019C) E2 03 8C 6C | :pixb   if_nc           xor     scanbuff,longmask       'invert pixels according to inverse flag
0EE0(019D) 94 D7 FF E4 |                         djnz    x,#:column              'another character in this half-row?
0EE4(019E) 92 D9 FF E4 |                         djnz    y,#:halfrow             'loop to do 2nd half-row, time for 2nd WAITVID
0EE8(019F) 50 D0 FF 84 |                         sub     screen_ptr,#cols        'back up to start of same row in screen memory
0EEC(01A0) 02 DA FF A0 |                         mov     z,#2                    'ready for two cursors
0EF0(01A1) DB D7 BF 00 | :cursor                 rdbyte  x,cursor_base           'x in range?
0EF4(01A2) 01 B6 FF 80 |                         add     cursor_base,#1
0EF8(01A3) 50 D6 7F 85 |                         cmp     x,#cols         wc
0EFC(01A4) DB D9 BF 00 |                         rdbyte  y,cursor_base           'y match?
0F00(01A5) 01 B6 FF 80 |                         add     cursor_base,#1
0F04(01A6) EE D9 3F 86 |                         cmp     y,row           wz
0F08(01A7) DB D9 BF 00 |                         rdbyte  y,cursor_base           'get cursor mode
0F0C(01A8) 01 B6 FF 80 |                         add     cursor_base,#1
0F10(01A9) B6 01 5C 5C |         if_nc_or_nz     jmp     #:nocursor              'if cursor not in scanbuff, no cursor
0F14(01AA) 01 D6 FF 80 |                         add     x,#scanbuff             'cursor in scanbuff, set scanbuff address
0F18(01AB) EB 6B BF 54 |                         movd    :xor,x
0F1C(01AC) 02 D8 7F 61 |                         test    y,#%010         wc      'get mode bits into flags
0F20(01AD) 01 D8 7F 62 |                         test    y,#%001         wz
0F24(01AE) B6 01 48 5C |         if_nc_and_z     jmp     #:nocursor              'if cursor disabled, no cursor
0F28(01AF) F1 C7 23 61 |         if_c_and_z      test    slowbit,cnt     wc      'if blink mode, get blink state
0F2C(01B0) F1 C9 13 61 |         if_c_and_nz     test    fastbit,cnt     wc
0F30(01B1) 04 D8 7F 62 |                         test    y,#%100         wz      'get box or underscore cursor piece
0F34(01B2) E2 D7 AB A0 |         if_z            mov     x,longmask
0F38(01B3) E5 D7 97 A0 |         if_nz           mov     x,underscore
0F3C(01B4) 02 BA 57 86 |         if_nz           cmp     font_third,#2   wz      'if underscore, must be last font section
0F40(01B5) EB 03 88 6C | :xor    if_nc_and_z     xor     scanbuff,x              'conditionally xor cursor into scanbuff
0F44(01B6) A1 DB FF E4 | :nocursor               djnz    z,#:cursor              'second cursor?
0F48(01B7) 06 B6 FF 84 |                         sub     cursor_base,#3*2        'restore cursor base
0F4C(01B8) E9 D7 BF 04 |                         rdword  x,color_ptr             'get color pattern for current row
0F50(01B9) E1 D7 BF 60 |                         and     x,colormask             'mask away hsync and vsync signal states
0F54(01BA) E6 D7 BF 68 |                         or      x,hv                    'insert inactive hsync and vsync states
0F58(01BB) 04 D8 FF A0 |                         mov     y,#4                    'ready for four scan lines
0F5C(01BC) E0 FF BF A0 | scanline                mov     vscl,vscl_chr           'set pixel rate for characters
0F60(01BD) 81 00 7C 5C |                         jmp     #scancode               'jump to scanbuff display routine in scancode
0F64(01BE) 28 FE FF A0 | scanret                 mov     vscl,#hs                'do horizontal sync pixels
0F68(01BF) 01 CE 7F FC |                         waitvid hvsync,#1               '#1 makes hsync active
0F6C(01C0) 80 FE FF A0 |                         mov     vscl,#hb                'do horizontal back porch pixels
0F70(01C1) 00 CE 7F FC |                         waitvid hvsync,#0               '#0 makes hsync inactive
0F74(01C2) 08 A0 FC 28 |                         shr     scanbuff+cols-1,#8      'shift last column's pixels right by 8
0F78(01C3) BC D9 FF E4 |                         djnz    y,#scanline             'another scan line?
0F7C(01C4) 02 BA FF 80 |                         add     font_third,#2           'if font_third + 2 => 3, subtract 3 (new row)
0F80(01C5) 03 BA FF E1 |                         cmpsub  font_third,#3   wc      'c=0 for same row, c=1 for new row
0F84(01C6) 50 D0 F3 80 |         if_c            add     screen_ptr,#cols        'if new row, advance screen pointer
0F88(01C7) 02 D2 F3 80 |         if_c            add     color_ptr,#2            'if new row, advance color pointer
0F8C(01C8) 01 DC F3 80 |         if_c            add     row,#1                  'if new row, increment row counter
0F90(01C9) 8B DF FF E4 |                         djnz    fours,#fourline         'another 4-line build/display?
0F94(01CA) F0 C5 3F 08 |                         wrlong  longmask,par            'write -1 to refresh indicator
0F98(01CB) 09 D6 FF A0 | vf_lines                mov     x,#vf                   'do vertical front porch lines (# set at runtime)
0F9C(01CC) CF B1 FF 5C |                         call    #blank
0FA0(01CD) 83 01 7C 5C |                         jmp     #vsync                  'new field, loop to vsync
0FA4(01CE) 01 CF FF 6C | blank_vsync             xor     hvsync,#$101            'flip vertical sync bits
0FA8(01CF) DE FF BF A0 | blank                   mov     vscl,hx                 'do blank pixels
0FAC(01D0) 00 CE 7F FC |                         waitvid hvsync,#0
0FB0(01D1) 18 FE FF A0 |                         mov     vscl,#hf                'do horizontal front porch pixels
0FB4(01D2) 00 CE 7F FC |                         waitvid hvsync,#0
0FB8(01D3) 28 FE FF A0 |                         mov     vscl,#hs                'do horizontal sync pixels
0FBC(01D4) 01 CE 7F FC |                         waitvid hvsync,#1
0FC0(01D5) 80 FE FF A0 |                         mov     vscl,#hb                'do horizontal back porch pixels
0FC4(01D6) 00 CE 7F FC |                         waitvid hvsync,#0
0FC8(01D7) CF D7 FF E4 |                         djnz    x,#blank                'another line?
0FCC(01D8)             | blank_ret
0FCC(01D8) 00 00 7C 5C | blank_vsync_ret         ret
0FD0(01D9) 00 00 00 00 | screen_base             long    0                       'set at runtime (3 contiguous longs)
0FD4(01DA) 00 00 00 00 | color_base              long    0                       'set at runtime
0FD8(01DB) 00 00 00 00 | cursor_base             long    0                       'set at runtime
0FDC(01DC) 00 00 00 00 | font_base               long    0                       'set at runtime
0FE0(01DD) 00 00 00 00 | font_third              long    0                       'set at runtime
0FE4(01DE) 80 02 00 00 | hx                      long    hp                      'visible pixels per scan line
0FE8(01DF) 80 06 00 00 | vscl_line2x             long    (hp + hf + hs + hb) * 2 'total number of pixels per 2 scan lines
0FEC(01E0) 08 10 00 00 | vscl_chr                long    1 << 12 + 8             '1 clock per pixel and 8 pixels per set
0FF0(01E1) FC FC 00 00 | colormask               long    $FCFC                   'mask to isolate R,G,B bits from H,V
0FF4(01E2) FF FF FF FF | longmask                long    $FFFFFFFF               'all bits set
0FF8(01E3) 00 00 00 02 | slowbit                 long    1 << 25                 'cnt mask for slow cursor blink
0FFC(01E4) 00 00 00 01 | fastbit                 long    1 << 24                 'cnt mask for fast cursor blink
1000(01E5) 00 00 FF FF | underscore              long    $FFFF0000               'underscore cursor pattern
1004(01E6) 03 03 00 00 | hv                      long    hv_inactive             '-H,-V states
1008(01E7) 03 01 00 00 | hvsync                  long    hv_inactive ^ $200      '+/-H,-V states
100C(01E8)             | screen_ptr              res     1
100C(01E9)             | color_ptr               res     1
100C(01EA)             | font_ptr                res     1
100C(01EB)             | x                       res     1
100C(01EC)             | y                       res     1
100C(01ED)             | z                       res     1
100C(01EE)             | row                     res     1
100C(01EF)             | fours                   res     1
100C(01F0) 00 00 00 00 | font  long
100C(01F0) 00 00 08 0C | long  $0C080000,$30100000,$7E3C1800,$18181800,$81423C00,$99423C00,$8181FF00,$E7C3FF00  'top
1010(01F1) 00 00 10 30 | 
1014(01F2) 00 18 3C 7E | 
1018(01F3) 00 18 18 18 | 
101C(01F4) 00 3C 42 81 | 
1020(01F5) 00 3C 42 99 | 
1024(01F6) 00 FF 81 81 | 
1028(01F7) 00 FF C3 E7 | 
102C(01F8) 02 06 0E 1E | long  $1E0E0602,$1C000000,$00000000,$00000000,$18181818,$18181818,$00000000,$18181818
1030(01F9) 00 00 00 1C | 
1034(01FA) 00 00 00 00 | 
1038(01FB) 00 00 00 00 | 
103C(01FC) 18 18 18 18 | 
1040(01FD) 18 18 18 18 | 
1044(01FE) 00 00 00 00 | 
1048(01FF) 18 18 18 18 | 
104C(0200) 00 00 00 00 | long  $00000000,$18181818,$18181818,$18181818,$18181818,$00FFFF00,$CC993366,$66666666
1050(0201) 18 18 18 18 | 
1054(0202) 18 18 18 18 | 
1058(0203) 18 18 18 18 | 
105C(0204) 18 18 18 18 | 
1060(0205) 00 FF FF 00 | 
1064(0206) 66 33 99 CC | 
1068(0207) 66 66 66 66 | 
106C(0208) 55 AA 55 AA | long  $AA55AA55,$0F0F0F0F,$0F0F0F0F,$0F0F0F0F,$0F0F0F0F,$00000000,$00000000,$00000000
1070(0209) 0F 0F 0F 0F | 
1074(020A) 0F 0F 0F 0F | 
1078(020B) 0F 0F 0F 0F | 
107C(020C) 0F 0F 0F 0F | 
1080(020D) 00 00 00 00 | 
1084(020E) 00 00 00 00 | 
1088(020F) 00 00 00 00 | 
108C(0210) 00 00 00 00 | long  $00000000,$3C3C1800,$77666600,$7F363600,$667C1818,$46000000,$1B1B0E00,$1C181800
1090(0211) 00 18 3C 3C | 
1094(0212) 00 66 66 77 | 
1098(0213) 00 36 36 7F | 
109C(0214) 18 18 7C 66 | 
10A0(0215) 00 00 00 46 | 
10A4(0216) 00 0E 1B 1B | 
10A8(0217) 00 18 18 1C | 
10AC(0218) 00 30 18 0C | long  $0C183000,$180C0600,$66000000,$18000000,$00000000,$00000000,$00000000,$60400000
10B0(0219) 00 06 0C 18 | 
10B4(021A) 00 00 00 66 | 
10B8(021B) 00 00 00 18 | 
10BC(021C) 00 00 00 00 | 
10C0(021D) 00 00 00 00 | 
10C4(021E) 00 00 00 00 | 
10C8(021F) 00 00 40 60 | 
10CC(0220) 00 3E 63 73 | long  $73633E00,$1E181000,$66663C00,$60663C00,$3C383000,$06067E00,$060C3800,$63637F00
10D0(0221) 00 10 18 1E | 
10D4(0222) 00 3C 66 66 | 
10D8(0223) 00 3C 66 60 | 
10DC(0224) 00 30 38 3C | 
10E0(0225) 00 7E 06 06 | 
10E4(0226) 00 38 0C 06 | 
10E8(0227) 00 7F 63 63 | 
10EC(0228) 00 3C 66 66 | long  $66663C00,$66663C00,$1C000000,$00000000,$18306000,$00000000,$180C0600,$60663C00
10F0(0229) 00 3C 66 66 | 
10F4(022A) 00 00 00 1C | 
10F8(022B) 00 00 00 00 | 
10FC(022C) 00 60 30 18 | 
1100(022D) 00 00 00 00 | 
1104(022E) 00 06 0C 18 | 
1108(022F) 00 3C 66 60 | 
110C(0230) 00 3E 67 63 | long  $63673E00,$66663C00,$66663F00,$63663C00,$66361F00,$06467F00,$06467F00,$63663C00
1110(0231) 00 3C 66 66 | 
1114(0232) 00 3F 66 66 | 
1118(0233) 00 3C 66 63 | 
111C(0234) 00 1F 36 66 | 
1120(0235) 00 7F 46 06 | 
1124(0236) 00 7F 46 06 | 
1128(0237) 00 3C 66 63 | 
112C(0238) 00 63 63 63 | long  $63636300,$18183C00,$30307800,$36666700,$06060F00,$7F776300,$67636300,$63361C00
1130(0239) 00 3C 18 18 | 
1134(023A) 00 78 30 30 | 
1138(023B) 00 67 66 36 | 
113C(023C) 00 0F 06 06 | 
1140(023D) 00 63 77 7F | 
1144(023E) 00 63 63 67 | 
1148(023F) 00 1C 36 63 | 
114C(0240) 00 3F 66 66 | long  $66663F00,$63361C00,$66663F00,$66663C00,$185A7E00,$66666600,$66666600,$63636300
1150(0241) 00 1C 36 63 | 
1154(0242) 00 3F 66 66 | 
1158(0243) 00 3C 66 66 | 
115C(0244) 00 7E 5A 18 | 
1160(0245) 00 66 66 66 | 
1164(0246) 00 66 66 66 | 
1168(0247) 00 63 63 63 | 
116C(0248) 00 66 66 66 | long  $66666600,$66666600,$31637F00,$0C0C3C00,$03010000,$30303C00,$361C0800,$00000000
1170(0249) 00 66 66 66 | 
1174(024A) 00 7F 63 31 | 
1178(024B) 00 3C 0C 0C | 
117C(024C) 00 00 01 03 | 
1180(024D) 00 3C 30 30 | 
1184(024E) 00 08 1C 36 | 
1188(024F) 00 00 00 00 | 
118C(0250) 00 00 00 0C | long  $0C000000,$00000000,$06060700,$00000000,$30303800,$00000000,$0C6C3800,$00000000
1190(0251) 00 00 00 00 | 
1194(0252) 00 07 06 06 | 
1198(0253) 00 00 00 00 | 
119C(0254) 00 38 30 30 | 
11A0(0255) 00 00 00 00 | 
11A4(0256) 00 38 6C 0C | 
11A8(0257) 00 00 00 00 | 
11AC(0258) 00 07 06 06 | long  $06060700,$00181800,$00606000,$06060700,$18181E00,$00000000,$00000000,$00000000
11B0(0259) 00 18 18 00 | 
11B4(025A) 00 60 60 00 | 
11B8(025B) 00 07 06 06 | 
11BC(025C) 00 1E 18 18 | 
11C0(025D) 00 00 00 00 | 
11C4(025E) 00 00 00 00 | 
11C8(025F) 00 00 00 00 | 
11CC(0260) 00 00 00 00 | long  $00000000,$00000000,$00000000,$00000000,$0C080000,$00000000,$00000000,$00000000
11D0(0261) 00 00 00 00 | 
11D4(0262) 00 00 00 00 | 
11D8(0263) 00 00 00 00 | 
11DC(0264) 00 00 08 0C | 
11E0(0265) 00 00 00 00 | 
11E4(0266) 00 00 00 00 | 
11E8(0267) 00 00 00 00 | 
11EC(0268) 00 00 00 00 | long  $00000000,$00000000,$00000000,$18187000,$18181800,$18180E00,$73DBCE00,$18180000
11F0(0269) 00 00 00 00 | 
11F4(026A) 00 00 00 00 | 
11F8(026B) 00 70 18 18 | 
11FC(026C) 00 18 18 18 | 
1200(026D) 00 0E 18 18 | 
1204(026E) 00 CE DB 73 | 
1208(026F) 00 00 18 18 | 
120C(0270) 7E 7E 0C 08 | long  $080C7E7E,$10307E7E,$18181818,$7E181818,$81818181,$99BDBDBD,$81818181,$E7BD99BD  'middle
1210(0271) 7E 7E 30 10 | 
1214(0272) 18 18 18 18 | 
1218(0273) 18 18 18 7E | 
121C(0274) 81 81 81 81 | 
1220(0275) BD BD BD 99 | 
1224(0276) 81 81 81 81 | 
1228(0277) BD 99 BD E7 | 
122C(0278) 3E 7E 3E 1E | long  $1E3E7E3E,$1C3E3E3E,$30F0C000,$0C0F0300,$00C0F030,$00030F0C,$00FFFF00,$18181818
1230(0279) 3E 3E 3E 1C | 
1234(027A) 00 C0 F0 30 | 
1238(027B) 00 03 0F 0C | 
123C(027C) 30 F0 C0 00 | 
1240(027D) 0C 0F 03 00 | 
1244(027E) 00 FF FF 00 | 
1248(027F) 18 18 18 18 | 
124C(0280) 00 FF FF 18 | long  $18FFFF00,$00FFFF18,$18F8F818,$181F1F18,$18FFFF18,$00FFFF00,$CC993366,$66666666
1250(0281) 18 FF FF 00 | 
1254(0282) 18 F8 F8 18 | 
1258(0283) 18 1F 1F 18 | 
125C(0284) 18 FF FF 18 | 
1260(0285) 00 FF FF 00 | 
1264(0286) 66 33 99 CC | 
1268(0287) 66 66 66 66 | 
126C(0288) 55 AA 55 AA | long  $AA55AA55,$FFFF0F0F,$F0F00F0F,$0F0F0F0F,$00000F0F,$FFFF0000,$F0F00000,$0F0F0000
1270(0289) 0F 0F FF FF | 
1274(028A) 0F 0F F0 F0 | 
1278(028B) 0F 0F 0F 0F | 
127C(028C) 0F 0F 00 00 | 
1280(028D) 00 00 FF FF | 
1284(028E) 00 00 F0 F0 | 
1288(028F) 00 00 0F 0F | 
128C(0290) 00 00 00 00 | long  $00000000,$0018183C,$00000033,$7F363636,$66603C06,$0C183066,$337B5B0E,$0000000C
1290(0291) 3C 18 18 00 | 
1294(0292) 33 00 00 00 | 
1298(0293) 36 36 36 7F | 
129C(0294) 06 3C 60 66 | 
12A0(0295) 66 30 18 0C | 
12A4(0296) 0E 5B 7B 33 | 
12A8(0297) 0C 00 00 00 | 
12AC(0298) 06 06 06 0C | long  $0C060606,$18303030,$663CFF3C,$18187E18,$00000000,$00007E00,$00000000,$060C1830
12B0(0299) 30 30 30 18 | 
12B4(029A) 3C FF 3C 66 | 
12B8(029B) 18 7E 18 18 | 
12BC(029C) 00 00 00 00 | 
12C0(029D) 00 7E 00 00 | 
12C4(029E) 00 00 00 00 | 
12C8(029F) 30 18 0C 06 | 
12CC(02A0) 7B 6B 6F 67 | long  $676F6B7B,$18181818,$0C183060,$60603860,$307F3336,$60603E06,$66663E06,$0C183060
12D0(02A1) 18 18 18 18 | 
12D4(02A2) 60 30 18 0C | 
12D8(02A3) 60 38 60 60 | 
12DC(02A4) 36 33 7F 30 | 
12E0(02A5) 06 3E 60 60 | 
12E4(02A6) 06 3E 66 66 | 
12E8(02A7) 60 30 18 0C | 
12EC(02A8) 6E 3C 76 66 | long  $66763C6E,$60607C66,$1C00001C,$00001C1C,$180C060C,$007E007E,$18306030,$00181830
12F0(02A9) 66 7C 60 60 | 
12F4(02AA) 1C 00 00 1C | 
12F8(02AB) 1C 1C 00 00 | 
12FC(02AC) 0C 06 0C 18 | 
1300(02AD) 7E 00 7E 00 | 
1304(02AE) 30 60 30 18 | 
1308(02AF) 30 18 18 00 | 
130C(02B0) 7B 7B 3B 03 | long  $033B7B7B,$66667E66,$66663E66,$63030303,$66666666,$06263E26,$06263E26,$63730303
1310(02B1) 66 7E 66 66 | 
1314(02B2) 66 3E 66 66 | 
1318(02B3) 03 03 03 63 | 
131C(02B4) 66 66 66 66 | 
1320(02B5) 26 3E 26 06 | 
1324(02B6) 26 3E 26 06 | 
1328(02B7) 03 03 73 63 | 
132C(02B8) 63 7F 63 63 | long  $63637F63,$18181818,$33333030,$36361E36,$66460606,$63636B7F,$737B7F6F,$63636363
1330(02B9) 18 18 18 18 | 
1334(02BA) 30 30 33 33 | 
1338(02BB) 36 1E 36 36 | 
133C(02BC) 06 06 46 66 | 
1340(02BD) 7F 6B 63 63 | 
1344(02BE) 6F 7F 7B 73 | 
1348(02BF) 63 63 63 63 | 
134C(02C0) 66 3E 06 06 | long  $06063E66,$7B636363,$66363E66,$66301C06,$18181818,$66666666,$66666666,$366B6B63
1350(02C1) 63 63 63 7B | 
1354(02C2) 66 3E 36 66 | 
1358(02C3) 06 1C 30 66 | 
135C(02C4) 18 18 18 18 | 
1360(02C5) 66 66 66 66 | 
1364(02C6) 66 66 66 66 | 
1368(02C7) 63 6B 6B 36 | 
136C(02C8) 3C 18 3C 66 | long  $663C183C,$18183C66,$43060C18,$0C0C0C0C,$30180C06,$30303030,$00000063,$00000000
1370(02C9) 66 3C 18 18 | 
1374(02CA) 18 0C 06 43 | 
1378(02CB) 0C 0C 0C 0C | 
137C(02CC) 06 0C 18 30 | 
1380(02CD) 30 30 30 30 | 
1384(02CE) 63 00 00 00 | 
1388(02CF) 00 00 00 00 | 
138C(02D0) 1C 38 30 00 | long  $0030381C,$333E301E,$6666663E,$0606663C,$3333333E,$067E663C,$0C0C3E0C,$3333336E
1390(02D1) 1E 30 3E 33 | 
1394(02D2) 3E 66 66 66 | 
1398(02D3) 3C 66 06 06 | 
139C(02D4) 3E 33 33 33 | 
13A0(02D5) 3C 66 7E 06 | 
13A4(02D6) 0C 3E 0C 0C | 
13A8(02D7) 6E 33 33 33 | 
13AC(02D8) 36 6E 66 66 | long  $66666E36,$1818181C,$60606070,$361E3666,$18181818,$6B6B6B3F,$6666663E,$6666663C
13B0(02D9) 1C 18 18 18 | 
13B4(02DA) 70 60 60 60 | 
13B8(02DB) 66 36 1E 36 | 
13BC(02DC) 18 18 18 18 | 
13C0(02DD) 3F 6B 6B 6B | 
13C4(02DE) 3E 66 66 66 | 
13C8(02DF) 3C 66 66 66 | 
13CC(02E0) 3B 66 66 66 | long  $6666663B,$3333336E,$066E7637,$300C663C,$0C0C0C7E,$33333333,$66666666,$6B6B6363
13D0(02E1) 6E 33 33 33 | 
13D4(02E2) 37 76 6E 06 | 
13D8(02E3) 3C 66 0C 30 | 
13DC(02E4) 7E 0C 0C 0C | 
13E0(02E5) 33 33 33 33 | 
13E4(02E6) 66 66 66 66 | 
13E8(02E7) 63 63 6B 6B | 
13EC(02E8) 63 36 1C 1C | long  $1C1C3663,$66666666,$0C30627E,$180C060C,$18181818,$18306030,$00000000,$0018187E
13F0(02E9) 66 66 66 66 | 
13F4(02EA) 7E 62 30 0C | 
13F8(02EB) 0C 06 0C 18 | 
13FC(02EC) 18 18 18 18 | 
1400(02ED) 30 60 30 18 | 
1404(02EE) 00 00 00 00 | 
1408(02EF) 7E 18 18 00 | 
140C(02F0) 00 00 00 00 | long  $00000000,$00000000,$00001818,$0000183C,$00003C42,$00003C42,$0000FF81,$0000FFC3  'bottom
1410(02F1) 00 00 00 00 | 
1414(02F2) 18 18 00 00 | 
1418(02F3) 3C 18 00 00 | 
141C(02F4) 42 3C 00 00 | 
1420(02F5) 42 3C 00 00 | 
1424(02F6) 81 FF 00 00 | 
1428(02F7) C3 FF 00 00 | 
142C(02F8) 0E 06 02 00 | long  $0002060E,$00000000,$18181818,$18181818,$00000000,$00000000,$00000000,$18181818
1430(02F9) 00 00 00 00 | 
1434(02FA) 18 18 18 18 | 
1438(02FB) 18 18 18 18 | 
143C(02FC) 00 00 00 00 | 
1440(02FD) 00 00 00 00 | 
1444(02FE) 00 00 00 00 | 
1448(02FF) 18 18 18 18 | 
144C(0300) 18 18 18 18 | long  $18181818,$00000000,$18181818,$18181818,$18181818,$00FFFF00,$CC993366,$66666666
1450(0301) 00 00 00 00 | 
1454(0302) 18 18 18 18 | 
1458(0303) 18 18 18 18 | 
145C(0304) 18 18 18 18 | 
1460(0305) 00 FF FF 00 | 
1464(0306) 66 33 99 CC | 
1468(0307) 66 66 66 66 | 
146C(0308) 55 AA 55 AA | long  $AA55AA55,$FFFFFFFF,$F0F0F0F0,$0F0F0F0F,$00000000,$FFFFFFFF,$F0F0F0F0,$0F0F0F0F
1470(0309) FF FF FF FF | 
1474(030A) F0 F0 F0 F0 | 
1478(030B) 0F 0F 0F 0F | 
147C(030C) 00 00 00 00 | 
1480(030D) FF FF FF FF | 
1484(030E) F0 F0 F0 F0 | 
1488(030F) 0F 0F 0F 0F | 
148C(0310) 00 00 00 00 | long  $00000000,$00001818,$00000000,$00003636,$0018183E,$00006266,$00006E3B,$00000000
1490(0311) 18 18 00 00 | 
1494(0312) 00 00 00 00 | 
1498(0313) 36 36 00 00 | 
149C(0314) 3E 18 18 00 | 
14A0(0315) 66 62 00 00 | 
14A4(0316) 3B 6E 00 00 | 
14A8(0317) 00 00 00 00 | 
14AC(0318) 18 30 00 00 | long  $00003018,$0000060C,$00000000,$00000000,$0C181C1C,$00000000,$00001C1C,$00000103
14B0(0319) 0C 06 00 00 | 
14B4(031A) 00 00 00 00 | 
14B8(031B) 00 00 00 00 | 
14BC(031C) 1C 1C 18 0C | 
14C0(031D) 00 00 00 00 | 
14C4(031E) 1C 1C 00 00 | 
14C8(031F) 03 01 00 00 | 
14CC(0320) 63 3E 00 00 | long  $00003E63,$00007E18,$00007E66,$00003C66,$00007830,$00003C66,$00003C66,$00000C0C
14D0(0321) 18 7E 00 00 | 
14D4(0322) 66 7E 00 00 | 
14D8(0323) 66 3C 00 00 | 
14DC(0324) 30 78 00 00 | 
14E0(0325) 66 3C 00 00 | 
14E4(0326) 66 3C 00 00 | 
14E8(0327) 0C 0C 00 00 | 
14EC(0328) 66 3C 00 00 | long  $00003C66,$00001C30,$0000001C,$0C181C1C,$00006030,$00000000,$0000060C,$00001818
14F0(0329) 30 1C 00 00 | 
14F4(032A) 1C 00 00 00 | 
14F8(032B) 1C 1C 18 0C | 
14FC(032C) 30 60 00 00 | 
1500(032D) 00 00 00 00 | 
1504(032E) 0C 06 00 00 | 
1508(032F) 18 18 00 00 | 
150C(0330) 07 3E 00 00 | long  $00003E07,$00006666,$00003F66,$00003C66,$00001F36,$00007F46,$00000F06,$00007C66
1510(0331) 66 66 00 00 | 
1514(0332) 66 3F 00 00 | 
1518(0333) 66 3C 00 00 | 
151C(0334) 36 1F 00 00 | 
1520(0335) 46 7F 00 00 | 
1524(0336) 06 0F 00 00 | 
1528(0337) 66 7C 00 00 | 
152C(0338) 63 63 00 00 | long  $00006363,$00003C18,$00001E33,$00006766,$00007F66,$00006363,$00006363,$00001C36
1530(0339) 18 3C 00 00 | 
1534(033A) 33 1E 00 00 | 
1538(033B) 66 67 00 00 | 
153C(033C) 66 7F 00 00 | 
1540(033D) 63 63 00 00 | 
1544(033E) 63 63 00 00 | 
1548(033F) 36 1C 00 00 | 
154C(0340) 06 0F 00 00 | long  $00000F06,$00603C36,$00006766,$00003C66,$00003C18,$00003C66,$0000183C,$00003636
1550(0341) 36 3C 60 00 | 
1554(0342) 66 67 00 00 | 
1558(0343) 66 3C 00 00 | 
155C(0344) 18 3C 00 00 | 
1560(0345) 66 3C 00 00 | 
1564(0346) 3C 18 00 00 | 
1568(0347) 36 36 00 00 | 
156C(0348) 66 66 00 00 | long  $00006666,$00003C18,$00007F63,$00003C0C,$00004060,$00003C30,$00000000,$FFFF0000
1570(0349) 18 3C 00 00 | 
1574(034A) 63 7F 00 00 | 
1578(034B) 0C 3C 00 00 | 
157C(034C) 60 40 00 00 | 
1580(034D) 30 3C 00 00 | 
1584(034E) 00 00 00 00 | 
1588(034F) 00 00 FF FF | 
158C(0350) 00 00 00 00 | long  $00000000,$00006E33,$00003B66,$00003C66,$00006E33,$00003C66,$00001E0C,$1E33303E
1590(0351) 33 6E 00 00 | 
1594(0352) 66 3B 00 00 | 
1598(0353) 66 3C 00 00 | 
159C(0354) 33 6E 00 00 | 
15A0(0355) 66 3C 00 00 | 
15A4(0356) 0C 1E 00 00 | 
15A8(0357) 3E 30 33 1E | 
15AC(0358) 66 67 00 00 | long  $00006766,$00007E18,$3C666660,$00006766,$00007E18,$00006B6B,$00006666,$00003C66
15B0(0359) 18 7E 00 00 | 
15B4(035A) 60 66 66 3C | 
15B8(035B) 66 67 00 00 | 
15BC(035C) 18 7E 00 00 | 
15C0(035D) 6B 6B 00 00 | 
15C4(035E) 66 66 00 00 | 
15C8(035F) 66 3C 00 00 | 
15CC(0360) 66 3E 06 0F | long  $0F063E66,$78303E33,$00000F06,$00003C66,$0000386C,$00006E33,$0000183C,$00003636
15D0(0361) 33 3E 30 78 | 
15D4(0362) 06 0F 00 00 | 
15D8(0363) 66 3C 00 00 | 
15DC(0364) 6C 38 00 00 | 
15E0(0365) 33 6E 00 00 | 
15E4(0366) 3C 18 00 00 | 
15E8(0367) 36 36 00 00 | 
15EC(0368) 36 63 00 00 | long  $00006336,$1C30607C,$00007E46,$00007018,$00001818,$00000E18,$00000000,$0000007E
15F0(0369) 7C 60 30 1C | 
15F4(036A) 46 7E 00 00 | 
15F8(036B) 18 70 00 00 | 
15FC(036C) 18 18 00 00 | 
1600(036D) 18 0E 00 00 | 
1604(036E) 00 00 00 00 | 
1608(036F) 7E 00 00 00 | 
|===========================================================================|
|===========================================================================|
Spin Block start with 5 Parameters and 2 Extra Stack Longs. Method 1
PUB start(BasePin, ScreenPtr, ColorPtr, CursorPtr, SyncPtr) : okay | i, j

Local Parameter DBASE:0000 - okay
Local Parameter DBASE:0004 - BasePin
Local Parameter DBASE:0008 - ScreenPtr
Local Parameter DBASE:000C - ColorPtr
Local Parameter DBASE:0010 - CursorPtr
Local Parameter DBASE:0014 - SyncPtr
Local Variable  DBASE:0018 - i
Local Variable  DBASE:001C - j
|===========================================================================|
123                        stop
Addr : 160C:             01  : Drop Anchor   
Addr : 160D:          05 02  : Call Sub 2    
126                        reg_vcfg := $200000FF + (BasePin & %111000) << 6
Addr : 160F: 3B 20 00 00 FF  : Constant 4 Bytes - 20 00 00 FF - $200000FF 536871167
Addr : 1614:             64  : Variable Operation Local Offset - 1 Read
Addr : 1615:          38 38  : Constant 1 Bytes - 38 - $00000038 56
Addr : 1617:             E8  : Math Op &     
Addr : 1618:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 161A:             E3  : Math Op <<    
Addr : 161B:             EC  : Math Op +     
Addr : 161C:       C5 80 98  : Memory Op Long PBASE + WRITE Address = 0098
127                        i := $FF << (BasePin & %011000)
Addr : 161F:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
Addr : 1621:             64  : Variable Operation Local Offset - 1 Read
Addr : 1622:          38 18  : Constant 1 Bytes - 18 - $00000018 24
Addr : 1624:             E8  : Math Op &     
Addr : 1625:             E3  : Math Op <<    
Addr : 1626:             79  : Variable Operation Local Offset - 6 Write
128                        j := BasePin & %100000 == 0
Addr : 1627:             64  : Variable Operation Local Offset - 1 Read
Addr : 1628:          37 04  : Constant Mask Y=4 00000020 32
Addr : 162A:             E8  : Math Op &     
Addr : 162B:             35  : Constant 1 $00000000
Addr : 162C:             FC  : Math Op ==    
Addr : 162D:             7D  : Variable Operation Local Offset - 7 Write
129                        reg_dira := i & j
Addr : 162E:             78  : Variable Operation Local Offset - 6 Read
Addr : 162F:             7C  : Variable Operation Local Offset - 7 Read
Addr : 1630:             E8  : Math Op &     
Addr : 1631:       C5 80 90  : Memory Op Long PBASE + WRITE Address = 0090
130                        reg_dirb := i & !j
Addr : 1634:             78  : Variable Operation Local Offset - 6 Read
Addr : 1635:             7C  : Variable Operation Local Offset - 7 Read
Addr : 1636:             E7  : Math Op !     
Addr : 1637:             E8  : Math Op &     
Addr : 1638:       C5 80 94  : Memory Op Long PBASE + WRITE Address = 0094
133                        sync_cnt := cnt + $10000
Addr : 163B:          3F 91  : Register op CNT Read
Addr : 163D:          37 0F  : Constant Mask Y=15 00010000 65536
Addr : 163F:             EC  : Math Op +     
Addr : 1640:       C5 80 9C  : Memory Op Long PBASE + WRITE Address = 009C
136                        longmove(@screen_base, @ScreenPtr, 3)
Addr : 1643:       C7 81 F8  : Memory Op Long PBASE + ADDRESS Address = 01F8
Addr : 1646:             6B  : Variable Operation Local Offset - 2 Address
Addr : 1647:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 1649:             1E  : LongMove(To, From, Count)
137                        font_base := @font
Addr : 164A:       C7 82 34  : Memory Op Long PBASE + ADDRESS Address = 0234
Addr : 164D:       C5 82 04  : Memory Op Long PBASE + WRITE Address = 0204
Addr : 1650:          38 09  : Constant 1 Bytes - 09 - $00000009 9
140                        vf_lines.byte := vf
Addr : 1652:       85 81 C0  : Memory Op Byte PBASE + WRITE Address = 01C0
Addr : 1655:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
141                        vb_lines.byte := vb
Addr : 1657:       85 80 A8  : Memory Op Byte PBASE + WRITE Address = 00A8
142                        font_third := 1
Addr : 165A:             36  : Constant 2 $00000001
Addr : 165B:       C5 82 08  : Memory Op Long PBASE + WRITE Address = 0208
Addr : 165E:             34  : Constant 0 $FFFFFFFF
143                        cog[1] := cognew(@d0, SyncPtr) + 1
Addr : 165F:          C7 0C  : Memory Op Long PBASE + ADDRESS Address = 000C
Addr : 1661:             74  : Variable Operation Local Offset - 5 Read
Addr : 1662:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 1663:             36  : Constant 2 $00000001
Addr : 1664:             EC  : Math Op +     
Addr : 1665:             36  : Constant 2 $00000001
Addr : 1666:          D9 00  : Memory Op Long VBASE + POP Index WRITE Address = 0000
146                        waitcnt($2000 + cnt)
Addr : 1668:          37 0C  : Constant Mask Y=12 00002000 8192
Addr : 166A:          3F 91  : Register op CNT Read
Addr : 166C:             EC  : Math Op +     
Addr : 166D:             23  : WaitCnt(count)
Addr : 166E:          38 09  : Constant 1 Bytes - 09 - $00000009 9
149                        vf_lines.byte := vf+4
Addr : 1670:          37 01  : Constant Mask Y=1 00000004 4
Addr : 1672:             EC  : Math Op +     
Addr : 1673:       85 81 C0  : Memory Op Byte PBASE + WRITE Address = 01C0
Addr : 1676:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
150                        vb_lines.byte := vb-4
Addr : 1678:          37 01  : Constant Mask Y=1 00000004 4
Addr : 167A:             ED  : Math Op -     
Addr : 167B:       85 80 A8  : Memory Op Byte PBASE + WRITE Address = 00A8
151                        font_third := 0
Addr : 167E:             35  : Constant 1 $00000000
Addr : 167F:       C5 82 08  : Memory Op Long PBASE + WRITE Address = 0208
Addr : 1682:             34  : Constant 0 $FFFFFFFF
152                        cog[0] := cognew(@d0, SyncPtr) + 1
Addr : 1683:          C7 0C  : Memory Op Long PBASE + ADDRESS Address = 000C
Addr : 1685:             74  : Variable Operation Local Offset - 5 Read
Addr : 1686:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 1687:             36  : Constant 2 $00000001
Addr : 1688:             EC  : Math Op +     
Addr : 1689:             35  : Constant 1 $00000000
Addr : 168A:          D9 00  : Memory Op Long VBASE + POP Index WRITE Address = 0000
155                        if cog[0] and cog[1]
Addr : 168C:             35  : Constant 1 $00000000
Addr : 168D:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 168F:             36  : Constant 2 $00000001
Addr : 1690:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 1692:             F0  : Math Op AND   
Addr : 1693: JZ Label0002
Addr : 1693:          0A 04  : jz Address = 1699 4
156                          return true
Addr : 1695:             34  : Constant 0 $FFFFFFFF
Addr : 1696:             33  : Return value  
Addr : 1697: JMP Label0003
Addr : 1697:          04 03  : Jmp 169C 3    
Addr : 1699: Label0002
160                          stop
Addr : 1699:             01  : Drop Anchor   
Addr : 169A:          05 02  : Call Sub 2    
Addr : 169C: Label0004
Addr : 169C: Label0003
Addr : 169C:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 1 Extra Stack Longs. Method 2
PUB stop | i

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - i
|===========================================================================|
167                        repeat i from 0 to 1
Addr : 169D:             35  : Constant 1 $00000000
Addr : 169E:             65  : Variable Operation Local Offset - 1 Write
Addr : 169F: Label0002
168                          if cog[i]
Addr : 169F:             64  : Variable Operation Local Offset - 1 Read
Addr : 16A0:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 16A2: JZ Label0005
Addr : 16A2:          0A 07  : jz Address = 16AB 7
169                            cogstop(cog[i]~ - 1)
Addr : 16A4:             64  : Variable Operation Local Offset - 1 Read
Addr : 16A5:       DA 00 98  : Memory Op Long VBASE + POP Index ASSIGN Address = 0000 VAR~ Post-clear Push
Addr : 16A8:             36  : Constant 2 $00000001
Addr : 16A9:             ED  : Math Op -     
Addr : 16AA:             21  : CogStop(id)   
Addr : 16AB: Label0005
Addr : 16AB: Label0006
Addr : 16AB: Label0003
167                        repeat i from 0 to 1
Addr : 16AB:             35  : Constant 1 $00000000
Addr : 16AC:             36  : Constant 2 $00000001
Addr : 16AD: Repeat i Step Label0002
Addr : 16AD:       66 02 6F  : Variable Operation Local Offset - 1 Assign Repeat-Var loop Address= 169F -17
Addr : 16B0: Label0004
Addr : 16B0:             32  : Return        
|===========================================================================|
Object hc11_Ports
Object Base is 16B4
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable cog
VBASE : 0004 LONG Size 0004 Variable status
VBASE : 0008 LONG Size 0004 Variable disk_status
VBASE : 000C LONG Size 0004 Variable key
VBASE : 0010 LONG Size 0004 Variable sector_offset
VBASE : 0014 LONG Size 0004 Variable dsk_cmdbuf_ptr
VBASE : 0018 LONG Size 0004 Variable vga_head
VBASE : 001C LONG Size 0004 Variable vga_tail
VBASE : 0020 LONG Size 0004 Variable vga_buffer_ptr
VBASE : 0024 BYTE Size 0100 Variable vga_buffer
VBASE : 0124 BYTE Size 000A Variable dsk_cmdbuf
|===========================================================================|
Object DAT Blocks
|===========================================================================|
16F0(0000)             |                         org 0
16F0(0000) 7E EC BF A0 | port_init               mov dira, input_port_mask       'set control + data = inputs, wait as output
16F4(0001) 7D E8 BF 68 |                         or  outa, wait_bit              'make sure wait bit is high now
16F8(0002) F0 0F BD A0 |                         mov t1,par                      'get parameters
16FC(0003) 87 FE BC A0 |                         mov _status, t1
1700(0004) 04 0E FD 80 |                         add t1, #4
1704(0005) 87 00 BD A0 |                         mov dsk_status, t1
1708(0006) 04 0E FD 80 |                         add t1, #4
170C(0007) 87 02 BD A0 |                         mov _key,t1
1710(0008) 04 0E FD 80 |                         add t1, #4
1714(0009) 87 04 BD A0 |                         mov sector_off, t1
1718(000A) 04 0E FD 80 |                         add t1, #4
171C(000B) 87 06 BD 08 |                         rdlong dskcmdptr,t1
1720(000C) 04 0E FD 80 |                         add t1, #4
1724(000D) 87 08 BD A0 |                         mov _vga_head, t1
1728(000E) 08 0E FD 80 |                         add t1, #8
172C(000F) 87 0A BD 08 |                         rdlong v_ptr, t1
1730(0010) 00 12 FD A0 |                         mov cmdcount, #0
1734(0011) 00 14 FD A0 |                         mov iobytes, #0
1738(0012) 7B F4 3C F0 | port_loop               waitpeq input_read, cs_mask     'Wait for CS to go high
173C(0013) 7D E8 BF 64 |                         andn outa, wait_bit             'toggle wait low
1740(0014) F2 0F BD A0 |                         mov t1, ina                     'get input bits
1744(0015) 09 0E FD 28 |                         shr t1, #9                      'get just A0, A1 and /RD
1748(0016) 07 0E FD 60 |                         and t1, #$07                    'mask just the 3 bits for jump table
174C(0017) 01 0E 7D 86 |                         cmp t1, #1     wz               'see if A0 = 1
1750(0018) 2B 00 68 5C |               if_z      jmp #keyin                      'A0 = 1, is a keyboard read request
1754(0019) 05 0E 7D 86 |                         cmp t1, #5     wz               'A0 = 1, /RD = 1
1758(001A) 36 00 68 5C |               if_z      jmp #vga_out                    'Yes process vga out
175C(001B) 06 0E 7D 86 |                         cmp t1, #6     wz               'A1 = 1, /RD = 1
1760(001C) 44 00 68 5C |               if_z      jmp #disk_cmd_in                'Read disk commands
1764(001D) 03 0E 7D 86 |                         cmp t1, #3     wz               'is this a disk read?
1768(001E) 63 00 68 5C |               if_z      jmp #disk_read                  'Do disk read
176C(001F) 02 0E 7D 86 |                         cmp t1, #2     wz
1770(0020) 5B 00 68 5C |               if_z      jmp #disk_cmd_status
1774(0021) 07 0E 7D 86 |                         cmp t1, #7     wz
1778(0022) 6E 00 68 5C |               if_z      jmp #disk_write
177C(0023) 7F 0E BD 08 | status_read             rdlong t1, _status              'get status byte
1780(0024) FF 0E FD 60 |                         and t1, #$FF                    'make sure byte
1784(0025) 79 EC BF 68 |                         or  dira, data_bits             'set D0-D7 as ouputs
1788(0026) 87 E8 BF A0 |                         mov outa, t1                    'output the status byte
178C(0027) 7D E8 BF 68 |                         or outa, wait_bit               'release wait
1790(0028) 7C F8 3C F0 |                         waitpeq cs_bit, cs_bit          'wait for CS to go high
1794(0029) 7E EC BF A0 |                         mov dira, input_port_mask       'tri-state data and set cntl for input
1798(002A) 12 00 7C 5C |                         jmp #port_loop
179C(002B)             | keyin                   
179C(002B) 81 0E BD 08 |                         rdlong t1,_key                  'Get Key from Hub
17A0(002C) FF 0E FD 60 |                         and t1, #$FF                    'Make sure it is a byte
17A4(002D) 79 EC BF 68 |                         or dira, data_bits              'set D0-D7 as outputs
17A8(002E) 87 E8 BF A0 |                         mov outa, t1                    'output key
17AC(002F) 7F 10 BD 08 |                         rdlong t2, _status              'get status
17B0(0030) 00 10 FD A0 |                         mov t2,#0                       'clear key status bit
17B4(0031) 7F 10 3D 08 |                         wrlong t2, _status              'write it to the global status
17B8(0032) 7D E8 BF 68 |                         or outa, wait_bit               'release wait
17BC(0033) 7C F8 3C F0 |                         waitpeq cs_bit, cs_bit          'wait for CS to go high
17C0(0034) 7E EC BF A0 |                         mov dira, input_port_mask       'tri-state data and set cntl for input
17C4(0035) 12 00 7C 5C |                         jmp #port_loop      
17C8(0036) 7D E8 BF 68 | vga_out                 or outa, wait_bit               'Release wait bit
17CC(0037) 79 EC BF 64 |                         andn  dira, data_bits           'Make sure D0-D7 (P0 - P7) are set for input
17D0(0038) F2 0D BD A0 |                         mov  c, ina                     'Read data from port
17D4(0039) FF 0C FD 60 |                         and  c, #$FF                    'Make sure it is a clean byte
17D8(003A) 84 10 BD 08 |                         rdlong t2, _vga_head            'Should have time to prefetch head here
17DC(003B) 7B F8 3C F0 |                         waitpeq  cs_bit, cs_mask        'Now wait to port is unselected
17E0(003C) 85 10 BD 80 |                         add  t2, v_ptr                  'Compute address to store byte
17E4(003D) 88 0C 3D 00 |                         wrbyte c, t2                    'Write the byte into vga_buffer
17E8(003E) 85 10 BD 84 |                         sub t2, v_ptr                   'Recompute value of head
17EC(003F) 01 10 FD 80 |                         add t2, #1                      'Increment head
17F0(0040) FF 10 FD 60 |                         and t2, #$FF                    'Make sure it wraps at 255
17F4(0041) 84 10 3D 08 |                         wrlong t2, _vga_head            'Store the new value of vga_head
17F8(0042) 7E EC BF A0 |                         mov dira, input_port_mask       'tri-state data and set cntl for input
17FC(0043) 12 00 7C 5C |                         jmp  #port_loop                 'Go back for more bytes
1800(0044)             | disk_cmd_in             
1800(0044) 79 EC BF 64 |                         andn dira, data_bits            'Make sure D0-D7 are set for input
1804(0045) 7D E8 BF 68 |                         or outa, wait_bit               'Release wait bit
1808(0046) F2 0D BD A0 |                         mov c, ina                      'Read data from port
180C(0047) FF 0C FD 60 |                         and c, #$FF                     'Mask it
1810(0048) 83 10 BD A0 |                         mov t2, dskcmdptr
1814(0049) 89 10 BD 80 |                         add t2, cmdcount
1818(004A) 88 0C 3D 00 |                         wrbyte c, t2
181C(004B) 55 12 7D EC |                         tjz cmdcount, #check_cmd
1820(004C) 01 12 FD 80 |                         add cmdcount, #1
1824(004D) 07 12 7D 86 |                         cmp cmdcount, #7  wz
1828(004E) 50 00 68 5C |               if_z      jmp #disk_finish                        
182C(004F) 12 00 7C 5C |                         jmp #port_loop
1830(0050) 80 10 FD A0 | disk_finish             mov t2,#$80
1834(0051) 80 10 3D 08 |                         wrlong  t2, dsk_status
1838(0052) 00 12 FD A0 |                         mov cmdcount, #0
183C(0053) 00 14 FD A0 |                         mov iobytes, #0
1840(0054) 12 00 7C 5C |                         jmp #port_loop
1844(0055) EE 0C 7D 86 | check_cmd               cmp c, #$EE  wz
1848(0056) 12 00 68 5C |               if_z      jmp #port_loop
184C(0057) AA 0C 7D 86 |                         cmp c, #$AA  wz
1850(0058) 12 00 68 5C |               if_z      jmp #port_loop
1854(0059) 01 12 FD 80 |                         add cmdcount,#1
1858(005A) 12 00 7C 5C |                         jmp #port_loop
185C(005B) 80 0E BD 08 | disk_cmd_status         rdlong t1, dsk_status           'Get Disk Status
1860(005C) FF 0E FD 60 |                         and t1, #$FF                    'Mask it
1864(005D) 79 EC BF 68 |                         or dira, data_bits              'Set D0-D7 for output
1868(005E) 87 E8 BF A0 |                         mov outa, t1                    'Output the disk Status
186C(005F) 7D E8 BF 68 |                         or outa, wait_bit               'release the wait bit
1870(0060) 7C F8 3C F0 |                         waitpeq cs_bit, cs_bit          'wait for /CS to go high
1874(0061) 7E EC BF A0 |                         mov dira, input_port_mask       'tri-state data and set cntl for input
1878(0062) 12 00 7C 5C |                         jmp #port_loop
187C(0063) 82 10 BD 08 | disk_read               rdlong t2, sector_off           'Get address of byte to read
1880(0064) 8A 10 BD 80 |                         add t2, iobytes                 'add offset in buffer
1884(0065) 88 0C BD 00 |                         rdbyte c, t2                    'Get byte from buffer
1888(0066) 01 14 FD 80 |                         add iobytes, #1                 'inc buffer offset
188C(0067) FF 0C FD 60 |                         and c, #$FF                     'mask byte
1890(0068) 79 EC BF 68 |                         or dira, data_bits              'set to ouput
1894(0069) 86 E8 BF A0 |                         mov outa, c                     'output the byte to bus
1898(006A) 7D E8 BF 68 |                         or outa, wait_bit               'release wait bit
189C(006B) 7C F8 3C F0 |                         waitpeq cs_bit, cs_bit          'wait for CS to go high
18A0(006C) 7E EC BF A0 |                         mov dira, input_port_mask       'tri-state bus again
18A4(006D) 12 00 7C 5C |                         jmp #port_loop
18A8(006E) 79 EC BF 64 | disk_write              andn dira, data_bits            'make sure D0-D7 are set for input
18AC(006F) 82 10 BD 08 |                         rdlong t2, sector_off           'get sector offset to write to
18B0(0070) 8A 10 BD 80 |                         add t2, iobytes                 'get increment to write to
18B4(0071) 01 14 FD 80 |                         add iobytes, #1                 'prep for next byte
18B8(0072) 7D E8 BF 68 |                         or outa, wait_bit
18BC(0073) F2 0D BD A0 |                         mov c, ina                      'read data
18C0(0074) FF 0C FD 60 |                         and c, #$FF                     'mask it
18C4(0075) 88 0C 3D 00 |                         wrbyte c, t2                    'write data into disk buffer
18C8(0076) 7C F8 3C F0 |                         waitpeq cs_bit, cs_bit
18CC(0077) 7E EC BF A0 |                         mov dira, input_port_mask
18D0(0078) 12 00 7C 5C |                         jmp #port_loop
18D4(0079) FF 00 00 00 | data_bits               LONG  $00FF
18D8(007A) 00 01 00 00 | input_read              LONG  $0100                     ' cs active high
18DC(007B) 00 01 00 00 | cs_mask                 LONG  $0100                     'mask for CS and RD Low ignore A0, A1
18E0(007C) 00 00 00 00 | cs_bit                  LONG  $0000
18E4(007D) 00 10 00 00 | wait_bit                LONG  $1000
18E8(007E) 00 10 00 00 | input_port_mask         LONG  $1000
18EC(007F)             | _status                 res   1
18EC(0080)             | dsk_status              res   1
18EC(0081)             | _key                    res   1
18EC(0082)             | sector_off              res   1
18EC(0083)             | dskcmdptr               res   1
18EC(0084)             | _vga_head               res   1
18EC(0085)             | v_ptr                   res   1
18EC(0086)             | c                       res   1
18EC(0087)             | t1                      res   1
18EC(0088)             | t2                      res   1
18EC(0089)             | cmdcount                res   1
18EC(008A)             | iobytes                 res   1
18EC(008B)             |                         FIT 
18EC(008B)             | There are 357 ($165) Longs left in the cog
|===========================================================================|
|===========================================================================|
Spin Block start with 0 Parameters and 0 Extra Stack Longs. Method 1
PUB start

Local Parameter DBASE:0000 - Result
|===========================================================================|
52                        stop
Addr : 18EC:             01  : Drop Anchor   
Addr : 18ED:          05 02  : Call Sub 2    
54                        status := 0
Addr : 18EF:             35  : Constant 1 $00000000
Addr : 18F0:             45  : Variable Operation Global Offset - 1 Write
55                        disk_status := 0
Addr : 18F1:             35  : Constant 1 $00000000
Addr : 18F2:             49  : Variable Operation Global Offset - 2 Write
56                        key := 0
Addr : 18F3:             35  : Constant 1 $00000000
Addr : 18F4:             4D  : Variable Operation Global Offset - 3 Write
58                        longfill(@vga_head, 0, 2)
Addr : 18F5:             5B  : Variable Operation Global Offset - 6 Address
Addr : 18F6:             35  : Constant 1 $00000000
Addr : 18F7:          37 00  : Constant Mask Y=0 00000002 2
Addr : 18F9:             1A  : LongFill(Start, Value, Count)
59                        vga_buffer_ptr := @vga_buffer
Addr : 18FA:          8B 24  : Memory Op Byte VBASE + ADDRESS Address = 0024
Addr : 18FC:          C9 20  : Memory Op Long VBASE + WRITE Address = 0020
60                        dsk_cmdbuf_ptr := @dsk_cmdbuf
Addr : 18FE:       8B 81 24  : Memory Op Byte VBASE + ADDRESS Address = 0124
Addr : 1901:             55  : Variable Operation Global Offset - 5 Write
Addr : 1902:             34  : Constant 0 $FFFFFFFF
62                        cog := cognew(@port_init, @status) + 1
Addr : 1903:          C7 3C  : Memory Op Long PBASE + ADDRESS Address = 003C
Addr : 1905:             47  : Variable Operation Global Offset - 1 Address
Addr : 1906:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 1907:             36  : Constant 2 $00000001
Addr : 1908:             EC  : Math Op +     
Addr : 1909:             41  : Variable Operation Global Offset - 0 Write
Addr : 190A:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 2
PUB stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
66                        if cog
Addr : 190B:             40  : Variable Operation Global Offset - 0 Read
Addr : 190C: JZ Label0002
Addr : 190C:          0A 05  : jz Address = 1913 5
67                          cogstop(cog~ - 1)
Addr : 190E:          42 98  : Variable Operation Global Offset - 0 Assign VAR~ Post-clear Push
Addr : 1910:             36  : Constant 2 $00000001
Addr : 1911:             ED  : Math Op -     
Addr : 1912:             21  : CogStop(id)   
Addr : 1913: Label0002
Addr : 1913: Label0003
Addr : 1913:             32  : Return        
|===========================================================================|
Spin Block set_status with 1 Parameters and 0 Extra Stack Longs. Method 3
PUB set_status(value)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
|===========================================================================|
70                        status := value
Addr : 1914:             64  : Variable Operation Local Offset - 1 Read
Addr : 1915:             45  : Variable Operation Global Offset - 1 Write
Addr : 1916:             32  : Return        
|===========================================================================|
Spin Block get_status with 0 Parameters and 0 Extra Stack Longs. Method 4
PUB get_status : value

Local Parameter DBASE:0000 - value
|===========================================================================|
73                        value := status
Addr : 1917:             44  : Variable Operation Global Offset - 1 Read
Addr : 1918:             61  : Variable Operation Local Offset - 0 Write
Addr : 1919:             32  : Return        
|===========================================================================|
Spin Block get_disk_command with 0 Parameters and 0 Extra Stack Longs. Method 5
PUB get_disk_command : value

Local Parameter DBASE:0000 - value
|===========================================================================|
Addr : 191A:             35  : Constant 1 $00000000
# Source File : lib/hc11_Ports.spin
76                        value := dsk_cmdbuf[DSK_CMD]
Addr : 191B:       98 81 24  : Memory Op Byte VBASE + POP Index READ Address = 0124
Addr : 191E:             61  : Variable Operation Local Offset - 0 Write
Addr : 191F:             32  : Return        
|===========================================================================|
Spin Block set_disk_command with 1 Parameters and 0 Extra Stack Longs. Method 6
PUB set_disk_command(value)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
|===========================================================================|
79                        dsk_cmdbuf[DSK_CMD] := value
Addr : 1920:             64  : Variable Operation Local Offset - 1 Read
Addr : 1921:             35  : Constant 1 $00000000
Addr : 1922:       99 81 24  : Memory Op Byte VBASE + POP Index WRITE Address = 0124
Addr : 1925:             32  : Return        
|===========================================================================|
Spin Block set_disk_status with 1 Parameters and 0 Extra Stack Longs. Method 7
PUB set_disk_status(value)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
|===========================================================================|
82                        disk_status := value
Addr : 1926:             64  : Variable Operation Local Offset - 1 Read
Addr : 1927:             49  : Variable Operation Global Offset - 2 Write
Addr : 1928:             32  : Return        
|===========================================================================|
Spin Block get_disk_status with 0 Parameters and 0 Extra Stack Longs. Method 8
PUB get_disk_status : value

Local Parameter DBASE:0000 - value
|===========================================================================|
85                        value := disk_status
Addr : 1929:             48  : Variable Operation Global Offset - 2 Read
Addr : 192A:             61  : Variable Operation Local Offset - 0 Write
Addr : 192B:             32  : Return        
|===========================================================================|
Spin Block get_drive_number with 0 Parameters and 0 Extra Stack Longs. Method 9
PUB get_drive_number : value

Local Parameter DBASE:0000 - value
|===========================================================================|
Addr : 192C:             36  : Constant 2 $00000001
# Source File : lib/hc11_Ports.spin
88                        value := dsk_cmdbuf[DSK_DRIVE]
Addr : 192D:       98 81 24  : Memory Op Byte VBASE + POP Index READ Address = 0124
Addr : 1930:             61  : Variable Operation Local Offset - 0 Write
Addr : 1931:             32  : Return        
|===========================================================================|
Spin Block get_track_number with 0 Parameters and 0 Extra Stack Longs. Method 10
PUB get_track_number : value

Local Parameter DBASE:0000 - value
|===========================================================================|
91                        value := 256 * dsk_cmdbuf[DSK_TRK_HI] + dsk_cmdbuf[DSK_TRK_LO]
Addr : 1932:          37 07  : Constant Mask Y=7 00000100 256
Addr : 1934:          37 01  : Constant Mask Y=1 00000004 4
Addr : 1936:       98 81 24  : Memory Op Byte VBASE + POP Index READ Address = 0124
Addr : 1939:             F4  : Math Op *     
Addr : 193A:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 193C:       98 81 24  : Memory Op Byte VBASE + POP Index READ Address = 0124
Addr : 193F:             EC  : Math Op +     
Addr : 1940:             61  : Variable Operation Local Offset - 0 Write
Addr : 1941:             32  : Return        
|===========================================================================|
Spin Block get_sector_number with 0 Parameters and 0 Extra Stack Longs. Method 11
PUB get_sector_number : value

Local Parameter DBASE:0000 - value
|===========================================================================|
Addr : 1942:          37 00  : Constant Mask Y=0 00000002 2
# Source File : lib/hc11_Ports.spin
94                        value := dsk_cmdbuf[DSK_SECT_NUM]
Addr : 1944:       98 81 24  : Memory Op Byte VBASE + POP Index READ Address = 0124
Addr : 1947:             61  : Variable Operation Local Offset - 0 Write
Addr : 1948:             32  : Return        
|===========================================================================|
Spin Block set_sector_offset with 1 Parameters and 0 Extra Stack Longs. Method 12
PUB set_sector_offset(value)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
|===========================================================================|
97                        sector_offset := value
Addr : 1949:             64  : Variable Operation Local Offset - 1 Read
Addr : 194A:             51  : Variable Operation Global Offset - 4 Write
Addr : 194B:             32  : Return        
|===========================================================================|
Spin Block set_key with 1 Parameters and 0 Extra Stack Longs. Method 13
PUB set_key(value)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
|===========================================================================|
100                        key := value
Addr : 194C:             64  : Variable Operation Local Offset - 1 Read
Addr : 194D:             4D  : Variable Operation Global Offset - 3 Write
Addr : 194E:             32  : Return        
|===========================================================================|
Spin Block vga_check with 0 Parameters and 0 Extra Stack Longs. Method 14
PUB vga_check : vga_byte

Local Parameter DBASE:0000 - vga_byte
|===========================================================================|
107                        vga_byte := 255
Addr : 194F:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
Addr : 1951:             61  : Variable Operation Local Offset - 0 Write
108                        if vga_tail <> vga_head
Addr : 1952:             5C  : Variable Operation Global Offset - 7 Read
Addr : 1953:             58  : Variable Operation Global Offset - 6 Read
Addr : 1954:             FB  : Math Op <>    
Addr : 1955: JZ Label0002
Addr : 1955:          0A 0A  : jz Address = 1961 10
109                          vga_byte := vga_buffer[vga_tail]
Addr : 1957:             5C  : Variable Operation Global Offset - 7 Read
Addr : 1958:          98 24  : Memory Op Byte VBASE + POP Index READ Address = 0024
Addr : 195A:             61  : Variable Operation Local Offset - 0 Write
110                          vga_tail := ++vga_tail & $FF
Addr : 195B:          5E A6  : Variable Operation Global Offset - 7 Assign ++VAR pre-inc Long Push
Addr : 195D:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
Addr : 195F:             E8  : Math Op &     
Addr : 1960:             5D  : Variable Operation Global Offset - 7 Write
Addr : 1961: Label0002
Addr : 1961: Label0003
Addr : 1961:             32  : Return        
|===========================================================================|
Object Keyboard
Object Base is 1964
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable cog
VBASE : 0004 LONG Size 0004 Variable par_tail
VBASE : 0008 LONG Size 0004 Variable par_head
VBASE : 000C LONG Size 0004 Variable par_present
VBASE : 0010 LONG Size 0020 Variable par_states
VBASE : 0030 LONG Size 0020 Variable par_keys
VBASE : 0050 LONG Size 0004 Variable nkey
VBASE : 0054 LONG Size 0004 Variable dkeyhd
VBASE : 0058 LONG Size 0004 Variable dkeytail
VBASE : 005C BYTE Size 0010 Variable dkeys
|===========================================================================|
Object DAT Blocks
|===========================================================================|
198C(0000)             |                         org
198C(0000) 3D 09 FC 54 | entry                   movd    :par,#_dpin             'load input parameters _dpin/_cpin/_locks/_auto
1990(0001) F0 61 BE A0 |                         mov     x,par
1994(0002) 2C 60 FE 80 |                         add     x,#11*4
1998(0003) 04 62 FE A0 |                         mov     y,#4
199C(0004) 30 01 BC 08 | :par                    rdlong  0,x
19A0(0005) D8 08 BC 80 |                         add     :par,dlsb
19A4(0006) 04 60 FE 80 |                         add     x,#4
19A8(0007) 04 62 FE E4 |                         djnz    y,#:par
19AC(0008) 01 58 FE A0 |                         mov     dmask,#1                'set pin masks
19B0(0009) 3D 59 BE 2C |                         shl     dmask,_dpin
19B4(000A) 01 5A FE A0 |                         mov     cmask,#1
19B8(000B) 3E 5B BE 2C |                         shl     cmask,_cpin
19BC(000C) 20 7A 7E 61 |                         test    _dpin,#$20      wc      'modify port registers within code
19C0(000D) D8 3E BD 70 |                         muxc    _d1,dlsb
19C4(000E) D8 52 BD 70 |                         muxc    _d2,dlsb
19C8(000F) 01 76 FD 70 |                         muxc    _d3,#1
19CC(0010) 01 94 FD 70 |                         muxc    _d4,#1
19D0(0011) 20 7C 7E 61 |                         test    _cpin,#$20      wc
19D4(0012) D8 38 BD 70 |                         muxc    _c1,dlsb
19D8(0013) D8 44 BD 70 |                         muxc    _c2,dlsb
19DC(0014) 01 92 FD 70 |                         muxc    _c3,#1
19E0(0015) 00 66 FE A0 |                         mov     _head,#0                'reset output parameter _head
19E4(0016) 00 EC FF A0 | reset                   mov     dira,#0                 'reset directions
19E8(0017) 00 EE FF A0 |                         mov     dirb,#0
19EC(0018) 34 35 FC 54 |                         movd    :par,#_present          'reset output parameters _present/_states[8]
19F0(0019) 09 60 FE A0 |                         mov     x,#1+8
19F4(001A) 00 00 FC A0 | :par                    mov     0,#0
19F8(001B) D8 34 BC 80 |                         add     :par,dlsb
19FC(001C) 1A 60 FE E4 |                         djnz    x,#:par
1A00(001D) 08 5C FE A0 |                         mov     stat,#8                 'set reset flag
1A04(001E) 33 45 FC 54 | update                  movd    :par,#_head             'update output parameters _head/_present/_states[8]
1A08(001F) F0 61 BE A0 |                         mov     x,par
1A0C(0020) 04 60 FE 80 |                         add     x,#1*4
1A10(0021) 0A 62 FE A0 |                         mov     y,#1+1+8
1A14(0022) 30 01 3C 08 | :par                    wrlong  0,x
1A18(0023) D8 44 BC 80 |                         add     :par,dlsb
1A1C(0024) 04 60 FE 80 |                         add     x,#4
1A20(0025) 22 62 FE E4 |                         djnz    y,#:par
1A24(0026) 08 5C 7E 61 |                         test    stat,#8         wc      'if reset flag, transmit reset command
1A28(0027) FF 5E F2 A0 |         if_c            mov     data,#$FF
1A2C(0028) 9C 68 F1 5C |         if_c            call    #transmit
1A30(0029) 00 5C FE A0 | newcode                 mov     stat,#0                 'reset state
1A34(002A) B5 88 FD 5C | :same                   call    #receive                'receive byte from keyboard
1A38(002B) 84 5E 7E 85 |                         cmp     data,#$83+1     wc      'scancode?
1A3C(002C) AA 5E 4E 86 |         if_nc           cmp     data,#$AA       wz      'powerup/reset?
1A40(002D) 80 00 48 5C |         if_nc_and_z     jmp     #configure
1A44(002E) E0 5E 4E 86 |         if_nc           cmp     data,#$E0       wz      'extended?
1A48(002F) 01 5C CA 68 |         if_nc_and_z     or      stat,#1
1A4C(0030) 2A 00 48 5C |         if_nc_and_z     jmp     #:same
1A50(0031) F0 5E 4E 86 |         if_nc           cmp     data,#$F0       wz      'released?
1A54(0032) 02 5C CA 68 |         if_nc_and_z     or      stat,#2
1A58(0033) 2A 00 48 5C |         if_nc_and_z     jmp     #:same
1A5C(0034) 29 00 4C 5C |         if_nc           jmp     #newcode                'unknown, ignore
1A60(0035) 01 5C 7E 61 |                         test    stat,#1         wc      'lookup code with extended flag
1A64(0036) 01 5E FE 34 |                         rcl     data,#1
1A68(0037) 94 88 FD 5C |                         call    #look
1A6C(0038) 00 5E 7E 86 |                         cmp     data,#0         wz      'if unknown, ignore
1A70(0039) 29 00 68 5C |         if_z            jmp     #newcode
1A74(003A) 3B 65 BE A0 |                         mov     t,_states+6             'remember lock keys in _states
1A78(003B) 2F 61 BE A0 |                         mov     x,data                  'set/clear key bit in _states
1A7C(003C) 05 60 FE 28 |                         shr     x,#5
1A80(003D) 35 61 FE 80 |                         add     x,#_states
1A84(003E) 30 85 BC 54 |                         movd    :reg,x
1A88(003F) 01 62 FE A0 |                         mov     y,#1
1A8C(0040) 2F 63 BE 2C |                         shl     y,data
1A90(0041) 02 5C 7E 61 |                         test    stat,#2         wc
1A94(0042) 31 01 BC 74 | :reg                    muxnc   0,y
1A98(0043) F0 5E CE E1 |         if_nc           cmpsub  data,#$F0       wc      'if released or shift/ctrl/alt/win, done
1A9C(0044) 1E 00 70 5C |         if_c            jmp     #update
1AA0(0045) 3C 63 BE A0 |                         mov     y,_states+7             'get shift/ctrl/alt/win bit pairs
1AA4(0046) 10 62 FE 28 |                         shr     y,#16
1AA8(0047) E0 5E FE E1 |                         cmpsub  data,#$E0       wc      'translate keypad, considering numlock
1AAC(0048) 04 7E 72 62 |         if_c            test    _locks,#%100    wz
1AB0(0049) 08 5F E2 80 |         if_c_and_z      add     data,#@keypad1-@table
1AB4(004A) 18 5F D2 80 |         if_c_and_nz     add     data,#@keypad2-@table
1AB8(004B) 94 88 F1 5C |         if_c            call    #look
1ABC(004C) 6A 00 70 5C |         if_c            jmp     #:flags
1AC0(004D) DD 5E FE E1 |                         cmpsub  data,#$DD       wc      'handle scrlock/capslock/numlock
1AC4(004E) 08 60 F2 A0 |         if_c            mov     x,#%001_000
1AC8(004F) 2F 61 B2 2C |         if_c            shl     x,data
1ACC(0050) 3F 61 B2 64 |         if_c            andn    x,_locks
1AD0(0051) 03 60 F2 28 |         if_c            shr     x,#3
1AD4(0052) 1D 64 F2 28 |         if_c            shr     t,#29                   'ignore auto-repeat
1AD8(0053) 32 61 B2 66 |         if_c            andn    x,t             wz
1ADC(0054) 30 7F B2 6C |         if_c            xor     _locks,x
1AE0(0055) DD 5E F2 80 |         if_c            add     data,#$DD
1AE4(0056) 04 5C D2 68 |         if_c_and_nz     or      stat,#4                 'if change, set configure flag to update leds
1AE8(0057) 03 62 7E 62 |                         test    y,#%11          wz      'get shift into nz
1AEC(0058) 61 5E 56 85 |         if_nz           cmp     data,#$60+1     wc      'check shift1
1AF0(0059) 5B 5E D2 E1 |         if_nz_and_c     cmpsub  data,#$5B       wc
1AF4(005A) 28 5F D2 80 |         if_nz_and_c     add     data,#@shift1-@table
1AF8(005B) 94 88 D1 5C |         if_nz_and_c     call    #look
1AFC(005C) 03 62 D2 64 |         if_nz_and_c     andn    y,#%11
1B00(005D) 3E 5E 56 85 |         if_nz           cmp     data,#$3D+1     wc      'check shift2
1B04(005E) 27 5E D2 E1 |         if_nz_and_c     cmpsub  data,#$27       wc
1B08(005F) 2E 5F D2 80 |         if_nz_and_c     add     data,#@shift2-@table
1B0C(0060) 94 88 D1 5C |         if_nz_and_c     call    #look
1B10(0061) 03 62 D2 64 |         if_nz_and_c     andn    y,#%11
1B14(0062) 02 7E 7E 61 |                         test    _locks,#%010    wc      'check shift-alpha, considering capslock
1B18(0063) 20 D0 FC 74 |                         muxnc   :shift,#$20
1B1C(0064) 40 7E 7E 61 |                         test    _locks,#$40     wc
1B20(0065) 20 D0 C4 6C |         if_nz_and_nc    xor     :shift,#$20
1B24(0066) 7B 5E 7E 85 |                         cmp     data,#"z"+1     wc
1B28(0067) 61 5E F2 E1 |         if_c            cmpsub  data,#"a"       wc
1B2C(0068) 41 5E F2 80 | :shift  if_c            add     data,#"A"
1B30(0069) 03 62 F2 64 |         if_c            andn    y,#%11
1B34(006A) 08 5E FE 20 | :flags                  ror     data,#8                 'add shift/ctrl/alt/win flags
1B38(006B) 04 60 FE A0 |                         mov     x,#4                    '+$100 if shift
1B3C(006C) 03 62 7E 62 | :loop                   test    y,#%11          wz      '+$200 if ctrl
1B40(006D) 02 62 FE 28 |                         shr     y,#2                    '+$400 if alt
1B44(006E) 01 5E D6 68 |         if_nz           or      data,#1                 '+$800 if win
1B48(006F) 01 5E FE 20 |                         ror     data,#1
1B4C(0070) 6C 60 FE E4 |                         djnz    x,#:loop
1B50(0071) 0C 5E FE 24 |                         rol     data,#12
1B54(0072) F0 61 BE 08 |                         rdlong  x,par                   'if room in buffer and key valid, enter
1B58(0073) 01 60 FE 84 |                         sub     x,#1
1B5C(0074) 0F 60 FE 60 |                         and     x,#$F
1B60(0075) 33 61 3E 86 |                         cmp     x,_head         wz
1B64(0076) FF 5E 56 62 |         if_nz           test    data,#$FF       wz
1B68(0077) F0 61 96 A0 |         if_nz           mov     x,par
1B6C(0078) 2C 60 D6 80 |         if_nz           add     x,#11*4
1B70(0079) 33 61 96 80 |         if_nz           add     x,_head
1B74(007A) 33 61 96 80 |         if_nz           add     x,_head
1B78(007B) 30 5F 16 04 |         if_nz           wrword  data,x
1B7C(007C) 01 66 D6 80 |         if_nz           add     _head,#1
1B80(007D) 0F 66 D6 60 |         if_nz           and     _head,#$F
1B84(007E) 04 5C 7E 61 |                         test    stat,#4         wc      'if not configure flag, done
1B88(007F) 1E 00 4C 5C |         if_nc           jmp     #update                 'else configure to update leds
1B8C(0080) F3 5E FE A0 | configure               mov     data,#$F3               'set keyboard auto-repeat
1B90(0081) 9C 68 FD 5C |                         call    #transmit
1B94(0082) 40 5F BE A0 |                         mov     data,_auto
1B98(0083) 7F 5E FE 60 |                         and     data,#%11_11111
1B9C(0084) 9C 68 FD 5C |                         call    #transmit
1BA0(0085) ED 5E FE A0 |                         mov     data,#$ED               'set keyboard lock-leds
1BA4(0086) 9C 68 FD 5C |                         call    #transmit
1BA8(0087) 3F 5F BE A0 |                         mov     data,_locks
1BAC(0088) 1D 5E FE 3C |                         rev     data,#-3 & $1F
1BB0(0089) 04 5E 7E 61 |                         test    data,#%100      wc
1BB4(008A) 01 5E FE 34 |                         rcl     data,#1
1BB8(008B) 07 5E FE 60 |                         and     data,#%111
1BBC(008C) 9C 68 FD 5C |                         call    #transmit
1BC0(008D) 3F 61 BE A0 |                         mov     x,_locks                'insert locks into _states
1BC4(008E) 07 60 FE 60 |                         and     x,#%111
1BC8(008F) 03 78 FE 2C |                         shl     _states+7,#3
1BCC(0090) 30 79 BE 68 |                         or      _states+7,x
1BD0(0091) 03 78 FE 20 |                         ror     _states+7,#3
1BD4(0092) 01 68 FE A0 |                         mov     _present,#1             'set _present
1BD8(0093) 1E 00 7C 5C |                         jmp     #update                 'done
1BDC(0094) 02 5E FE 20 | look                    ror     data,#2                 'perform lookup
1BE0(0095) 2F 33 BD 50 |                         movs    :reg,data
1BE4(0096) DA 32 FD 80 |                         add     :reg,#table
1BE8(0097) 1B 5E FE 28 |                         shr     data,#27
1BEC(0098) 2F 61 BE A0 |                         mov     x,data
1BF0(0099) 00 5E BE A0 | :reg                    mov     data,0
1BF4(009A) 30 5F BE 28 |                         shr     data,x
1BF8(009B) C3 00 7C 5C |                         jmp     #rand                   'isolate byte
1BFC(009C)             | transmit
1BFC(009C) 2D ED BF 68 | _c1                     or      dira,cmask              'pull clock low
1C00(009D) 0D A6 FD 50 |                         movs    napshr,#13              'hold clock for ~128us (must be >100us)
1C04(009E) D2 AE FD 5C |                         call    #nap
1C08(009F) 2C ED BF 68 | _d1                     or      dira,dmask              'pull data low
1C0C(00A0) 12 A6 FD 50 |                         movs    napshr,#18              'hold data for ~4us
1C10(00A1) D2 AE FD 5C |                         call    #nap
1C14(00A2) 2D ED BF 6C | _c2                     xor     dira,cmask              'release clock
1C18(00A3) FF 5E 7E 61 |                         test    data,#$0FF      wc      'append parity and stop bits to byte
1C1C(00A4) 00 5F FE 74 |                         muxnc   data,#$100
1C20(00A5) D8 5E BE 68 |                         or      data,dlsb
1C24(00A6) 0A 60 FE A0 |                         mov     x,#10                   'ready 10 bits
1C28(00A7) C5 9A FD 5C | transmit_bit            call    #wait_c0                'wait until clock low
1C2C(00A8) 01 5E FE 29 |                         shr     data,#1         wc      'output data bit
1C30(00A9) 2C ED BF 74 | _d2                     muxnc   dira,dmask
1C34(00AA) CF 96 BD A0 |                         mov     wcond,c1                'wait until clock high
1C38(00AB) C6 9A FD 5C |                         call    #wait
1C3C(00AC) A7 60 FE E4 |                         djnz    x,#transmit_bit         'another bit?
1C40(00AD) D0 96 BD A0 |                         mov     wcond,c0d0              'wait until clock and data low
1C44(00AE) C6 9A FD 5C |                         call    #wait
1C48(00AF) D1 96 BD A0 |                         mov     wcond,c1d1              'wait until clock and data high
1C4C(00B0) C6 9A FD 5C |                         call    #wait
1C50(00B1) B7 88 FD 5C |                         call    #receive_ack            'receive ack byte with timed wait
1C54(00B2) FA 5E 7E 86 |                         cmp     data,#$FA       wz      'if ack error, reset keyboard
1C58(00B3) 16 00 54 5C |         if_nz           jmp     #reset
1C5C(00B4) 00 00 7C 5C | transmit_ret            ret
1C60(00B5) 20 7C 7E 61 | receive                 test    _cpin,#$20      wc      'wait indefinitely for initial clock low
1C64(00B6) 2D 5B 3E F4 |                         waitpne cmask,cmask
1C68(00B7)             | receive_ack
1C68(00B7) 0B 60 FE A0 |                         mov     x,#11                   'ready 11 bits
1C6C(00B8) C5 9A FD 5C | receive_bit             call    #wait_c0                'wait until clock low
1C70(00B9) 10 A6 FD 50 |                         movs    napshr,#16              'pause ~16us
1C74(00BA) D2 AE FD 5C |                         call    #nap
1C78(00BB) F2 59 3E 61 | _d3                     test    dmask,ina       wc      'input data bit
1C7C(00BC) 01 5E FE 30 |                         rcr     data,#1
1C80(00BD) CF 96 BD A0 |                         mov     wcond,c1                'wait until clock high
1C84(00BE) C6 9A FD 5C |                         call    #wait
1C88(00BF) B8 60 FE E4 |                         djnz    x,#receive_bit          'another bit?
1C8C(00C0) 16 5E FE 28 |                         shr     data,#22                'align byte
1C90(00C1) FF 5F 7E 61 |                         test    data,#$1FF      wc      'if parity error, reset keyboard
1C94(00C2) 16 00 4C 5C |         if_nc           jmp     #reset
1C98(00C3) FF 5E FE 60 | rand                    and     data,#$FF               'isolate byte
1C9C(00C4)             | look_ret
1C9C(00C4)             | receive_ack_ret
1C9C(00C4) 00 00 7C 5C | receive_ret             ret
1CA0(00C5) CE 96 BD A0 | wait_c0                 mov     wcond,c0                '(wait until clock low)
1CA4(00C6) D9 62 BE A0 | wait                    mov     y,tenms                 'set timeout to 10ms
1CA8(00C7) 12 A6 FD 50 | wloop                   movs    napshr,#18              'nap ~4us
1CAC(00C8) D2 AE FD 5C |                         call    #nap
1CB0(00C9) F2 5B 3E 61 | _c3                     test    cmask,ina       wc      'check required state(s)
1CB4(00CA) F2 59 3E 62 | _d4                     test    dmask,ina       wz      'loop until got state(s) or timeout
1CB8(00CB) C7 62 C2 E4 | wcond   if_never        djnz    y,#wloop                '(replaced with c0/c1/c0d0/c1d1)
1CBC(00CC) 16 62 7E EC |                         tjz     y,#reset                'if timeout, reset keyboard
1CC0(00CD)             | wait_ret
1CC0(00CD) 00 00 7C 5C | wait_c0_ret             ret
1CC4(00CE) C7 62 F2 E4 | c0      if_c            djnz    y,#wloop                '(if_never replacements)
1CC8(00CF) C7 62 CE E4 | c1      if_nc           djnz    y,#wloop
1CCC(00D0) C7 62 F6 E4 | c0d0    if_c_or_nz      djnz    y,#wloop
1CD0(00D1) C7 62 EE E4 | c1d1    if_nc_or_z      djnz    y,#wloop
1CD4(00D2) 00 64 FE 08 | nap                     rdlong  t,#0                    'get clkfreq
1CD8(00D3) 00 64 FE 28 | napshr                  shr     t,#18/16/13             'shr scales time
1CDC(00D4) 03 64 FE 48 |                         min     t,#3                    'ensure waitcnt won't snag
1CE0(00D5) F1 65 BE 80 |                         add     t,cnt                   'add cnt to time
1CE4(00D6) 00 64 FE F8 |                         waitcnt t,#0                    'wait until time elapses (nap)
1CE8(00D7) 00 00 7C 5C | nap_ret                 ret
1CEC(00D8) 00 02 00 00 | dlsb                    long    1 << 9
1CF0(00D9) C4 09 00 00 | tenms                   long    10_000 / 4
1CF4(00DA) 00 00       | table                   word    $0000   '00
1CF6(00DA) D8 00       |                         word    $00D8   '01             F9
1CF8(00DB) 00 00       |                         word    $0000   '02
1CFA(00DB) D4 00       |                         word    $00D4   '03             F5
1CFC(00DC) D2 00       |                         word    $00D2   '04             F3
1CFE(00DC) D0 00       |                         word    $00D0   '05             F1
1D00(00DD) D1 00       |                         word    $00D1   '06             F2
1D02(00DD) DB 00       |                         word    $00DB   '07             F12
1D04(00DE) 00 00       |                         word    $0000   '08
1D06(00DE) D9 00       |                         word    $00D9   '09             F10
1D08(00DF) D7 00       |                         word    $00D7   '0A             F8
1D0A(00DF) D5 00       |                         word    $00D5   '0B             F6
1D0C(00E0) D3 00       |                         word    $00D3   '0C             F4
1D0E(00E0) 09 00       |                         word    $0009   '0D             Tab
1D10(00E1) 60 00       |                         word    $0060   '0E             `
1D12(00E1) 00 00       |                         word    $0000   '0F
1D14(00E2) 00 00       |                         word    $0000   '10
1D16(00E2) F4 F5       |                         word    $F5F4   '11     Alt-R   Alt-L
1D18(00E3) F0 00       |                         word    $00F0   '12             Shift-L
1D1A(00E3) 00 00       |                         word    $0000   '13
1D1C(00E4) F2 F3       |                         word    $F3F2   '14     Ctrl-R  Ctrl-L
1D1E(00E4) 71 00       |                         word    $0071   '15             q
1D20(00E5) 31 00       |                         word    $0031   '16             1
1D22(00E5) 00 00       |                         word    $0000   '17
1D24(00E6) 00 00       |                         word    $0000   '18
1D26(00E6) 00 00       |                         word    $0000   '19
1D28(00E7) 7A 00       |                         word    $007A   '1A             z
1D2A(00E7) 73 00       |                         word    $0073   '1B             s
1D2C(00E8) 61 00       |                         word    $0061   '1C             a
1D2E(00E8) 77 00       |                         word    $0077   '1D             w
1D30(00E9) 32 00       |                         word    $0032   '1E             2
1D32(00E9) 00 F6       |                         word    $F600   '1F     Win-L
1D34(00EA) 00 00       |                         word    $0000   '20
1D36(00EA) 63 00       |                         word    $0063   '21             c
1D38(00EB) 78 00       |                         word    $0078   '22             x
1D3A(00EB) 64 00       |                         word    $0064   '23             d
1D3C(00EC) 65 00       |                         word    $0065   '24             e
1D3E(00EC) 34 00       |                         word    $0034   '25             4
1D40(00ED) 33 00       |                         word    $0033   '26             3
1D42(00ED) 00 F7       |                         word    $F700   '27     Win-R
1D44(00EE) 00 00       |                         word    $0000   '28
1D46(00EE) 20 00       |                         word    $0020   '29             Space
1D48(00EF) 76 00       |                         word    $0076   '2A             v
1D4A(00EF) 66 00       |                         word    $0066   '2B             f
1D4C(00F0) 74 00       |                         word    $0074   '2C             t
1D4E(00F0) 72 00       |                         word    $0072   '2D             r
1D50(00F1) 35 00       |                         word    $0035   '2E             5
1D52(00F1) 00 CC       |                         word    $CC00   '2F     Apps
1D54(00F2) 00 00       |                         word    $0000   '30
1D56(00F2) 6E 00       |                         word    $006E   '31             n
1D58(00F3) 62 00       |                         word    $0062   '32             b
1D5A(00F3) 68 00       |                         word    $0068   '33             h
1D5C(00F4) 67 00       |                         word    $0067   '34             g
1D5E(00F4) 79 00       |                         word    $0079   '35             y
1D60(00F5) 36 00       |                         word    $0036   '36             6
1D62(00F5) 00 CD       |                         word    $CD00   '37     Power
1D64(00F6) 00 00       |                         word    $0000   '38
1D66(00F6) 00 00       |                         word    $0000   '39
1D68(00F7) 6D 00       |                         word    $006D   '3A             m
1D6A(00F7) 6A 00       |                         word    $006A   '3B             j
1D6C(00F8) 75 00       |                         word    $0075   '3C             u
1D6E(00F8) 37 00       |                         word    $0037   '3D             7
1D70(00F9) 38 00       |                         word    $0038   '3E             8
1D72(00F9) 00 CE       |                         word    $CE00   '3F     Sleep
1D74(00FA) 00 00       |                         word    $0000   '40
1D76(00FA) 2C 00       |                         word    $002C   '41             ,
1D78(00FB) 6B 00       |                         word    $006B   '42             k
1D7A(00FB) 69 00       |                         word    $0069   '43             i
1D7C(00FC) 6F 00       |                         word    $006F   '44             o
1D7E(00FC) 30 00       |                         word    $0030   '45             0
1D80(00FD) 39 00       |                         word    $0039   '46             9
1D82(00FD) 00 00       |                         word    $0000   '47
1D84(00FE) 00 00       |                         word    $0000   '48
1D86(00FE) 2E 00       |                         word    $002E   '49             .
1D88(00FF) 2F EF       |                         word    $EF2F   '4A     (/)     /
1D8A(00FF) 6C 00       |                         word    $006C   '4B             l
1D8C(0100) 3B 00       |                         word    $003B   '4C             ;
1D8E(0100) 70 00       |                         word    $0070   '4D             p
1D90(0101) 2D 00       |                         word    $002D   '4E             -
1D92(0101) 00 00       |                         word    $0000   '4F
1D94(0102) 00 00       |                         word    $0000   '50
1D96(0102) 00 00       |                         word    $0000   '51
1D98(0103) 27 00       |                         word    $0027   '52             '
1D9A(0103) 00 00       |                         word    $0000   '53
1D9C(0104) 5B 00       |                         word    $005B   '54             [
1D9E(0104) 3D 00       |                         word    $003D   '55             =
1DA0(0105) 00 00       |                         word    $0000   '56
1DA2(0105) 00 00       |                         word    $0000   '57
1DA4(0106) DE 00       |                         word    $00DE   '58             CapsLock
1DA6(0106) F1 00       |                         word    $00F1   '59             Shift-R
1DA8(0107) 0D EB       |                         word    $EB0D   '5A     (Enter) Enter
1DAA(0107) 5D 00       |                         word    $005D   '5B             ]
1DAC(0108) 00 00       |                         word    $0000   '5C
1DAE(0108) 5C 00       |                         word    $005C   '5D             \
1DB0(0109) 00 CF       |                         word    $CF00   '5E     WakeUp
1DB2(0109) 00 00       |                         word    $0000   '5F
1DB4(010A) 00 00       |                         word    $0000   '60
1DB6(010A) 00 00       |                         word    $0000   '61
1DB8(010B) 00 00       |                         word    $0000   '62
1DBA(010B) 00 00       |                         word    $0000   '63
1DBC(010C) 00 00       |                         word    $0000   '64
1DBE(010C) 00 00       |                         word    $0000   '65
1DC0(010D) C8 00       |                         word    $00C8   '66             BackSpace
1DC2(010D) 00 00       |                         word    $0000   '67
1DC4(010E) 00 00       |                         word    $0000   '68
1DC6(010E) E1 C5       |                         word    $C5E1   '69     End     (1)
1DC8(010F) 00 00       |                         word    $0000   '6A
1DCA(010F) E4 C0       |                         word    $C0E4   '6B     Left    (4)
1DCC(0110) E7 C4       |                         word    $C4E7   '6C     Home    (7)
1DCE(0110) 00 00       |                         word    $0000   '6D
1DD0(0111) 00 00       |                         word    $0000   '6E
1DD2(0111) 00 00       |                         word    $0000   '6F
1DD4(0112) E0 CA       |                         word    $CAE0   '70     Insert  (0)
1DD6(0112) EA C9       |                         word    $C9EA   '71     Delete  (.)
1DD8(0113) E2 C3       |                         word    $C3E2   '72     Down    (2)
1DDA(0113) E5 00       |                         word    $00E5   '73             (5)
1DDC(0114) E6 C1       |                         word    $C1E6   '74     Right   (6)
1DDE(0114) E8 C2       |                         word    $C2E8   '75     Up      (8)
1DE0(0115) CB 00       |                         word    $00CB   '76             Esc
1DE2(0115) DF 00       |                         word    $00DF   '77             NumLock
1DE4(0116) DA 00       |                         word    $00DA   '78             F11
1DE6(0116) EC 00       |                         word    $00EC   '79             (+)
1DE8(0117) E3 C7       |                         word    $C7E3   '7A     PageDn  (3)
1DEA(0117) ED 00       |                         word    $00ED   '7B             (-)
1DEC(0118) EE DC       |                         word    $DCEE   '7C     PrScr   (*)
1DEE(0118) E9 C6       |                         word    $C6E9   '7D     PageUp  (9)
1DF0(0119) DD 00       |                         word    $00DD   '7E             ScrLock
1DF2(0119) 00 00       |                         word    $0000   '7F
1DF4(011A) 00 00       |                         word    $0000   '80
1DF6(011A) 00 00       |                         word    $0000   '81
1DF8(011B) 00 00       |                         word    $0000   '82
1DFA(011B) D6 00       |                         word    $00D6   '83             F7
1DFC(011C) CA          | keypad1                 byte    $CA, $C5, $C3, $C7, $C0, 0, $C1, $C4, $C2, $C6, $C9, $0D, "+-*/"
1DFD(011C) C5          | 
1DFE(011C) C3          | 
1DFF(011C) C7          | 
1E00(011D) C0          | 
1E01(011D) 00          | 
1E02(011D) C1          | 
1E03(011D) C4          | 
1E04(011E) C2          | 
1E05(011E) C6          | 
1E06(011E) C9          | 
1E07(011E) 0D          | 
1E08(011F) 2B          | 
1E09(011F) 2D          | 
1E0A(011F) 2A          | 
1E0B(011F) 2F          | 
1E0C(0120) 30          | keypad2                 byte    "0123456789.", $0D, "+-*/"
1E0D(0120) 31          | 
1E0E(0120) 32          | 
1E0F(0120) 33          | 
1E10(0121) 34          | 
1E11(0121) 35          | 
1E12(0121) 36          | 
1E13(0121) 37          | 
1E14(0122) 38          | 
1E15(0122) 39          | 
1E16(0122) 2E          | 
1E17(0122) 0D          | 
1E18(0123) 2B          | 
1E19(0123) 2D          | 
1E1A(0123) 2A          | 
1E1B(0123) 2F          | 
1E1C(0124) 7B          | shift1                  byte    "{|}", 0, 0, "~"
1E1D(0124) 7C          | 
1E1E(0124) 7D          | 
1E1F(0124) 00          | 
1E20(0125) 00          | 
1E21(0125) 7E          | 
1E22(0125) 22          | shift2                  byte    $22, 0, 0, 0, 0, "<_>?)!@#$%^&*(", 0, ":", 0, "+"
1E23(0125) 00          | 
1E24(0126) 00          | 
1E25(0126) 00          | 
1E26(0126) 00          | 
1E27(0126) 3C          | 
1E28(0127) 5F          | 
1E29(0127) 3E          | 
1E2A(0127) 3F          | 
1E2B(0127) 29          | 
1E2C(0128) 21          | 
1E2D(0128) 40          | 
1E2E(0128) 23          | 
1E2F(0128) 24          | 
1E30(0129) 25          | 
1E31(0129) 5E          | 
1E32(0129) 26          | 
1E33(0129) 2A          | 
1E34(012A) 28          | 
1E35(012A) 00          | 
1E36(012A) 3A          | 
1E37(012A) 00          | 
1E38(012B) 2B          | 
1E39(012B)             | dmask                   res     1
1E3C(012D)             | cmask                   res     1
1E3C(012E)             | stat                    res     1
1E3C(012F)             | data                    res     1
1E3C(0130)             | x                       res     1
1E3C(0131)             | y                       res     1
1E3C(0132)             | t                       res     1
1E3C(0133)             | _head                   res     1       'write-only
1E3C(0134)             | _present                res     1       'write-only
1E3C(0135)             | _states                 res     8       'write-only
1E3C(013D)             | _dpin                   res     1       'read-only at start
1E3C(013E)             | _cpin                   res     1       'read-only at start
1E3C(013F)             | _locks                  res     1       'read-only at start
1E3C(0140)             | _auto                   res     1       'read-only at start
|===========================================================================|
|===========================================================================|
Spin Block start with 2 Parameters and 0 Extra Stack Longs. Method 1
PUB start(dpin, cpin) : okay

Local Parameter DBASE:0000 - okay
Local Parameter DBASE:0004 - dpin
Local Parameter DBASE:0008 - cpin
|===========================================================================|
40                        okay := startx(dpin, cpin, %0_000_100, %01_01000)
Addr : 1E3C:             00  : Drop Anchor Push 
Addr : 1E3D:             64  : Variable Operation Local Offset - 1 Read
Addr : 1E3E:             68  : Variable Operation Local Offset - 2 Read
Addr : 1E3F:          37 01  : Constant Mask Y=1 00000004 4
Addr : 1E41:          38 28  : Constant 1 Bytes - 28 - $00000028 40
Addr : 1E43:          05 02  : Call Sub 2    
Addr : 1E45:             61  : Variable Operation Local Offset - 0 Write
41                        nkey := dkeyhd := dkeytail := 0
Addr : 1E46:             35  : Constant 1 $00000000
Addr : 1E47:       CA 58 80  : Memory Op Long VBASE + ASSIGN Address = 0058 Write Push
Addr : 1E4A:       CA 54 80  : Memory Op Long VBASE + ASSIGN Address = 0054 Write Push
Addr : 1E4D:          C9 50  : Memory Op Long VBASE + WRITE Address = 0050
Addr : 1E4F:             32  : Return        
|===========================================================================|
Spin Block startx with 4 Parameters and 0 Extra Stack Longs. Method 2
PUB startx(dpin, cpin, locks, auto) : okay

Local Parameter DBASE:0000 - okay
Local Parameter DBASE:0004 - dpin
Local Parameter DBASE:0008 - cpin
Local Parameter DBASE:000C - locks
Local Parameter DBASE:0010 - auto
|===========================================================================|
59                        stop
Addr : 1E50:             01  : Drop Anchor   
Addr : 1E51:          05 03  : Call Sub 3    
60                        longmove(@par_keys, @dpin, 4)
Addr : 1E53:          CB 30  : Memory Op Long VBASE + ADDRESS Address = 0030
Addr : 1E55:             67  : Variable Operation Local Offset - 1 Address
Addr : 1E56:          37 01  : Constant Mask Y=1 00000004 4
Addr : 1E58:             1E  : LongMove(To, From, Count)
Addr : 1E59:             34  : Constant 0 $FFFFFFFF
61                        okay := cog := cognew(@entry, @par_tail) + 1
Addr : 1E5A:          C7 28  : Memory Op Long PBASE + ADDRESS Address = 0028
Addr : 1E5C:             47  : Variable Operation Global Offset - 1 Address
Addr : 1E5D:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 1E5E:             36  : Constant 2 $00000001
Addr : 1E5F:             EC  : Math Op +     
Addr : 1E60:          42 80  : Variable Operation Global Offset - 0 Assign Write Push
Addr : 1E62:             61  : Variable Operation Local Offset - 0 Write
Addr : 1E63:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 3
PUB stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
68                        if cog
Addr : 1E64:             40  : Variable Operation Global Offset - 0 Read
Addr : 1E65: JZ Label0002
Addr : 1E65:          0A 05  : jz Address = 1E6C 5
69                          cogstop(cog~ -  1)
Addr : 1E67:          42 98  : Variable Operation Global Offset - 0 Assign VAR~ Post-clear Push
Addr : 1E69:             36  : Constant 2 $00000001
Addr : 1E6A:             ED  : Math Op -     
Addr : 1E6B:             21  : CogStop(id)   
Addr : 1E6C: Label0002
Addr : 1E6C: Label0003
70                        longfill(@par_tail, 0, 19)
Addr : 1E6C:             47  : Variable Operation Global Offset - 1 Address
Addr : 1E6D:             35  : Constant 1 $00000000
Addr : 1E6E:          38 13  : Constant 1 Bytes - 13 - $00000013 19
Addr : 1E70:             1A  : LongFill(Start, Value, Count)
Addr : 1E71:             32  : Return        
|===========================================================================|
Spin Block key with 0 Parameters and 0 Extra Stack Longs. Method 4
PUB key : keycode

Local Parameter DBASE:0000 - keycode
|===========================================================================|
93                        if par_tail <> par_head
Addr : 1E72:             44  : Variable Operation Global Offset - 1 Read
Addr : 1E73:             48  : Variable Operation Global Offset - 2 Read
Addr : 1E74:             FB  : Math Op <>    
Addr : 1E75: JZ Label0002
Addr : 1E75:          0A 0A  : jz Address = 1E81 10
94                          keycode := par_keys.word[par_tail]
Addr : 1E77:             44  : Variable Operation Global Offset - 1 Read
Addr : 1E78:          B8 30  : Memory Op Word VBASE + POP Index READ Address = 0030
Addr : 1E7A:             61  : Variable Operation Local Offset - 0 Write
95                          par_tail := ++par_tail & $F
Addr : 1E7B:          46 A6  : Variable Operation Global Offset - 1 Assign ++VAR pre-inc Long Push
Addr : 1E7D:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 1E7F:             E8  : Math Op &     
Addr : 1E80:             45  : Variable Operation Global Offset - 1 Write
Addr : 1E81: Label0002
Addr : 1E81: Label0003
Addr : 1E81:             32  : Return        
|===========================================================================|
Spin Block getkey with 0 Parameters and 1 Extra Stack Longs. Method 5
PUB getkey : keycode | temp

Local Parameter DBASE:0000 - keycode
Local Variable  DBASE:0004 - temp
|===========================================================================|
158                        temp := key
Addr : 1E82:             00  : Drop Anchor Push 
Addr : 1E83:          05 04  : Call Sub 4    
Addr : 1E85:             65  : Variable Operation Local Offset - 1 Write
160                        if temp > 0
Addr : 1E86:             64  : Variable Operation Local Offset - 1 Read
Addr : 1E87:             35  : Constant 1 $00000000
Addr : 1E88:             FA  : Math Op >     
Addr : 1E89: JZ Label0002
Addr : 1E89:          0A 04  : jz Address = 1E8F 4
161                          decode_key(temp)
Addr : 1E8B:             01  : Drop Anchor   
Addr : 1E8C:             64  : Variable Operation Local Offset - 1 Read
Addr : 1E8D:          05 09  : Call Sub 9    
Addr : 1E8F: Label0002
Addr : 1E8F: Label0003
163                        keycode := 0
Addr : 1E8F:             35  : Constant 1 $00000000
Addr : 1E90:             61  : Variable Operation Local Offset - 0 Write
164                        if nkey
Addr : 1E91:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 1E93: JZ Label0004
Addr : 1E93:          0A 14  : jz Address = 1EA9 20
165                          nkey -= 1
Addr : 1E95:             36  : Constant 2 $00000001
Addr : 1E96:       CA 50 4D  : Memory Op Long VBASE + ASSIGN Address = 0050 WordMathop -
166                          keycode := dkeys[dkeytail]
Addr : 1E99:          C8 58  : Memory Op Long VBASE + READ Address = 0058
Addr : 1E9B:          98 5C  : Memory Op Byte VBASE + POP Index READ Address = 005C
Addr : 1E9D:             61  : Variable Operation Local Offset - 0 Write
167                          dkeys[dkeytail++] := 0
Addr : 1E9E:             35  : Constant 1 $00000000
Addr : 1E9F:       CA 58 AE  : Memory Op Long VBASE + ASSIGN Address = 0058 VAR++ post inc Long Push
Addr : 1EA2:          99 5C  : Memory Op Byte VBASE + POP Index WRITE Address = 005C
168                          dkeytail &= $F
Addr : 1EA4:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 1EA6:       CA 58 48  : Memory Op Long VBASE + ASSIGN Address = 0058 BitMathop &
Addr : 1EA9: Label0004
Addr : 1EA9: Label0005
Addr : 1EA9:             32  : Return        
|===========================================================================|
Spin Block gotkey with 0 Parameters and 0 Extra Stack Longs. Method 6
PUB gotkey : truefalse

Local Parameter DBASE:0000 - truefalse
|===========================================================================|
186                         return nkey OR (par_tail <> par_head)
Addr : 1EAA:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 1EAC:             44  : Variable Operation Global Offset - 1 Read
Addr : 1EAD:             48  : Variable Operation Global Offset - 2 Read
Addr : 1EAE:             FB  : Math Op <>    
Addr : 1EAF:             F2  : Math Op OR    
Addr : 1EB0:             33  : Return value  
Addr : 1EB1: Data : 32                       2
|===========================================================================|
Spin Block enqueue with 1 Parameters and 0 Extra Stack Longs. Method 7
PRI enqueue(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
82                        if nkey == 16
Addr : 1EB2:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 1EB4:          37 03  : Constant Mask Y=3 00000010 16
Addr : 1EB6:             FC  : Math Op ==    
Addr : 1EB7: JZ Label0002
Addr : 1EB7:          0A 01  : jz Address = 1EBA 1
Addr : 1EB9:             32  : Return        
Addr : 1EBA: Label0002
Addr : 1EBA: Label0003
84                        dkeys[dkeyhd++] := c
Addr : 1EBA:             64  : Variable Operation Local Offset - 1 Read
Addr : 1EBB:       CA 54 AE  : Memory Op Long VBASE + ASSIGN Address = 0054 VAR++ post inc Long Push
Addr : 1EBE:          99 5C  : Memory Op Byte VBASE + POP Index WRITE Address = 005C
85                        nkey += 1
Addr : 1EC0:             36  : Constant 2 $00000001
Addr : 1EC1:       CA 50 4C  : Memory Op Long VBASE + ASSIGN Address = 0050 WordMathop +
86                        dkeyhd &=$F
Addr : 1EC4:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 1EC6:       CA 54 48  : Memory Op Long VBASE + ASSIGN Address = 0054 BitMathop &
Addr : 1EC9:             32  : Return        
|===========================================================================|
Spin Block escstr with 1 Parameters and 1 Extra Stack Longs. Method 8
PRI escstr(s) | xx

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - s
Local Variable  DBASE:0008 - xx
|===========================================================================|
98                        enqueue($1B)
Addr : 1ECA:             01  : Drop Anchor   
Addr : 1ECB:          38 1B  : Constant 1 Bytes - 1B - $0000001B 27
Addr : 1ECD:          05 07  : Call Sub 7    
99                        repeat xx from 0 to STRSIZE(s) - 1
Addr : 1ECF:             35  : Constant 1 $00000000
Addr : 1ED0:             69  : Variable Operation Local Offset - 2 Write
Addr : 1ED1: Label0002
100                          enqueue(BYTE[s][xx])
Addr : 1ED1:             01  : Drop Anchor   
Addr : 1ED2:             64  : Variable Operation Local Offset - 1 Read
Addr : 1ED3:             68  : Variable Operation Local Offset - 2 Read
Addr : 1ED4:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 1ED5:          05 07  : Call Sub 7    
Addr : 1ED7: Label0003
99                        repeat xx from 0 to STRSIZE(s) - 1
Addr : 1ED7:             35  : Constant 1 $00000000
Addr : 1ED8:             64  : Variable Operation Local Offset - 1 Read
Addr : 1ED9:             16  : StrSize(String)
Addr : 1EDA:             36  : Constant 2 $00000001
Addr : 1EDB:             ED  : Math Op -     
Addr : 1EDC: Repeat xx Step Label0002
Addr : 1EDC:       6A 02 72  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 1ED1 -14
Addr : 1EDF: Label0004
Addr : 1EDF:             32  : Return        
|===========================================================================|
Spin Block decode_key with 1 Parameters and 1 Extra Stack Longs. Method 9
PRI decode_key(scode)   | s

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - scode
Local Variable  DBASE:0008 - s
|===========================================================================|
Addr : 1EE0: Constant Address of Label0002
Addr : 1EE0:       39 06 0D  : Constant 2 Bytes - 06 0D - $0000060D 1549
# Source File : lib/Keyboard.spin
104                        case scode
Addr : 1EE3:             64  : Variable Operation Local Offset - 1 Read
106                          $C0:    'left cursor
Addr : 1EE4:          38 C0  : Constant 1 Bytes - C0 - $000000C0 192
Addr : 1EE6: Case_Value Label0003
Addr : 1EE6:       0D 80 56  : Value Case Address = 1F3F 86
109                          $C1:    'right cursor
Addr : 1EE9:          38 C1  : Constant 1 Bytes - C1 - $000000C1 193
Addr : 1EEB: Case_Value Label0005
Addr : 1EEB:       0D 80 56  : Value Case Address = 1F44 86
112                          $C2:    'UP                   
Addr : 1EEE:          38 C2  : Constant 1 Bytes - C2 - $000000C2 194
Addr : 1EF0: Case_Value Label0007
Addr : 1EF0:       0D 80 56  : Value Case Address = 1F49 86
115                          $C3:    'DOWN
Addr : 1EF3:          38 C3  : Constant 1 Bytes - C3 - $000000C3 195
Addr : 1EF5: Case_Value Label0009
Addr : 1EF5:       0D 80 56  : Value Case Address = 1F4E 86
118                          $C4:    'Home
Addr : 1EF8:          38 C4  : Constant 1 Bytes - C4 - $000000C4 196
Addr : 1EFA: Case_Value Label000B
Addr : 1EFA:       0D 80 56  : Value Case Address = 1F53 86
121                          $C5:    'End
Addr : 1EFD:          38 C5  : Constant 1 Bytes - C5 - $000000C5 197
Addr : 1EFF: Case_Value Label000D
Addr : 1EFF:       0D 80 56  : Value Case Address = 1F58 86
124                          $C6:    'Page Up
Addr : 1F02:          38 C6  : Constant 1 Bytes - C6 - $000000C6 198
Addr : 1F04: Case_Value Label000F
Addr : 1F04:       0D 80 56  : Value Case Address = 1F5D 86
127                          $C7:    'Page Dn
Addr : 1F07:          38 C7  : Constant 1 Bytes - C7 - $000000C7 199
Addr : 1F09: Case_Value Label0011
Addr : 1F09:       0D 80 56  : Value Case Address = 1F62 86
130                          $C9:    'Delete    
Addr : 1F0C:          38 C9  : Constant 1 Bytes - C9 - $000000C9 201
Addr : 1F0E: Case_Value Label0013
Addr : 1F0E:       0D 80 56  : Value Case Address = 1F67 86
133                          $CA:    'Insert
Addr : 1F11:          38 CA  : Constant 1 Bytes - CA - $000000CA 202
Addr : 1F13: Case_Value Label0015
Addr : 1F13:       0D 80 56  : Value Case Address = 1F6C 86
138                            if scode == $CB
Addr : 1F16:             64  : Variable Operation Local Offset - 1 Read
Addr : 1F17:          38 CB  : Constant 1 Bytes - CB - $000000CB 203
Addr : 1F19:             FC  : Math Op ==    
Addr : 1F1A: JZ Label0017
Addr : 1F1A:          0A 03  : jz Address = 1F1F 3
139                              scode := $1B
Addr : 1F1C:          38 1B  : Constant 1 Bytes - 1B - $0000001B 27
Addr : 1F1E:             65  : Variable Operation Local Offset - 1 Write
Addr : 1F1F: Label0017
Addr : 1F1F: Label0018
140                            if scode == $C8
Addr : 1F1F:             64  : Variable Operation Local Offset - 1 Read
Addr : 1F20:          38 C8  : Constant 1 Bytes - C8 - $000000C8 200
Addr : 1F22:             FC  : Math Op ==    
Addr : 1F23: JZ Label0019
Addr : 1F23:          0A 03  : jz Address = 1F28 3
141                              scode := $08
Addr : 1F25:          37 02  : Constant Mask Y=2 00000008 8
Addr : 1F27:             65  : Variable Operation Local Offset - 1 Write
Addr : 1F28: Label0019
Addr : 1F28: Label001A
143                            if (scode > $260) AND (scode < $27B)
Addr : 1F28:             64  : Variable Operation Local Offset - 1 Read
Addr : 1F29:       39 02 60  : Constant 2 Bytes - 02 60 - $00000260 608
Addr : 1F2C:             FA  : Math Op >     
Addr : 1F2D:             64  : Variable Operation Local Offset - 1 Read
Addr : 1F2E:       39 02 7B  : Constant 2 Bytes - 02 7B - $0000027B 635
Addr : 1F31:             F9  : Math Op <     
Addr : 1F32:             F0  : Math Op AND   
Addr : 1F33: JZ Label001B
Addr : 1F33:          0A 04  : jz Address = 1F39 4
144                              scode &= $1F
Addr : 1F35:          37 24  : Constant Mask Y=36 Decrement 0000001F 31
Addr : 1F37:          66 48  : Variable Operation Local Offset - 1 Assign BitMathop &
Addr : 1F39: Label001B
Addr : 1F39: Label001C
146                            enqueue(scode)
Addr : 1F39:             01  : Drop Anchor   
Addr : 1F3A:             64  : Variable Operation Local Offset - 1 Read
Addr : 1F3B:          05 07  : Call Sub 7    
Addr : 1F3D:             32  : Return        
Addr : 1F3E: CaseDone Label0015
Addr : 1F3E:             0C  : Casedone      
Addr : 1F3F: Label0003
Addr : 1F3F: PBASE Constant Address of Label0004
Addr : 1F3F:       87 86 12  : Memory Op Byte PBASE + ADDRESS Address = 0612
107                            s := string("OD")
Addr : 1F42:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F43: CaseDone Label0003
Addr : 1F43:             0C  : Casedone      
Addr : 1F44: Label0005
Addr : 1F44: PBASE Constant Address of Label0006
Addr : 1F44:       87 86 15  : Memory Op Byte PBASE + ADDRESS Address = 0615
110                            s := string("OC")
Addr : 1F47:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F48: CaseDone Label0005
Addr : 1F48:             0C  : Casedone      
Addr : 1F49: Label0007
Addr : 1F49: PBASE Constant Address of Label0008
Addr : 1F49:       87 86 18  : Memory Op Byte PBASE + ADDRESS Address = 0618
113                            s := string("OA")
Addr : 1F4C:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F4D: CaseDone Label0007
Addr : 1F4D:             0C  : Casedone      
Addr : 1F4E: Label0009
Addr : 1F4E: PBASE Constant Address of Label000A
Addr : 1F4E:       87 86 1B  : Memory Op Byte PBASE + ADDRESS Address = 061B
116                            s := string("OB")
Addr : 1F51:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F52: CaseDone Label0009
Addr : 1F52:             0C  : Casedone      
Addr : 1F53: Label000B
Addr : 1F53: PBASE Constant Address of Label000C
Addr : 1F53:       87 86 1E  : Memory Op Byte PBASE + ADDRESS Address = 061E
119                            s := string("OH")
Addr : 1F56:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F57: CaseDone Label000B
Addr : 1F57:             0C  : Casedone      
Addr : 1F58: Label000D
Addr : 1F58: PBASE Constant Address of Label000E
Addr : 1F58:       87 86 21  : Memory Op Byte PBASE + ADDRESS Address = 0621
122                            s := string("OF")
Addr : 1F5B:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F5C: CaseDone Label000D
Addr : 1F5C:             0C  : Casedone      
Addr : 1F5D: Label000F
Addr : 1F5D: PBASE Constant Address of Label0010
Addr : 1F5D:       87 86 24  : Memory Op Byte PBASE + ADDRESS Address = 0624
125                            s := string("[5~")
Addr : 1F60:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F61: CaseDone Label000F
Addr : 1F61:             0C  : Casedone      
Addr : 1F62: Label0011
Addr : 1F62: PBASE Constant Address of Label0012
Addr : 1F62:       87 86 28  : Memory Op Byte PBASE + ADDRESS Address = 0628
128                            s := string("[6~")
Addr : 1F65:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F66: CaseDone Label0011
Addr : 1F66:             0C  : Casedone      
Addr : 1F67: Label0013
Addr : 1F67: PBASE Constant Address of Label0014
Addr : 1F67:       87 86 2C  : Memory Op Byte PBASE + ADDRESS Address = 062C
131                            s := string("[3~")
Addr : 1F6A:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F6B: CaseDone Label0013
Addr : 1F6B:             0C  : Casedone      
Addr : 1F6C: Label0015
Addr : 1F6C: PBASE Constant Address of Label0016
Addr : 1F6C:       87 86 30  : Memory Op Byte PBASE + ADDRESS Address = 0630
134                            s := string("[2~")
Addr : 1F6F:             69  : Variable Operation Local Offset - 2 Write
Addr : 1F70: CaseDone Label0015
Addr : 1F70:             0C  : Casedone      
Addr : 1F71: Label0002
149                        escstr(s)
Addr : 1F71:             01  : Drop Anchor   
Addr : 1F72:             68  : Variable Operation Local Offset - 2 Read
Addr : 1F73:          05 08  : Call Sub 8    
Addr : 1F75:             32  : Return        
Addr : 1F76: Label0004
Addr : 1F76: Data : 4F 44 00                 OD.
Addr : 1F79: Label0006
Addr : 1F79: Data : 4F 43 00                 OC.
Addr : 1F7C: Label0008
Addr : 1F7C: Data : 4F 41 00                 OA.
Addr : 1F7F: Label000A
Addr : 1F7F: Data : 4F 42 00                 OB.
Addr : 1F82: Label000C
Addr : 1F82: Data : 4F 48 00                 OH.
Addr : 1F85: Label000E
Addr : 1F85: Data : 4F 46 00                 OF.
Addr : 1F88: Label0010
Addr : 1F88: Data : 5B 35 7E 00              [5~.
Addr : 1F8C: Label0012
Addr : 1F8C: Data : 5B 36 7E 00              [6~.
Addr : 1F90: Label0014
Addr : 1F90: Data : 5B 33 7E 00              [3~.
Addr : 1F94: Label0016
Addr : 1F94: Data : 5B 32 7E 00              [2~.
|===========================================================================|
Object fsrw
Object Base is 1F98
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable fclust
VBASE : 0004 LONG Size 0004 Variable filesize
VBASE : 0008 LONG Size 0004 Variable floc
VBASE : 000C LONG Size 0004 Variable frem
VBASE : 0010 LONG Size 0004 Variable bufat
VBASE : 0014 LONG Size 0004 Variable bufend
VBASE : 0018 LONG Size 0004 Variable direntry
VBASE : 001C LONG Size 0004 Variable writelink
VBASE : 0020 LONG Size 0004 Variable fatptr
VBASE : 0024 LONG Size 0004 Variable firstcluster
VBASE : 0028 BYTE Size 0200 Variable buf
|===========================================================================|
Object DAT Blocks
|===========================================================================|
2008(0000) 00 00 00 00 | filesystem  long 0 ' 0 = unmounted, 1 = fat16, 2 = fat32
200C(0001) 00 00 00 00 | rootdir  long 0 ' the byte address of the start of the root directory
2010(0002) 00 00 00 00 | rootdirend  long 0 ' the byte immediately following the root directory.
2014(0003) 00 00 00 00 | dataregion  long 0 ' the start of the data region, offset by two sectors
2018(0004) 00 00 00 00 | clustershift  long 0 ' log base 2 of blocks per cluster
201C(0005) 00 00 00 00 | clustersize  long 0 ' total size of cluster in bytes
2020(0006) 00 00 00 00 | fat1  long 0 ' the block address of the fat1 space
2024(0007) 00 00 00 00 | totclusters  long 0 ' how many clusters in the volume
2028(0008) 00 00 00 00 | sectorsperfat  long 0 ' how many sectors per fat
202C(0009) 00 00 00 00 | endofchain  long 0 ' end of chain marker (with a 0 at the end)
2030(000A) 00 00 00 00 | pdate  long 0 ' current date
2034(000B) 00 00 00 00 | lastread  long 0 ' the block address of the buf2 contents
2038(000C) 00 00 00 00 | dirty  long 0 ' nonzero if buf2 is dirty
203C(000D) 00          | buf2 byte 0[SECTORSIZE]  ' main metadata buffer
223C(008D) 00          | padname byte 0[11]  ' filename buffer
|===========================================================================|
|===========================================================================|
Spin Block readSDCard with 3 Parameters and 0 Extra Stack Longs. Method 1
pub readSDCard(address, bufAdr, size)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - address
Local Parameter DBASE:0008 - bufAdr
Local Parameter DBASE:000C - size
|===========================================================================|
80                        return sdspi.readblock(address, bufAdr)               '512!
Addr : 2247:             00  : Drop Anchor Push 
Addr : 2248:             64  : Variable Operation Local Offset - 1 Read
Addr : 2249:             68  : Variable Operation Local Offset - 2 Read
Addr : 224A:       06 1B 01  : Call Obj.Sub 27 1
Addr : 224D:             33  : Return value  
Addr : 224E: Data : 32                       2
|===========================================================================|
Spin Block writeSDCard with 3 Parameters and 0 Extra Stack Longs. Method 2
pub writeSDCard(address, bufAdr, size)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - address
Local Parameter DBASE:0008 - bufAdr
Local Parameter DBASE:000C - size
|===========================================================================|
83                        return sdspi.writeblock(address, bufAdr)              '512!
Addr : 224F:             00  : Drop Anchor Push 
Addr : 2250:             64  : Variable Operation Local Offset - 1 Read
Addr : 2251:             68  : Variable Operation Local Offset - 2 Read
Addr : 2252:       06 1B 02  : Call Obj.Sub 27 2
Addr : 2255:             33  : Return value  
Addr : 2256: Data : 32                       2
|===========================================================================|
Spin Block getSDdatablock with 0 Parameters and 0 Extra Stack Longs. Method 3
pub getSDdatablock

Local Parameter DBASE:0000 - Result
|===========================================================================|
86                        return datablock
Addr : 2257:             00  : Drop Anchor Push 
Addr : 2258:          05 18  : Call Sub 24   
Addr : 225A:             33  : Return value  
Addr : 225B: Data : 32                       2
|===========================================================================|
Spin Block unmount with 0 Parameters and 0 Extra Stack Longs. Method 4
pub unmount

Local Parameter DBASE:0000 - Result
|===========================================================================|
166                        pclose
Addr : 225C:             01  : Drop Anchor   
Addr : 225D:          05 07  : Call Sub 7    
167                        sdspi.stop
Addr : 225F:             01  : Drop Anchor   
Addr : 2260:       06 1B 05  : Call Obj.Sub 27 5
Addr : 2263:             32  : Return        
|===========================================================================|
Spin Block mount_explicit with 4 Parameters and 5 Extra Stack Longs. Method 5
pub mount_explicit(DO, CLK, DI, CS) : r | start, sectorspercluster, reserved, rootentries, sectors

Local Parameter DBASE:0000 - r
Local Parameter DBASE:0004 - DO
Local Parameter DBASE:0008 - CLK
Local Parameter DBASE:000C - DI
Local Parameter DBASE:0010 - CS
Local Variable  DBASE:0014 - start
Local Variable  DBASE:0018 - sectorspercluster
Local Variable  DBASE:001C - reserved
Local Variable  DBASE:0020 - rootentries
Local Variable  DBASE:0024 - sectors
|===========================================================================|
180                         if (pdate == 0)
Addr : 2264:       C4 80 98  : Memory Op Long PBASE + READ Address = 0098
Addr : 2267:             35  : Constant 1 $00000000
Addr : 2268:             FC  : Math Op ==    
Addr : 2269: JZ Label0003
Addr : 2269:          0A 08  : jz Address = 2273 8
Addr : 226B: 3B 3A 3B 38 00  : Constant 4 Bytes - 3A 3B 38 00 - $3A3B3800 976959488
181                            pdate := constant(((2009-1980) << 25) + (1 << 21) + (27 << 16) + (7 << 11))
Addr : 2270:       C5 80 98  : Memory Op Long PBASE + WRITE Address = 0098
Addr : 2273: Label0003
Addr : 2273: Label0004
182                         unmount
Addr : 2273:             01  : Drop Anchor   
Addr : 2274:          05 04  : Call Sub 4    
183                         sdspi.start_explicit(DO, CLK, DI, CS)
Addr : 2276:             01  : Drop Anchor   
Addr : 2277:             64  : Variable Operation Local Offset - 1 Read
Addr : 2278:             68  : Variable Operation Local Offset - 2 Read
Addr : 2279:             6C  : Variable Operation Local Offset - 3 Read
Addr : 227A:             70  : Variable Operation Local Offset - 4 Read
Addr : 227B:       06 1B 03  : Call Obj.Sub 27 3
184                         lastread := -1
Addr : 227E:             34  : Constant 0 $FFFFFFFF
Addr : 227F:       C5 80 9C  : Memory Op Long PBASE + WRITE Address = 009C
185                         dirty := 0
Addr : 2282:             35  : Constant 1 $00000000
Addr : 2283:       C5 80 A0  : Memory Op Long PBASE + WRITE Address = 00A0
186                         sdspi.readblock(0, @buf)
Addr : 2286:             01  : Drop Anchor   
Addr : 2287:             35  : Constant 1 $00000000
Addr : 2288:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 228A:       06 1B 01  : Call Obj.Sub 27 1
187                         if (getfstype > 0)
Addr : 228D:             00  : Drop Anchor Push 
Addr : 228E:          05 12  : Call Sub 18   
Addr : 2290:             35  : Constant 1 $00000000
Addr : 2291:             FA  : Math Op >     
Addr : 2292: JZ Label0005
Addr : 2292:          0A 04  : jz Address = 2298 4
188                           start := 0
Addr : 2294:             35  : Constant 1 $00000000
Addr : 2295:             75  : Variable Operation Local Offset - 5 Write
Addr : 2296: JMP Label0006
Addr : 2296:          04 11  : Jmp 22A9 17   
Addr : 2298: Label0005
190                           start := brlong(@buf+$1c6)
Addr : 2298:             00  : Drop Anchor Push 
Addr : 2299:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 229B:       39 01 C6  : Constant 2 Bytes - 01 C6 - $000001C6 454
Addr : 229E:             EC  : Math Op +     
Addr : 229F:          05 0D  : Call Sub 13   
Addr : 22A1:             75  : Variable Operation Local Offset - 5 Write
191                           sdspi.readblock(start, @buf)
Addr : 22A2:             01  : Drop Anchor   
Addr : 22A3:             74  : Variable Operation Local Offset - 5 Read
Addr : 22A4:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 22A6:       06 1B 01  : Call Obj.Sub 27 1
Addr : 22A9: Label0007
Addr : 22A9: Label0006
192                         filesystem := getfstype
Addr : 22A9:             00  : Drop Anchor Push 
Addr : 22AA:          05 12  : Call Sub 18   
Addr : 22AC:          C5 70  : Memory Op Long PBASE + WRITE Address = 0070
193                         if (filesystem == 0)
Addr : 22AE:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 22B0:             35  : Constant 1 $00000000
Addr : 22B1:             FC  : Math Op ==    
Addr : 22B2: JZ Label0008
Addr : 22B2:          0A 04  : jz Address = 22B8 4
194                            abort(-20) ' not a fat16 or fat32 volume
Addr : 22B4:          38 13  : Constant 1 Bytes - 13 - $00000013 19
Addr : 22B6:             E7  : Math Op !     
Addr : 22B7:             31  : Abort value   
Addr : 22B8: Label0008
Addr : 22B8: Label0009
195                         if (brword(@buf+$0b) <> SECTORSIZE)
Addr : 22B8:             00  : Drop Anchor Push 
Addr : 22B9:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 22BB:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 22BD:             EC  : Math Op +     
Addr : 22BE:          05 0C  : Call Sub 12   
Addr : 22C0:          37 08  : Constant Mask Y=8 00000200 512
Addr : 22C2:             FB  : Math Op <>    
Addr : 22C3: JZ Label000A
Addr : 22C3:          0A 04  : jz Address = 22C9 4
196                            abort(-21) ' bad bytes per sector
Addr : 22C5:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 22C7:             E7  : Math Op !     
Addr : 22C8:             31  : Abort value   
Addr : 22C9: Label000A
Addr : 22C9: Label000B
197                         sectorspercluster := buf[$0d]
Addr : 22C9:          38 0D  : Constant 1 Bytes - 0D - $0000000D 13
Addr : 22CB:          98 28  : Memory Op Byte VBASE + POP Index READ Address = 0028
Addr : 22CD:             79  : Variable Operation Local Offset - 6 Write
198                         if (sectorspercluster & (sectorspercluster - 1))
Addr : 22CE:             78  : Variable Operation Local Offset - 6 Read
Addr : 22CF:             78  : Variable Operation Local Offset - 6 Read
Addr : 22D0:             36  : Constant 2 $00000001
Addr : 22D1:             ED  : Math Op -     
Addr : 22D2:             E8  : Math Op &     
Addr : 22D3: JZ Label000C
Addr : 22D3:          0A 04  : jz Address = 22D9 4
199                            abort(-22) ' bad sectors per cluster
Addr : 22D5:          38 15  : Constant 1 Bytes - 15 - $00000015 21
Addr : 22D7:             E7  : Math Op !     
Addr : 22D8:             31  : Abort value   
Addr : 22D9: Label000C
Addr : 22D9: Label000D
200                         clustershift := 0
Addr : 22D9:             35  : Constant 1 $00000000
Addr : 22DA:       C5 80 80  : Memory Op Long PBASE + WRITE Address = 0080
Addr : 22DD: Label000E
201                         repeat while (sectorspercluster > 1)
Addr : 22DD:             78  : Variable Operation Local Offset - 6 Read
Addr : 22DE:             36  : Constant 2 $00000001
Addr : 22DF:             FA  : Math Op >     
Addr : 22E0: JZ Label0010
Addr : 22E0:          0A 09  : jz Address = 22EB 9
202                            clustershift++
Addr : 22E2:    C6 80 80 2E  : Memory Op Long PBASE + ASSIGN Address = 0080 VAR++ post inc Long
203                            sectorspercluster >>= 1
Addr : 22E6:             36  : Constant 2 $00000001
Addr : 22E7:          7A 42  : Variable Operation Local Offset - 6 Assign ByteMathop >>
Addr : 22E9: Label000F
Addr : 22E9: JMP Label000E
Addr : 22E9:          04 72  : Jmp 22DD -14  
Addr : 22EB: Label0010
204                         sectorspercluster := 1 << clustershift
Addr : 22EB:             36  : Constant 2 $00000001
Addr : 22EC:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 22EF:             E3  : Math Op <<    
Addr : 22F0:             79  : Variable Operation Local Offset - 6 Write
Addr : 22F1:          37 08  : Constant Mask Y=8 00000200 512
205                         clustersize := SECTORSIZE << clustershift
Addr : 22F3:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 22F6:             E3  : Math Op <<    
Addr : 22F7:       C5 80 84  : Memory Op Long PBASE + WRITE Address = 0084
206                         reserved := brword(@buf+$0e)
Addr : 22FA:             00  : Drop Anchor Push 
Addr : 22FB:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 22FD:          38 0E  : Constant 1 Bytes - 0E - $0000000E 14
Addr : 22FF:             EC  : Math Op +     
Addr : 2300:          05 0C  : Call Sub 12   
Addr : 2302:             7D  : Variable Operation Local Offset - 7 Write
207                         if (buf[$10] <> 2)
Addr : 2303:          37 03  : Constant Mask Y=3 00000010 16
Addr : 2305:          98 28  : Memory Op Byte VBASE + POP Index READ Address = 0028
Addr : 2307:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2309:             FB  : Math Op <>    
Addr : 230A: JZ Label0011
Addr : 230A:          0A 04  : jz Address = 2310 4
208                            abort(-23) ' not two FATs
Addr : 230C:          38 16  : Constant 1 Bytes - 16 - $00000016 22
Addr : 230E:             E7  : Math Op !     
Addr : 230F:             31  : Abort value   
Addr : 2310: Label0011
Addr : 2310: Label0012
209                         sectors := brword(@buf+$13)
Addr : 2310:             00  : Drop Anchor Push 
Addr : 2311:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2313:          38 13  : Constant 1 Bytes - 13 - $00000013 19
Addr : 2315:             EC  : Math Op +     
Addr : 2316:          05 0C  : Call Sub 12   
Addr : 2318:          CD 24  : Memory Op Long DBASE + WRITE Address = 0024
210                         if (sectors == 0)
Addr : 231A:          CC 24  : Memory Op Long DBASE + READ Address = 0024
Addr : 231C:             35  : Constant 1 $00000000
Addr : 231D:             FC  : Math Op ==    
Addr : 231E: JZ Label0013
Addr : 231E:          0A 0A  : jz Address = 232A 10
211                           sectors := brlong(@buf+$20)
Addr : 2320:             00  : Drop Anchor Push 
Addr : 2321:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2323:          37 04  : Constant Mask Y=4 00000020 32
Addr : 2325:             EC  : Math Op +     
Addr : 2326:          05 0D  : Call Sub 13   
Addr : 2328:          CD 24  : Memory Op Long DBASE + WRITE Address = 0024
Addr : 232A: Label0013
Addr : 232A: Label0014
212                         fat1 := start + reserved
Addr : 232A:             74  : Variable Operation Local Offset - 5 Read
Addr : 232B:             7C  : Variable Operation Local Offset - 7 Read
Addr : 232C:             EC  : Math Op +     
Addr : 232D:       C5 80 88  : Memory Op Long PBASE + WRITE Address = 0088
213                         if (filesystem == 2)
Addr : 2330:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2332:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2334:             FC  : Math Op ==    
Addr : 2335: JZ Label0015
Addr : 2335:       0A 80 4D  : jz Address = 2385 77
214                            rootentries := 16 << clustershift
Addr : 2338:          37 03  : Constant Mask Y=3 00000010 16
Addr : 233A:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 233D:             E3  : Math Op <<    
Addr : 233E:          CD 20  : Memory Op Long DBASE + WRITE Address = 0020
215                            sectorsperfat := brlong(@buf+$24)
Addr : 2340:             00  : Drop Anchor Push 
Addr : 2341:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2343:          38 24  : Constant 1 Bytes - 24 - $00000024 36
Addr : 2345:             EC  : Math Op +     
Addr : 2346:          05 0D  : Call Sub 13   
Addr : 2348:       C5 80 90  : Memory Op Long PBASE + WRITE Address = 0090
216                            dataregion := (fat1 + 2 * sectorsperfat) - 2 * sectorspercluster
Addr : 234B:       C4 80 88  : Memory Op Long PBASE + READ Address = 0088
Addr : 234E:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2350:       C4 80 90  : Memory Op Long PBASE + READ Address = 0090
Addr : 2353:             F4  : Math Op *     
Addr : 2354:             EC  : Math Op +     
Addr : 2355:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2357:             78  : Variable Operation Local Offset - 6 Read
Addr : 2358:             F4  : Math Op *     
Addr : 2359:             ED  : Math Op -     
Addr : 235A:          C5 7C  : Memory Op Long PBASE + WRITE Address = 007C
217                            rootdir := (dataregion + (brword(@buf+$2c) << clustershift)) << SECTORSHIFT
Addr : 235C:          C4 7C  : Memory Op Long PBASE + READ Address = 007C
Addr : 235E:             00  : Drop Anchor Push 
Addr : 235F:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2361:          38 2C  : Constant 1 Bytes - 2C - $0000002C 44
Addr : 2363:             EC  : Math Op +     
Addr : 2364:          05 0C  : Call Sub 12   
Addr : 2366:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 2369:             E3  : Math Op <<    
Addr : 236A:             EC  : Math Op +     
Addr : 236B:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 236D:             E3  : Math Op <<    
Addr : 236E:          C5 74  : Memory Op Long PBASE + WRITE Address = 0074
218                            rootdirend := rootdir + (rootentries << DIRSHIFT)
Addr : 2370:          C4 74  : Memory Op Long PBASE + READ Address = 0074
Addr : 2372:          CC 20  : Memory Op Long DBASE + READ Address = 0020
Addr : 2374:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 2376:             E3  : Math Op <<    
Addr : 2377:             EC  : Math Op +     
Addr : 2378:          C5 78  : Memory Op Long PBASE + WRITE Address = 0078
219                            endofchain := $ffffff0
Addr : 237A: 3B 0F FF FF F0  : Constant 4 Bytes - 0F FF FF F0 - $0FFFFFF0 268435440
Addr : 237F:       C5 80 94  : Memory Op Long PBASE + WRITE Address = 0094
Addr : 2382: JMP Label0016
Addr : 2382:       04 80 44  : Jmp 23C9 68   
Addr : 2385: Label0015
221                            rootentries := brword(@buf+$11)
Addr : 2385:             00  : Drop Anchor Push 
Addr : 2386:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2388:          38 11  : Constant 1 Bytes - 11 - $00000011 17
Addr : 238A:             EC  : Math Op +     
Addr : 238B:          05 0C  : Call Sub 12   
Addr : 238D:          CD 20  : Memory Op Long DBASE + WRITE Address = 0020
222                            sectorsperfat := brword(@buf+$16)
Addr : 238F:             00  : Drop Anchor Push 
Addr : 2390:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2392:          38 16  : Constant 1 Bytes - 16 - $00000016 22
Addr : 2394:             EC  : Math Op +     
Addr : 2395:          05 0C  : Call Sub 12   
Addr : 2397:       C5 80 90  : Memory Op Long PBASE + WRITE Address = 0090
223                            rootdir := (fat1 + 2 * sectorsperfat) << SECTORSHIFT
Addr : 239A:       C4 80 88  : Memory Op Long PBASE + READ Address = 0088
Addr : 239D:          37 00  : Constant Mask Y=0 00000002 2
Addr : 239F:       C4 80 90  : Memory Op Long PBASE + READ Address = 0090
Addr : 23A2:             F4  : Math Op *     
Addr : 23A3:             EC  : Math Op +     
Addr : 23A4:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 23A6:             E3  : Math Op <<    
Addr : 23A7:          C5 74  : Memory Op Long PBASE + WRITE Address = 0074
224                            rootdirend := rootdir + (rootentries << DIRSHIFT)
Addr : 23A9:          C4 74  : Memory Op Long PBASE + READ Address = 0074
Addr : 23AB:          CC 20  : Memory Op Long DBASE + READ Address = 0020
Addr : 23AD:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 23AF:             E3  : Math Op <<    
Addr : 23B0:             EC  : Math Op +     
Addr : 23B1:          C5 78  : Memory Op Long PBASE + WRITE Address = 0078
225                            dataregion := 1 + ((rootdirend - 1) >> SECTORSHIFT) - 2 * sectorspercluster
Addr : 23B3:             36  : Constant 2 $00000001
Addr : 23B4:          C4 78  : Memory Op Long PBASE + READ Address = 0078
Addr : 23B6:             36  : Constant 2 $00000001
Addr : 23B7:             ED  : Math Op -     
Addr : 23B8:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 23BA:             E2  : Math Op >>    
Addr : 23BB:             EC  : Math Op +     
Addr : 23BC:          37 00  : Constant Mask Y=0 00000002 2
Addr : 23BE:             78  : Variable Operation Local Offset - 6 Read
Addr : 23BF:             F4  : Math Op *     
Addr : 23C0:             ED  : Math Op -     
Addr : 23C1:          C5 7C  : Memory Op Long PBASE + WRITE Address = 007C
226                            endofchain := $fff0
Addr : 23C3:       39 FF F0  : Constant 2 Bytes - FF F0 - $0000FFF0 65520
Addr : 23C6:       C5 80 94  : Memory Op Long PBASE + WRITE Address = 0094
Addr : 23C9: Label0017
Addr : 23C9: Label0016
227                         if (brword(@buf+$1fe) <> $aa55)
Addr : 23C9:             00  : Drop Anchor Push 
Addr : 23CA:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 23CC:       39 01 FE  : Constant 2 Bytes - 01 FE - $000001FE 510
Addr : 23CF:             EC  : Math Op +     
Addr : 23D0:          05 0C  : Call Sub 12   
Addr : 23D2:       39 AA 55  : Constant 2 Bytes - AA 55 - $0000AA55 43605
Addr : 23D5:             FB  : Math Op <>    
Addr : 23D6: JZ Label0018
Addr : 23D6:          0A 04  : jz Address = 23DC 4
228                           abort(-24) ' bad FAT signature
Addr : 23D8:          38 17  : Constant 1 Bytes - 17 - $00000017 23
Addr : 23DA:             E7  : Math Op !     
Addr : 23DB:             31  : Abort value   
Addr : 23DC: Label0018
Addr : 23DC: Label0019
229                         totclusters := ((sectors - dataregion + start) >> clustershift)
Addr : 23DC:          CC 24  : Memory Op Long DBASE + READ Address = 0024
Addr : 23DE:          C4 7C  : Memory Op Long PBASE + READ Address = 007C
Addr : 23E0:             ED  : Math Op -     
Addr : 23E1:             74  : Variable Operation Local Offset - 5 Read
Addr : 23E2:             EC  : Math Op +     
Addr : 23E3:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 23E6:             E2  : Math Op >>    
Addr : 23E7:       C5 80 8C  : Memory Op Long PBASE + WRITE Address = 008C
Addr : 23EA:             32  : Return        
|===========================================================================|
Spin Block pflush with 0 Parameters and 0 Extra Stack Longs. Method 6
pub pflush

Local Parameter DBASE:0000 - Result
|===========================================================================|
357                         return pflushbuf(bufat, 1)
Addr : 23EB:             00  : Drop Anchor Push 
Addr : 23EC:             50  : Variable Operation Global Offset - 4 Read
Addr : 23ED:             36  : Constant 2 $00000001
Addr : 23EE:          05 1A  : Call Sub 26   
Addr : 23F0:             33  : Return value  
Addr : 23F1: Data : 32                       2
|===========================================================================|
Spin Block pclose with 0 Parameters and 0 Extra Stack Longs. Method 7
pub pclose : r

Local Parameter DBASE:0000 - r
|===========================================================================|
383                         if (direntry)
Addr : 23F2:             58  : Variable Operation Global Offset - 6 Read
Addr : 23F3: JZ Label0003
Addr : 23F3:          0A 04  : jz Address = 23F9 4
384                            r := pflush
Addr : 23F5:             00  : Drop Anchor Push 
Addr : 23F6:          05 06  : Call Sub 6    
Addr : 23F8:             61  : Variable Operation Local Offset - 0 Write
Addr : 23F9: Label0003
Addr : 23F9: Label0004
385                         bufat := 0
Addr : 23F9:             35  : Constant 1 $00000000
Addr : 23FA:             51  : Variable Operation Global Offset - 4 Write
386                         bufend := 0
Addr : 23FB:             35  : Constant 1 $00000000
Addr : 23FC:             55  : Variable Operation Global Offset - 5 Write
387                         filesize := 0
Addr : 23FD:             35  : Constant 1 $00000000
Addr : 23FE:             45  : Variable Operation Global Offset - 1 Write
388                         floc := 0
Addr : 23FF:             35  : Constant 1 $00000000
Addr : 2400:             49  : Variable Operation Global Offset - 2 Write
389                         frem := 0
Addr : 2401:             35  : Constant 1 $00000000
Addr : 2402:             4D  : Variable Operation Global Offset - 3 Write
390                         writelink := 0
Addr : 2403:             35  : Constant 1 $00000000
Addr : 2404:             5D  : Variable Operation Global Offset - 7 Write
391                         direntry := 0
Addr : 2405:             35  : Constant 1 $00000000
Addr : 2406:             59  : Variable Operation Global Offset - 6 Write
392                         fclust := 0
Addr : 2407:             35  : Constant 1 $00000000
Addr : 2408:             41  : Variable Operation Global Offset - 0 Write
393                         firstcluster := 0
Addr : 2409:             35  : Constant 1 $00000000
Addr : 240A:          C9 24  : Memory Op Long VBASE + WRITE Address = 0024
394                         sdspi.release
Addr : 240C:             01  : Drop Anchor   
Addr : 240D:       06 1B 04  : Call Obj.Sub 27 4
Addr : 2410:             32  : Return        
|===========================================================================|
Spin Block popen with 2 Parameters and 4 Extra Stack Longs. Method 8
pub popen(s, mode) : r | i, sentinel, dirptr, freeentry

Local Parameter DBASE:0000 - r
Local Parameter DBASE:0004 - s
Local Parameter DBASE:0008 - mode
Local Variable  DBASE:000C - i
Local Variable  DBASE:0010 - sentinel
Local Variable  DBASE:0014 - dirptr
Local Variable  DBASE:0018 - freeentry
|===========================================================================|
412                         pclose
Addr : 2411:             01  : Drop Anchor   
Addr : 2412:          05 07  : Call Sub 7    
413                         i := 0
Addr : 2414:             35  : Constant 1 $00000000
Addr : 2415:             6D  : Variable Operation Local Offset - 3 Write
Addr : 2416: Label0003
414                         repeat while (i<8 and byte[s] and byte[s] <> ".")
Addr : 2416:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2417:          37 02  : Constant Mask Y=2 00000008 8
Addr : 2419:             F9  : Math Op <     
Addr : 241A:             64  : Variable Operation Local Offset - 1 Read
Addr : 241B:             80  : Memory Op Byte POP Address READ 
Addr : 241C:             F0  : Math Op AND   
Addr : 241D:             64  : Variable Operation Local Offset - 1 Read
Addr : 241E:             80  : Memory Op Byte POP Address READ 
Addr : 241F:          38 2E  : Constant 1 Bytes - 2E - $0000002E 46
Addr : 2421:             FB  : Math Op <>    
Addr : 2422:             F0  : Math Op AND   
Addr : 2423: JZ Label0005
Addr : 2423:          0A 0D  : jz Address = 2432 13
415                            padname[i++] := uc(byte[s++])
Addr : 2425:             00  : Drop Anchor Push 
Addr : 2426:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 2428:             80  : Memory Op Byte POP Address READ 
Addr : 2429:          05 19  : Call Sub 25   
Addr : 242B:          6E AE  : Variable Operation Local Offset - 3 Assign VAR++ post inc Long Push
Addr : 242D:       95 82 A4  : Memory Op Byte PBASE + POP Index WRITE Address = 02A4
Addr : 2430: Label0004
Addr : 2430: JMP Label0003
Addr : 2430:          04 64  : Jmp 2416 -28  
Addr : 2432: Label0005
Addr : 2432: Label0006
416                         repeat while (i<8)
Addr : 2432:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2433:          37 02  : Constant Mask Y=2 00000008 8
Addr : 2435:             F9  : Math Op <     
Addr : 2436: JZ Label0008
Addr : 2436:          0A 09  : jz Address = 2441 9
417                            padname[i++] := " "
Addr : 2438:          37 04  : Constant Mask Y=4 00000020 32
Addr : 243A:          6E AE  : Variable Operation Local Offset - 3 Assign VAR++ post inc Long Push
Addr : 243C:       95 82 A4  : Memory Op Byte PBASE + POP Index WRITE Address = 02A4
Addr : 243F: Label0007
Addr : 243F: JMP Label0006
Addr : 243F:          04 71  : Jmp 2432 -15  
Addr : 2441: Label0008
Addr : 2441: Label0009
418                         repeat while (byte[s] and byte[s] <> ".")
Addr : 2441:             64  : Variable Operation Local Offset - 1 Read
Addr : 2442:             80  : Memory Op Byte POP Address READ 
Addr : 2443:             64  : Variable Operation Local Offset - 1 Read
Addr : 2444:             80  : Memory Op Byte POP Address READ 
Addr : 2445:          38 2E  : Constant 1 Bytes - 2E - $0000002E 46
Addr : 2447:             FB  : Math Op <>    
Addr : 2448:             F0  : Math Op AND   
Addr : 2449: JZ Label000B
Addr : 2449:          0A 04  : jz Address = 244F 4
419                            s++
Addr : 244B:          66 2E  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long
Addr : 244D: Label000A
Addr : 244D: JMP Label0009
Addr : 244D:          04 72  : Jmp 2441 -14  
Addr : 244F: Label000B
420                         if (byte[s] == ".")
Addr : 244F:             64  : Variable Operation Local Offset - 1 Read
Addr : 2450:             80  : Memory Op Byte POP Address READ 
Addr : 2451:          38 2E  : Constant 1 Bytes - 2E - $0000002E 46
Addr : 2453:             FC  : Math Op ==    
Addr : 2454: JZ Label000C
Addr : 2454:          0A 02  : jz Address = 2458 2
421                            s++
Addr : 2456:          66 2E  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long
Addr : 2458: Label000C
Addr : 2458: Label000D
Addr : 2458: Label000E
422                         repeat while (i<11 and byte[s])
Addr : 2458:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2459:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 245B:             F9  : Math Op <     
Addr : 245C:             64  : Variable Operation Local Offset - 1 Read
Addr : 245D:             80  : Memory Op Byte POP Address READ 
Addr : 245E:             F0  : Math Op AND   
Addr : 245F: JZ Label0010
Addr : 245F:          0A 0D  : jz Address = 246E 13
423                            padname[i++] := uc(byte[s++])
Addr : 2461:             00  : Drop Anchor Push 
Addr : 2462:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 2464:             80  : Memory Op Byte POP Address READ 
Addr : 2465:          05 19  : Call Sub 25   
Addr : 2467:          6E AE  : Variable Operation Local Offset - 3 Assign VAR++ post inc Long Push
Addr : 2469:       95 82 A4  : Memory Op Byte PBASE + POP Index WRITE Address = 02A4
Addr : 246C: Label000F
Addr : 246C: JMP Label000E
Addr : 246C:          04 6A  : Jmp 2458 -22  
Addr : 246E: Label0010
Addr : 246E: Label0011
424                         repeat while (i < 11)
Addr : 246E:             6C  : Variable Operation Local Offset - 3 Read
Addr : 246F:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 2471:             F9  : Math Op <     
Addr : 2472: JZ Label0013
Addr : 2472:          0A 09  : jz Address = 247D 9
425                            padname[i++] := " "
Addr : 2474:          37 04  : Constant Mask Y=4 00000020 32
Addr : 2476:          6E AE  : Variable Operation Local Offset - 3 Assign VAR++ post inc Long Push
Addr : 2478:       95 82 A4  : Memory Op Byte PBASE + POP Index WRITE Address = 02A4
Addr : 247B: Label0012
Addr : 247B: JMP Label0011
Addr : 247B:          04 71  : Jmp 246E -15  
Addr : 247D: Label0013
426                         sentinel := 0
Addr : 247D:             35  : Constant 1 $00000000
Addr : 247E:             71  : Variable Operation Local Offset - 4 Write
427                         freeentry := 0
Addr : 247F:             35  : Constant 1 $00000000
Addr : 2480:             79  : Variable Operation Local Offset - 6 Write
428                         repeat dirptr from rootdir to rootdirend - DIRSIZE step DIRSIZE
Addr : 2481:          C4 74  : Memory Op Long PBASE + READ Address = 0074
Addr : 2483:             75  : Variable Operation Local Offset - 5 Write
Addr : 2484: Label0014
429                            s := readbytec(dirptr)
Addr : 2484:             00  : Drop Anchor Push 
Addr : 2485:             74  : Variable Operation Local Offset - 5 Read
Addr : 2486:          05 13  : Call Sub 19   
Addr : 2488:             65  : Variable Operation Local Offset - 1 Write
430                            if (freeentry == 0 and (byte[s] == 0 or byte[s] == $e5))
Addr : 2489:             78  : Variable Operation Local Offset - 6 Read
Addr : 248A:             35  : Constant 1 $00000000
Addr : 248B:             FC  : Math Op ==    
Addr : 248C:             64  : Variable Operation Local Offset - 1 Read
Addr : 248D:             80  : Memory Op Byte POP Address READ 
Addr : 248E:             35  : Constant 1 $00000000
Addr : 248F:             FC  : Math Op ==    
Addr : 2490:             64  : Variable Operation Local Offset - 1 Read
Addr : 2491:             80  : Memory Op Byte POP Address READ 
Addr : 2492:          38 E5  : Constant 1 Bytes - E5 - $000000E5 229
Addr : 2494:             FC  : Math Op ==    
Addr : 2495:             F2  : Math Op OR    
Addr : 2496:             F0  : Math Op AND   
Addr : 2497: JZ Label0017
Addr : 2497:          0A 02  : jz Address = 249B 2
431                               freeentry := dirptr
Addr : 2499:             74  : Variable Operation Local Offset - 5 Read
Addr : 249A:             79  : Variable Operation Local Offset - 6 Write
Addr : 249B: Label0017
Addr : 249B: Label0018
432                            if (byte[s] == 0)
Addr : 249B:             64  : Variable Operation Local Offset - 1 Read
Addr : 249C:             80  : Memory Op Byte POP Address READ 
Addr : 249D:             35  : Constant 1 $00000000
Addr : 249E:             FC  : Math Op ==    
Addr : 249F: JZ Label0019
Addr : 249F:          0A 05  : jz Address = 24A6 5
433                               sentinel := dirptr
Addr : 24A1:             74  : Variable Operation Local Offset - 5 Read
Addr : 24A2:             71  : Variable Operation Local Offset - 4 Write
Addr : 24A3: JMP Label0016
Addr : 24A3:       04 81 3D  : Jmp 25E3 317  
Addr : 24A6: Label0019
Addr : 24A6: Label001A
435                            repeat i from 0 to 10
Addr : 24A6:             35  : Constant 1 $00000000
Addr : 24A7:             6D  : Variable Operation Local Offset - 3 Write
Addr : 24A8: Label001B
436                               if (padname[i] <> byte[s][i])
Addr : 24A8:             6C  : Variable Operation Local Offset - 3 Read
Addr : 24A9:       94 82 A4  : Memory Op Byte PBASE + POP Index READ Address = 02A4
Addr : 24AC:             64  : Variable Operation Local Offset - 1 Read
Addr : 24AD:             6C  : Variable Operation Local Offset - 3 Read
Addr : 24AE:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 24AF:             FB  : Math Op <>    
Addr : 24B0: JZ Label001E
Addr : 24B0:          0A 02  : jz Address = 24B4 2
Addr : 24B2: JMP Label001D
Addr : 24B2:          04 06  : Jmp 24BA 6    
Addr : 24B4: Label001E
Addr : 24B4: Label001F
Addr : 24B4: Label001C
435                            repeat i from 0 to 10
Addr : 24B4:             35  : Constant 1 $00000000
Addr : 24B5:          38 0A  : Constant 1 Bytes - 0A - $0000000A 10
Addr : 24B7: Repeat i Step Label001B
Addr : 24B7:       6E 02 6E  : Variable Operation Local Offset - 3 Assign Repeat-Var loop Address= 24A8 -18
Addr : 24BA: Label001D
438                            if (i == 11 and 0 == (byte[s][$0b] & $18)) ' this always returns
Addr : 24BA:             6C  : Variable Operation Local Offset - 3 Read
Addr : 24BB:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 24BD:             FC  : Math Op ==    
Addr : 24BE:             35  : Constant 1 $00000000
Addr : 24BF:             64  : Variable Operation Local Offset - 1 Read
Addr : 24C0:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 24C2:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 24C3:          38 18  : Constant 1 Bytes - 18 - $00000018 24
Addr : 24C5:             E8  : Math Op &     
Addr : 24C6:             FC  : Math Op ==    
Addr : 24C7:             F0  : Math Op AND   
Addr : 24C8: JZ Label0020
Addr : 24C8:       0A 81 0B  : jz Address = 25D6 267
439                               fclust := brword(s+$1a)
Addr : 24CB:             00  : Drop Anchor Push 
Addr : 24CC:             64  : Variable Operation Local Offset - 1 Read
Addr : 24CD:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 24CF:             EC  : Math Op +     
Addr : 24D0:          05 0C  : Call Sub 12   
Addr : 24D2:             41  : Variable Operation Global Offset - 0 Write
440                               if (filesystem == 2)
Addr : 24D3:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 24D5:          37 00  : Constant Mask Y=0 00000002 2
Addr : 24D7:             FC  : Math Op ==    
Addr : 24D8: JZ Label0022
Addr : 24D8:          0A 0C  : jz Address = 24E6 12
441                                  fclust += brword(s+$14) << 16
Addr : 24DA:             00  : Drop Anchor Push 
Addr : 24DB:             64  : Variable Operation Local Offset - 1 Read
Addr : 24DC:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 24DE:             EC  : Math Op +     
Addr : 24DF:          05 0C  : Call Sub 12   
Addr : 24E1:          37 03  : Constant Mask Y=3 00000010 16
Addr : 24E3:             E3  : Math Op <<    
Addr : 24E4:          42 4C  : Variable Operation Global Offset - 0 Assign WordMathop +
Addr : 24E6: Label0022
Addr : 24E6: Label0023
442                               firstcluster := fclust
Addr : 24E6:             40  : Variable Operation Global Offset - 0 Read
Addr : 24E7:          C9 24  : Memory Op Long VBASE + WRITE Address = 0024
443                               filesize := brlong(s+$1c)
Addr : 24E9:             00  : Drop Anchor Push 
Addr : 24EA:             64  : Variable Operation Local Offset - 1 Read
Addr : 24EB:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
Addr : 24ED:             EC  : Math Op +     
Addr : 24EE:          05 0D  : Call Sub 13   
Addr : 24F0:             45  : Variable Operation Global Offset - 1 Write
444                               if (mode == "r")
Addr : 24F1:             68  : Variable Operation Local Offset - 2 Read
Addr : 24F2:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 24F4:             FC  : Math Op ==    
Addr : 24F5: JZ Label0024
Addr : 24F5:          0A 08  : jz Address = 24FF 8
445                                  frem := (clustersize) <# (filesize)
Addr : 24F7:       C4 80 84  : Memory Op Long PBASE + READ Address = 0084
Addr : 24FA:             44  : Variable Operation Global Offset - 1 Read
Addr : 24FB:             E5  : Math Op <#    
Addr : 24FC:             4D  : Variable Operation Global Offset - 3 Write
446                                  return 0
Addr : 24FD:             35  : Constant 1 $00000000
Addr : 24FE:             33  : Return value  
Addr : 24FF: Label0024
Addr : 24FF: Label0025
447                               if (byte[s][11] & $d9)
Addr : 24FF:             64  : Variable Operation Local Offset - 1 Read
Addr : 2500:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 2502:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 2503:          38 D9  : Constant 1 Bytes - D9 - $000000D9 217
Addr : 2505:             E8  : Math Op &     
Addr : 2506: JZ Label0026
Addr : 2506:          0A 04  : jz Address = 250C 4
448                                  abort(-6) ' no permission to write
Addr : 2508:          38 05  : Constant 1 Bytes - 05 - $00000005 5
Addr : 250A:             E7  : Math Op !     
Addr : 250B:             31  : Abort value   
Addr : 250C: Label0026
Addr : 250C: Label0027
449                               if (mode == "d")
Addr : 250C:             68  : Variable Operation Local Offset - 2 Read
Addr : 250D:          38 64  : Constant 1 Bytes - 64 - $00000064 100
Addr : 250F:             FC  : Math Op ==    
Addr : 2510: JZ Label0028
Addr : 2510:          0A 12  : jz Address = 2524 18
450                                  brwword(s, $e5)
Addr : 2512:             01  : Drop Anchor   
Addr : 2513:             64  : Variable Operation Local Offset - 1 Read
Addr : 2514:          38 E5  : Constant 1 Bytes - E5 - $000000E5 229
Addr : 2516:          05 0F  : Call Sub 15   
451                                  if (fclust)
Addr : 2518:             40  : Variable Operation Global Offset - 0 Read
Addr : 2519: JZ Label002A
Addr : 2519:          0A 04  : jz Address = 251F 4
452                                     freeclusters(fclust)
Addr : 251B:             01  : Drop Anchor   
Addr : 251C:             40  : Variable Operation Global Offset - 0 Read
Addr : 251D:          05 17  : Call Sub 23   
Addr : 251F: Label002A
Addr : 251F: Label002B
453                                  flushifdirty
Addr : 251F:             01  : Drop Anchor   
Addr : 2520:          05 0A  : Call Sub 10   
454                                  return 0
Addr : 2522:             35  : Constant 1 $00000000
Addr : 2523:             33  : Return value  
Addr : 2524: Label0028
Addr : 2524: Label0029
455                               if (mode == "w")
Addr : 2524:             68  : Variable Operation Local Offset - 2 Read
Addr : 2525:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 2527:             FC  : Math Op ==    
Addr : 2528: JZ Label002C
Addr : 2528:          0A 31  : jz Address = 255B 49
456                                  brwword(s+$1a, 0)
Addr : 252A:             01  : Drop Anchor   
Addr : 252B:             64  : Variable Operation Local Offset - 1 Read
Addr : 252C:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 252E:             EC  : Math Op +     
Addr : 252F:             35  : Constant 1 $00000000
Addr : 2530:          05 0F  : Call Sub 15   
457                                  brwword(s+$14, 0)
Addr : 2532:             01  : Drop Anchor   
Addr : 2533:             64  : Variable Operation Local Offset - 1 Read
Addr : 2534:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 2536:             EC  : Math Op +     
Addr : 2537:             35  : Constant 1 $00000000
Addr : 2538:          05 0F  : Call Sub 15   
458                                  brwlong(s+$1c, 0)
Addr : 253A:             01  : Drop Anchor   
Addr : 253B:             64  : Variable Operation Local Offset - 1 Read
Addr : 253C:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
Addr : 253E:             EC  : Math Op +     
Addr : 253F:             35  : Constant 1 $00000000
Addr : 2540:          05 10  : Call Sub 16   
459                                  writelink := 0
Addr : 2542:             35  : Constant 1 $00000000
Addr : 2543:             5D  : Variable Operation Global Offset - 7 Write
460                                  direntry := dirptr
Addr : 2544:             74  : Variable Operation Local Offset - 5 Read
Addr : 2545:             59  : Variable Operation Global Offset - 6 Write
461                                  if (fclust)
Addr : 2546:             40  : Variable Operation Global Offset - 0 Read
Addr : 2547: JZ Label002E
Addr : 2547:          0A 04  : jz Address = 254D 4
462                                     freeclusters(fclust)
Addr : 2549:             01  : Drop Anchor   
Addr : 254A:             40  : Variable Operation Global Offset - 0 Read
Addr : 254B:          05 17  : Call Sub 23   
Addr : 254D: Label002E
Addr : 254D: Label002F
Addr : 254D:          37 08  : Constant Mask Y=8 00000200 512
463                                  bufend := SECTORSIZE
Addr : 254F:             55  : Variable Operation Global Offset - 5 Write
464                                  fclust := 0
Addr : 2550:             35  : Constant 1 $00000000
Addr : 2551:             41  : Variable Operation Global Offset - 0 Write
465                                  filesize := 0
Addr : 2552:             35  : Constant 1 $00000000
Addr : 2553:             45  : Variable Operation Global Offset - 1 Write
466                                  frem := 0
Addr : 2554:             35  : Constant 1 $00000000
Addr : 2555:             4D  : Variable Operation Global Offset - 3 Write
467                                  return 0
Addr : 2556:             35  : Constant 1 $00000000
Addr : 2557:             33  : Return value  
Addr : 2558: JMP Label002D
Addr : 2558:       04 80 7B  : Jmp 25D6 123  
Addr : 255B: Label002C
468                               elseif (mode == "a")
Addr : 255B:             68  : Variable Operation Local Offset - 2 Read
Addr : 255C:          38 61  : Constant 1 Bytes - 61 - $00000061 97
Addr : 255E:             FC  : Math Op ==    
Addr : 255F: JZ Label0030
Addr : 255F:       0A 80 71  : jz Address = 25D3 113
470                                  frem := filesize
Addr : 2562:             44  : Variable Operation Global Offset - 1 Read
Addr : 2563:             4D  : Variable Operation Global Offset - 3 Write
471                                  freeentry := clustersize
Addr : 2564:       C4 80 84  : Memory Op Long PBASE + READ Address = 0084
Addr : 2567:             79  : Variable Operation Local Offset - 6 Write
472                                  if (fclust => endofchain)
Addr : 2568:             40  : Variable Operation Global Offset - 0 Read
Addr : 2569:       C4 80 94  : Memory Op Long PBASE + READ Address = 0094
Addr : 256C:             FE  : Math Op =>    
Addr : 256D: JZ Label0031
Addr : 256D:          0A 02  : jz Address = 2571 2
473                                     fclust := 0
Addr : 256F:             35  : Constant 1 $00000000
Addr : 2570:             41  : Variable Operation Global Offset - 0 Write
Addr : 2571: Label0031
Addr : 2571: Label0032
Addr : 2571: Label0033
474                                  repeat while (frem > freeentry)
Addr : 2571:             4C  : Variable Operation Global Offset - 3 Read
Addr : 2572:             78  : Variable Operation Local Offset - 6 Read
Addr : 2573:             FA  : Math Op >     
Addr : 2574: JZ Label0035
Addr : 2574:          0A 13  : jz Address = 2589 19
475                                     if (fclust < 2)
Addr : 2576:             40  : Variable Operation Global Offset - 0 Read
Addr : 2577:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2579:             F9  : Math Op <     
Addr : 257A: JZ Label0036
Addr : 257A:          0A 04  : jz Address = 2580 4
476                                        abort(-7) ' eof repeat while following chain
Addr : 257C:          38 06  : Constant 1 Bytes - 06 - $00000006 6
Addr : 257E:             E7  : Math Op !     
Addr : 257F:             31  : Abort value   
Addr : 2580: Label0036
Addr : 2580: Label0037
477                                     fclust := nextcluster
Addr : 2580:             00  : Drop Anchor Push 
Addr : 2581:          05 16  : Call Sub 22   
Addr : 2583:             41  : Variable Operation Global Offset - 0 Write
478                                     frem -= freeentry
Addr : 2584:             78  : Variable Operation Local Offset - 6 Read
Addr : 2585:          4E 4D  : Variable Operation Global Offset - 3 Assign WordMathop -
Addr : 2587: Label0034
Addr : 2587: JMP Label0033
Addr : 2587:          04 68  : Jmp 2571 -24  
Addr : 2589: Label0035
479                                  floc := filesize & constant(!(SECTORSIZE - 1))
Addr : 2589:             44  : Variable Operation Global Offset - 1 Read
Addr : 258A:          37 68  : Constant Mask Y=104 Decrement Invert FFFFFE00 4294966784
Addr : 258C:             E8  : Math Op &     
Addr : 258D:             49  : Variable Operation Global Offset - 2 Write
Addr : 258E:          37 08  : Constant Mask Y=8 00000200 512
480                                  bufend := SECTORSIZE
Addr : 2590:             55  : Variable Operation Global Offset - 5 Write
481                                  bufat := frem & constant(SECTORSIZE - 1)
Addr : 2591:             4C  : Variable Operation Global Offset - 3 Read
Addr : 2592:          37 28  : Constant Mask Y=40 Decrement 000001FF 511
Addr : 2594:             E8  : Math Op &     
Addr : 2595:             51  : Variable Operation Global Offset - 4 Write
482                                  writelink := 0
Addr : 2596:             35  : Constant 1 $00000000
Addr : 2597:             5D  : Variable Operation Global Offset - 7 Write
483                                  direntry := dirptr
Addr : 2598:             74  : Variable Operation Local Offset - 5 Read
Addr : 2599:             59  : Variable Operation Global Offset - 6 Write
484                                  if (bufat)
Addr : 259A:             50  : Variable Operation Global Offset - 4 Read
Addr : 259B: JZ Label0038
Addr : 259B:          0A 13  : jz Address = 25B0 19
485                                     sdspi.readblock(datablock, @buf)
Addr : 259D:             01  : Drop Anchor   
Addr : 259E:             00  : Drop Anchor Push 
Addr : 259F:          05 18  : Call Sub 24   
Addr : 25A1:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 25A3:       06 1B 01  : Call Obj.Sub 27 1
486                                     frem := freeentry - (floc & (freeentry - 1))
Addr : 25A6:             78  : Variable Operation Local Offset - 6 Read
Addr : 25A7:             48  : Variable Operation Global Offset - 2 Read
Addr : 25A8:             78  : Variable Operation Local Offset - 6 Read
Addr : 25A9:             36  : Constant 2 $00000001
Addr : 25AA:             ED  : Math Op -     
Addr : 25AB:             E8  : Math Op &     
Addr : 25AC:             ED  : Math Op -     
Addr : 25AD:             4D  : Variable Operation Global Offset - 3 Write
Addr : 25AE: JMP Label0039
Addr : 25AE:          04 16  : Jmp 25C6 22   
Addr : 25B0: Label0038
488                                     if (fclust < 2 or frem == freeentry)
Addr : 25B0:             40  : Variable Operation Global Offset - 0 Read
Addr : 25B1:          37 00  : Constant Mask Y=0 00000002 2
Addr : 25B3:             F9  : Math Op <     
Addr : 25B4:             4C  : Variable Operation Global Offset - 3 Read
Addr : 25B5:             78  : Variable Operation Local Offset - 6 Read
Addr : 25B6:             FC  : Math Op ==    
Addr : 25B7:             F2  : Math Op OR    
Addr : 25B8: JZ Label003B
Addr : 25B8:          0A 04  : jz Address = 25BE 4
489                                        frem := 0
Addr : 25BA:             35  : Constant 1 $00000000
Addr : 25BB:             4D  : Variable Operation Global Offset - 3 Write
Addr : 25BC: JMP Label003C
Addr : 25BC:          04 08  : Jmp 25C6 8    
Addr : 25BE: Label003B
491                                        frem := freeentry - (floc & (freeentry - 1))
Addr : 25BE:             78  : Variable Operation Local Offset - 6 Read
Addr : 25BF:             48  : Variable Operation Global Offset - 2 Read
Addr : 25C0:             78  : Variable Operation Local Offset - 6 Read
Addr : 25C1:             36  : Constant 2 $00000001
Addr : 25C2:             ED  : Math Op -     
Addr : 25C3:             E8  : Math Op &     
Addr : 25C4:             ED  : Math Op -     
Addr : 25C5:             4D  : Variable Operation Global Offset - 3 Write
Addr : 25C6: Label003D
Addr : 25C6: Label003C
Addr : 25C6: Label003A
Addr : 25C6: Label0039
492                                  if (fclust => 2)
Addr : 25C6:             40  : Variable Operation Global Offset - 0 Read
Addr : 25C7:          37 00  : Constant Mask Y=0 00000002 2
Addr : 25C9:             FE  : Math Op =>    
Addr : 25CA: JZ Label003E
Addr : 25CA:          0A 03  : jz Address = 25CF 3
493                                     followchain
Addr : 25CC:             01  : Drop Anchor   
Addr : 25CD:          05 15  : Call Sub 21   
Addr : 25CF: Label003E
Addr : 25CF: Label003F
494                                  return 0
Addr : 25CF:             35  : Constant 1 $00000000
Addr : 25D0:             33  : Return value  
Addr : 25D1: JMP Label002D
Addr : 25D1:          04 03  : Jmp 25D6 3    
Addr : 25D3: Label0030
496                                  abort(-3) ' bad argument
Addr : 25D3:          37 40  : Constant Mask Y=64 Invert FFFFFFFD 4294967293
Addr : 25D5:             31  : Abort value   
Addr : 25D6: Label0040
Addr : 25D6: Label002D
Addr : 25D6: Label0020
Addr : 25D6: Label0021
Addr : 25D6: Label0015
Addr : 25D6:          37 04  : Constant Mask Y=4 00000020 32
428                         repeat dirptr from rootdir to rootdirend - DIRSIZE step DIRSIZE
Addr : 25D8:          C4 74  : Memory Op Long PBASE + READ Address = 0074
Addr : 25DA:          C4 78  : Memory Op Long PBASE + READ Address = 0078
Addr : 25DC:          37 04  : Constant Mask Y=4 00000020 32
Addr : 25DE:             ED  : Math Op -     
Addr : 25DF: Repeat dirptr Step Label0014
Addr : 25DF:    76 06 FE A1  : Variable Operation Local Offset - 5 Assign Repeat-Var loop (pop step) Address= 2484 -351
Addr : 25E3: Label0016
497                         if (mode <> "w" and mode <> "a")
Addr : 25E3:             68  : Variable Operation Local Offset - 2 Read
Addr : 25E4:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 25E6:             FB  : Math Op <>    
Addr : 25E7:             68  : Variable Operation Local Offset - 2 Read
Addr : 25E8:          38 61  : Constant 1 Bytes - 61 - $00000061 97
Addr : 25EA:             FB  : Math Op <>    
Addr : 25EB:             F0  : Math Op AND   
Addr : 25EC: JZ Label0041
Addr : 25EC:          0A 02  : jz Address = 25F0 2
498                            return -1 ' not found
Addr : 25EE:             34  : Constant 0 $FFFFFFFF
Addr : 25EF:             33  : Return value  
Addr : 25F0: Label0041
Addr : 25F0: Label0042
499                         direntry := freeentry
Addr : 25F0:             78  : Variable Operation Local Offset - 6 Read
Addr : 25F1:             59  : Variable Operation Global Offset - 6 Write
500                         if (direntry == 0)
Addr : 25F2:             58  : Variable Operation Global Offset - 6 Read
Addr : 25F3:             35  : Constant 1 $00000000
Addr : 25F4:             FC  : Math Op ==    
Addr : 25F5: JZ Label0043
Addr : 25F5:          0A 03  : jz Address = 25FA 3
501                            abort(-2) ' no empty directory entry
Addr : 25F7:          37 60  : Constant Mask Y=96 Decrement Invert FFFFFFFE 4294967294
Addr : 25F9:             31  : Abort value   
Addr : 25FA: Label0043
Addr : 25FA: Label0044
503                         s := readbytec(direntry)
Addr : 25FA:             00  : Drop Anchor Push 
Addr : 25FB:             58  : Variable Operation Global Offset - 6 Read
Addr : 25FC:          05 13  : Call Sub 19   
Addr : 25FE:             65  : Variable Operation Local Offset - 1 Write
504                         bytefill(s, 0, DIRSIZE)
Addr : 25FF:             64  : Variable Operation Local Offset - 1 Read
Addr : 2600:             35  : Constant 1 $00000000
Addr : 2601:          37 04  : Constant Mask Y=4 00000020 32
Addr : 2603:             18  : ByteFill(Start, Value, Count)
505                         bytemove(s, @padname, 11)
Addr : 2604:             64  : Variable Operation Local Offset - 1 Read
Addr : 2605:       87 82 A4  : Memory Op Byte PBASE + ADDRESS Address = 02A4
Addr : 2608:          38 0B  : Constant 1 Bytes - 0B - $0000000B 11
Addr : 260A:             1C  : ByteMove(To, From, Count)
506                         brwword(s+$1a, 0)
Addr : 260B:             01  : Drop Anchor   
Addr : 260C:             64  : Variable Operation Local Offset - 1 Read
Addr : 260D:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 260F:             EC  : Math Op +     
Addr : 2610:             35  : Constant 1 $00000000
Addr : 2611:          05 0F  : Call Sub 15   
507                         brwword(s+$14, 0)
Addr : 2613:             01  : Drop Anchor   
Addr : 2614:             64  : Variable Operation Local Offset - 1 Read
Addr : 2615:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 2617:             EC  : Math Op +     
Addr : 2618:             35  : Constant 1 $00000000
Addr : 2619:          05 0F  : Call Sub 15   
508                         i := pdate
Addr : 261B:       C4 80 98  : Memory Op Long PBASE + READ Address = 0098
Addr : 261E:             6D  : Variable Operation Local Offset - 3 Write
509                         brwlong(s+$e, i) ' write create time and date
Addr : 261F:             01  : Drop Anchor   
Addr : 2620:             64  : Variable Operation Local Offset - 1 Read
Addr : 2621:          38 0E  : Constant 1 Bytes - 0E - $0000000E 14
Addr : 2623:             EC  : Math Op +     
Addr : 2624:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2625:          05 10  : Call Sub 16   
510                         brwlong(s+$16, i) ' write last modified date and time
Addr : 2627:             01  : Drop Anchor   
Addr : 2628:             64  : Variable Operation Local Offset - 1 Read
Addr : 2629:          38 16  : Constant 1 Bytes - 16 - $00000016 22
Addr : 262B:             EC  : Math Op +     
Addr : 262C:             6C  : Variable Operation Local Offset - 3 Read
Addr : 262D:          05 10  : Call Sub 16   
511                         if (direntry == sentinel and direntry + DIRSIZE < rootdirend)
Addr : 262F:             58  : Variable Operation Global Offset - 6 Read
Addr : 2630:             70  : Variable Operation Local Offset - 4 Read
Addr : 2631:             FC  : Math Op ==    
Addr : 2632:             58  : Variable Operation Global Offset - 6 Read
Addr : 2633:          37 04  : Constant Mask Y=4 00000020 32
Addr : 2635:             EC  : Math Op +     
Addr : 2636:          C4 78  : Memory Op Long PBASE + READ Address = 0078
Addr : 2638:             F9  : Math Op <     
Addr : 2639:             F0  : Math Op AND   
Addr : 263A: JZ Label0045
Addr : 263A:          0A 0B  : jz Address = 2647 11
512                            brwword(readbytec(direntry+DIRSIZE), 0)
Addr : 263C:             01  : Drop Anchor   
Addr : 263D:             00  : Drop Anchor Push 
Addr : 263E:             58  : Variable Operation Global Offset - 6 Read
Addr : 263F:          37 04  : Constant Mask Y=4 00000020 32
Addr : 2641:             EC  : Math Op +     
Addr : 2642:          05 13  : Call Sub 19   
Addr : 2644:             35  : Constant 1 $00000000
Addr : 2645:          05 0F  : Call Sub 15   
Addr : 2647: Label0045
Addr : 2647: Label0046
513                         flushifdirty
Addr : 2647:             01  : Drop Anchor   
Addr : 2648:          05 0A  : Call Sub 10   
514                         writelink := 0
Addr : 264A:             35  : Constant 1 $00000000
Addr : 264B:             5D  : Variable Operation Global Offset - 7 Write
515                         fclust := 0
Addr : 264C:             35  : Constant 1 $00000000
Addr : 264D:             41  : Variable Operation Global Offset - 0 Write
Addr : 264E:          37 08  : Constant Mask Y=8 00000200 512
516                         bufend := SECTORSIZE
Addr : 2650:             55  : Variable Operation Global Offset - 5 Write
Addr : 2651:             32  : Return        
|===========================================================================|
Spin Block writeblock2 with 2 Parameters and 0 Extra Stack Longs. Method 9
pri writeblock2(n, b)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - n
Local Parameter DBASE:0008 - b
|===========================================================================|
102                         sdspi.writeblock(n, b)
Addr : 2652:             01  : Drop Anchor   
Addr : 2653:             64  : Variable Operation Local Offset - 1 Read
Addr : 2654:             68  : Variable Operation Local Offset - 2 Read
Addr : 2655:       06 1B 02  : Call Obj.Sub 27 2
103                         if (n => fat1)
Addr : 2658:             64  : Variable Operation Local Offset - 1 Read
Addr : 2659:       C4 80 88  : Memory Op Long PBASE + READ Address = 0088
Addr : 265C:             FE  : Math Op =>    
Addr : 265D: JZ Label0003
Addr : 265D:          0A 15  : jz Address = 2674 21
104                           if (n < fat1 + sectorsperfat)
Addr : 265F:             64  : Variable Operation Local Offset - 1 Read
Addr : 2660:       C4 80 88  : Memory Op Long PBASE + READ Address = 0088
Addr : 2663:       C4 80 90  : Memory Op Long PBASE + READ Address = 0090
Addr : 2666:             EC  : Math Op +     
Addr : 2667:             F9  : Math Op <     
Addr : 2668: JZ Label0005
Addr : 2668:          0A 0A  : jz Address = 2674 10
105                             sdspi.writeblock(n+sectorsperfat, b)
Addr : 266A:             01  : Drop Anchor   
Addr : 266B:             64  : Variable Operation Local Offset - 1 Read
Addr : 266C:       C4 80 90  : Memory Op Long PBASE + READ Address = 0090
Addr : 266F:             EC  : Math Op +     
Addr : 2670:             68  : Variable Operation Local Offset - 2 Read
Addr : 2671:       06 1B 02  : Call Obj.Sub 27 2
Addr : 2674: Label0005
Addr : 2674: Label0006
Addr : 2674: Label0003
Addr : 2674: Label0004
Addr : 2674:             32  : Return        
|===========================================================================|
Spin Block flushifdirty with 0 Parameters and 0 Extra Stack Longs. Method 10
pri flushifdirty

Local Parameter DBASE:0000 - Result
|===========================================================================|
110                         if (dirty)
Addr : 2675:       C4 80 A0  : Memory Op Long PBASE + READ Address = 00A0
Addr : 2678: JZ Label0003
Addr : 2678:          0A 0D  : jz Address = 2687 13
111                            writeblock2(lastread, @buf2)
Addr : 267A:             01  : Drop Anchor   
Addr : 267B:       C4 80 9C  : Memory Op Long PBASE + READ Address = 009C
Addr : 267E:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2681:          05 09  : Call Sub 9    
112                            dirty := 0
Addr : 2683:             35  : Constant 1 $00000000
Addr : 2684:       C5 80 A0  : Memory Op Long PBASE + WRITE Address = 00A0
Addr : 2687: Label0003
Addr : 2687: Label0004
Addr : 2687:             32  : Return        
|===========================================================================|
Spin Block readblockc with 1 Parameters and 0 Extra Stack Longs. Method 11
pri readblockc(n)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - n
|===========================================================================|
118                         if (n <> lastread)
Addr : 2688:             64  : Variable Operation Local Offset - 1 Read
Addr : 2689:       C4 80 9C  : Memory Op Long PBASE + READ Address = 009C
Addr : 268C:             FB  : Math Op <>    
Addr : 268D: JZ Label0003
Addr : 268D:          0A 0F  : jz Address = 269E 15
119                            flushifdirty
Addr : 268F:             01  : Drop Anchor   
Addr : 2690:          05 0A  : Call Sub 10   
120                            sdspi.readblock(n, @buf2)
Addr : 2692:             01  : Drop Anchor   
Addr : 2693:             64  : Variable Operation Local Offset - 1 Read
Addr : 2694:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2697:       06 1B 01  : Call Obj.Sub 27 1
121                            lastread := n
Addr : 269A:             64  : Variable Operation Local Offset - 1 Read
Addr : 269B:       C5 80 9C  : Memory Op Long PBASE + WRITE Address = 009C
Addr : 269E: Label0003
Addr : 269E: Label0004
Addr : 269E:             32  : Return        
|===========================================================================|
Spin Block brword with 1 Parameters and 0 Extra Stack Longs. Method 12
pri brword(b)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - b
|===========================================================================|
126                         return (byte[b]) + ((byte[b][1]) << 8)
Addr : 269F:             64  : Variable Operation Local Offset - 1 Read
Addr : 26A0:             80  : Memory Op Byte POP Address READ 
Addr : 26A1:             64  : Variable Operation Local Offset - 1 Read
Addr : 26A2:             36  : Constant 2 $00000001
Addr : 26A3:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 26A4:          37 02  : Constant Mask Y=2 00000008 8
Addr : 26A6:             E3  : Math Op <<    
Addr : 26A7:             EC  : Math Op +     
Addr : 26A8:             33  : Return value  
Addr : 26A9: Data : 32                       2
|===========================================================================|
Spin Block brlong with 1 Parameters and 0 Extra Stack Longs. Method 13
pri brlong(b)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - b
|===========================================================================|
131                         return brword(b) + (brword(b+2) << 16)
Addr : 26AA:             00  : Drop Anchor Push 
Addr : 26AB:             64  : Variable Operation Local Offset - 1 Read
Addr : 26AC:          05 0C  : Call Sub 12   
Addr : 26AE:             00  : Drop Anchor Push 
Addr : 26AF:             64  : Variable Operation Local Offset - 1 Read
Addr : 26B0:          37 00  : Constant Mask Y=0 00000002 2
Addr : 26B2:             EC  : Math Op +     
Addr : 26B3:          05 0C  : Call Sub 12   
Addr : 26B5:          37 03  : Constant Mask Y=3 00000010 16
Addr : 26B7:             E3  : Math Op <<    
Addr : 26B8:             EC  : Math Op +     
Addr : 26B9:             33  : Return value  
Addr : 26BA: Data : 32                       2
|===========================================================================|
Spin Block brclust with 1 Parameters and 0 Extra Stack Longs. Method 14
pri brclust(b)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - b
|===========================================================================|
136                        if (filesystem == 1)
Addr : 26BB:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 26BD:             36  : Constant 2 $00000001
Addr : 26BE:             FC  : Math Op ==    
Addr : 26BF: JZ Label0002
Addr : 26BF:          0A 07  : jz Address = 26C8 7
137                          return brword(b)
Addr : 26C1:             00  : Drop Anchor Push 
Addr : 26C2:             64  : Variable Operation Local Offset - 1 Read
Addr : 26C3:          05 0C  : Call Sub 12   
Addr : 26C5:             33  : Return value  
Addr : 26C6: JMP Label0003
Addr : 26C6:          04 05  : Jmp 26CD 5    
Addr : 26C8: Label0002
139                          return brlong(b)
Addr : 26C8:             00  : Drop Anchor Push 
Addr : 26C9:             64  : Variable Operation Local Offset - 1 Read
Addr : 26CA:          05 0D  : Call Sub 13   
Addr : 26CC:             33  : Return value  
Addr : 26CD: Label0004
Addr : 26CD: Label0003
Addr : 26CD:             32  : Return        
|===========================================================================|
Spin Block brwword with 2 Parameters and 0 Extra Stack Longs. Method 15
pri brwword(w, v)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - w
Local Parameter DBASE:0008 - v
|===========================================================================|
145                         byte[w++] := v
Addr : 26CE:             68  : Variable Operation Local Offset - 2 Read
Addr : 26CF:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 26D1:             81  : Memory Op Byte POP Address WRITE 
146                         byte[w] := v >> 8
Addr : 26D2:             68  : Variable Operation Local Offset - 2 Read
Addr : 26D3:          37 02  : Constant Mask Y=2 00000008 8
Addr : 26D5:             E2  : Math Op >>    
Addr : 26D6:             64  : Variable Operation Local Offset - 1 Read
Addr : 26D7:             81  : Memory Op Byte POP Address WRITE 
147                         dirty := 1
Addr : 26D8:             36  : Constant 2 $00000001
Addr : 26D9:       C5 80 A0  : Memory Op Long PBASE + WRITE Address = 00A0
Addr : 26DC:             32  : Return        
|===========================================================================|
Spin Block brwlong with 2 Parameters and 0 Extra Stack Longs. Method 16
pri brwlong(w, v)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - w
Local Parameter DBASE:0008 - v
|===========================================================================|
153                         brwword(w, v)
Addr : 26DD:             01  : Drop Anchor   
Addr : 26DE:             64  : Variable Operation Local Offset - 1 Read
Addr : 26DF:             68  : Variable Operation Local Offset - 2 Read
Addr : 26E0:          05 0F  : Call Sub 15   
154                         brwword(w+2, v >> 16)
Addr : 26E2:             01  : Drop Anchor   
Addr : 26E3:             64  : Variable Operation Local Offset - 1 Read
Addr : 26E4:          37 00  : Constant Mask Y=0 00000002 2
Addr : 26E6:             EC  : Math Op +     
Addr : 26E7:             68  : Variable Operation Local Offset - 2 Read
Addr : 26E8:          37 03  : Constant Mask Y=3 00000010 16
Addr : 26EA:             E2  : Math Op >>    
Addr : 26EB:          05 0F  : Call Sub 15   
Addr : 26ED:             32  : Return        
|===========================================================================|
Spin Block brwclust with 2 Parameters and 0 Extra Stack Longs. Method 17
pri brwclust(w, v)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - w
Local Parameter DBASE:0008 - v
|===========================================================================|
158                         if (filesystem == 1)
Addr : 26EE:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 26F0:             36  : Constant 2 $00000001
Addr : 26F1:             FC  : Math Op ==    
Addr : 26F2: JZ Label0003
Addr : 26F2:          0A 07  : jz Address = 26FB 7
159                           brwword(w, v)
Addr : 26F4:             01  : Drop Anchor   
Addr : 26F5:             64  : Variable Operation Local Offset - 1 Read
Addr : 26F6:             68  : Variable Operation Local Offset - 2 Read
Addr : 26F7:          05 0F  : Call Sub 15   
Addr : 26F9: JMP Label0004
Addr : 26F9:          04 05  : Jmp 2700 5    
Addr : 26FB: Label0003
161                           brwlong(w, v)
Addr : 26FB:             01  : Drop Anchor   
Addr : 26FC:             64  : Variable Operation Local Offset - 1 Read
Addr : 26FD:             68  : Variable Operation Local Offset - 2 Read
Addr : 26FE:          05 10  : Call Sub 16   
Addr : 2700: Label0005
Addr : 2700: Label0004
Addr : 2700:             32  : Return        
|===========================================================================|
Spin Block getfstype with 0 Parameters and 0 Extra Stack Longs. Method 18
pri getfstype : r

Local Parameter DBASE:0000 - r
|===========================================================================|
169                         if (brlong(@buf+$36) == constant("F" + ("A" << 8) + ("T" << 16) + ("1" << 24)) and buf[$3a]=="6")
Addr : 2701:             00  : Drop Anchor Push 
Addr : 2702:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 2704:          38 36  : Constant 1 Bytes - 36 - $00000036 54
Addr : 2706:             EC  : Math Op +     
Addr : 2707:          05 0D  : Call Sub 13   
Addr : 2709: 3B 31 54 41 46  : Constant 4 Bytes - 31 54 41 46 - $31544146 827605318
Addr : 270E:             FC  : Math Op ==    
Addr : 270F:          38 3A  : Constant 1 Bytes - 3A - $0000003A 58
Addr : 2711:          98 28  : Memory Op Byte VBASE + POP Index READ Address = 0028
Addr : 2713:          38 36  : Constant 1 Bytes - 36 - $00000036 54
Addr : 2715:             FC  : Math Op ==    
Addr : 2716:             F0  : Math Op AND   
Addr : 2717: JZ Label0003
Addr : 2717:          0A 02  : jz Address = 271B 2
170                           return 1
Addr : 2719:             36  : Constant 2 $00000001
Addr : 271A:             33  : Return value  
Addr : 271B: Label0003
Addr : 271B: Label0004
171                         if (brlong(@buf+$52) == constant("F" + ("A" << 8) + ("T" << 16) + ("3" << 24)) and buf[$56]=="2")
Addr : 271B:             00  : Drop Anchor Push 
Addr : 271C:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 271E:          38 52  : Constant 1 Bytes - 52 - $00000052 82
Addr : 2720:             EC  : Math Op +     
Addr : 2721:          05 0D  : Call Sub 13   
Addr : 2723: 3B 33 54 41 46  : Constant 4 Bytes - 33 54 41 46 - $33544146 861159750
Addr : 2728:             FC  : Math Op ==    
Addr : 2729:          38 56  : Constant 1 Bytes - 56 - $00000056 86
Addr : 272B:          98 28  : Memory Op Byte VBASE + POP Index READ Address = 0028
Addr : 272D:          38 32  : Constant 1 Bytes - 32 - $00000032 50
Addr : 272F:             FC  : Math Op ==    
Addr : 2730:             F0  : Math Op AND   
Addr : 2731: JZ Label0005
Addr : 2731:          0A 03  : jz Address = 2736 3
172                           return 2
Addr : 2733:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2735:             33  : Return value  
Addr : 2736: Label0005
Addr : 2736: Label0006
Addr : 2736:             32  : Return        
|===========================================================================|
Spin Block readbytec with 1 Parameters and 0 Extra Stack Longs. Method 19
pri readbytec(byteloc)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - byteloc
|===========================================================================|
241                         readblockc(byteloc >> SECTORSHIFT)
Addr : 2737:             01  : Drop Anchor   
Addr : 2738:             64  : Variable Operation Local Offset - 1 Read
Addr : 2739:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 273B:             E2  : Math Op >>    
Addr : 273C:          05 0B  : Call Sub 11   
242                         return @buf2 + (byteloc & constant(SECTORSIZE - 1))
Addr : 273E:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2741:             64  : Variable Operation Local Offset - 1 Read
Addr : 2742:          37 28  : Constant Mask Y=40 Decrement 000001FF 511
Addr : 2744:             E8  : Math Op &     
Addr : 2745:             EC  : Math Op +     
Addr : 2746:             33  : Return value  
Addr : 2747: Data : 32                       2
|===========================================================================|
Spin Block readfat with 1 Parameters and 0 Extra Stack Longs. Method 20
pri readfat(clust)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - clust
|===========================================================================|
248                         fatptr := (fat1 << SECTORSHIFT) + (clust << filesystem)
Addr : 2748:       C4 80 88  : Memory Op Long PBASE + READ Address = 0088
Addr : 274B:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 274D:             E3  : Math Op <<    
Addr : 274E:             64  : Variable Operation Local Offset - 1 Read
Addr : 274F:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2751:             E3  : Math Op <<    
Addr : 2752:             EC  : Math Op +     
Addr : 2753:          C9 20  : Memory Op Long VBASE + WRITE Address = 0020
249                         return readbytec(fatptr)
Addr : 2755:             00  : Drop Anchor Push 
Addr : 2756:          C8 20  : Memory Op Long VBASE + READ Address = 0020
Addr : 2758:          05 13  : Call Sub 19   
Addr : 275A:             33  : Return value  
Addr : 275B: Data : 32                       2
|===========================================================================|
Spin Block followchain with 0 Parameters and 0 Extra Stack Longs. Method 21
pri followchain : r

Local Parameter DBASE:0000 - r
|===========================================================================|
254                         r := brclust(readfat(fclust))
Addr : 275C:             00  : Drop Anchor Push 
Addr : 275D:             00  : Drop Anchor Push 
Addr : 275E:             40  : Variable Operation Global Offset - 0 Read
Addr : 275F:          05 14  : Call Sub 20   
Addr : 2761:          05 0E  : Call Sub 14   
Addr : 2763:             61  : Variable Operation Local Offset - 0 Write
255                         writelink := fatptr
Addr : 2764:          C8 20  : Memory Op Long VBASE + READ Address = 0020
Addr : 2766:             5D  : Variable Operation Global Offset - 7 Write
Addr : 2767:             32  : Return        
|===========================================================================|
Spin Block nextcluster with 0 Parameters and 0 Extra Stack Longs. Method 22
pri nextcluster : r

Local Parameter DBASE:0000 - r
|===========================================================================|
263                         r := followchain
Addr : 2768:             00  : Drop Anchor Push 
Addr : 2769:          05 15  : Call Sub 21   
Addr : 276B:             61  : Variable Operation Local Offset - 0 Write
264                         if (r < 2 or r => totclusters)
Addr : 276C:             60  : Variable Operation Local Offset - 0 Read
Addr : 276D:          37 00  : Constant Mask Y=0 00000002 2
Addr : 276F:             F9  : Math Op <     
Addr : 2770:             60  : Variable Operation Local Offset - 0 Read
Addr : 2771:       C4 80 8C  : Memory Op Long PBASE + READ Address = 008C
Addr : 2774:             FE  : Math Op =>    
Addr : 2775:             F2  : Math Op OR    
Addr : 2776: JZ Label0003
Addr : 2776:          0A 03  : jz Address = 277B 3
265                            abort(-9) ' bad cluster value
Addr : 2778:          37 42  : Constant Mask Y=66 Invert FFFFFFF7 4294967287
Addr : 277A:             31  : Abort value   
Addr : 277B: Label0003
Addr : 277B: Label0004
Addr : 277B:             32  : Return        
|===========================================================================|
Spin Block freeclusters with 1 Parameters and 1 Extra Stack Longs. Method 23
pri freeclusters(clust) | bp

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - clust
Local Variable  DBASE:0008 - bp
|===========================================================================|
Addr : 277C: Label0003
# Source File : lib/fsrw.spin
272                         repeat while (clust < endofchain)
Addr : 277C:             64  : Variable Operation Local Offset - 1 Read
Addr : 277D:       C4 80 94  : Memory Op Long PBASE + READ Address = 0094
Addr : 2780:             F9  : Math Op <     
Addr : 2781: JZ Label0005
Addr : 2781:          0A 1B  : jz Address = 279E 27
273                            if (clust < 2)
Addr : 2783:             64  : Variable Operation Local Offset - 1 Read
Addr : 2784:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2786:             F9  : Math Op <     
Addr : 2787: JZ Label0006
Addr : 2787:          0A 04  : jz Address = 278D 4
274                               abort(-26) ' bad cluster number")
Addr : 2789:          38 19  : Constant 1 Bytes - 19 - $00000019 25
Addr : 278B:             E7  : Math Op !     
Addr : 278C:             31  : Abort value   
Addr : 278D: Label0006
Addr : 278D: Label0007
275                            bp := readfat(clust)
Addr : 278D:             00  : Drop Anchor Push 
Addr : 278E:             64  : Variable Operation Local Offset - 1 Read
Addr : 278F:          05 14  : Call Sub 20   
Addr : 2791:             69  : Variable Operation Local Offset - 2 Write
276                            clust := brclust(bp)
Addr : 2792:             00  : Drop Anchor Push 
Addr : 2793:             68  : Variable Operation Local Offset - 2 Read
Addr : 2794:          05 0E  : Call Sub 14   
Addr : 2796:             65  : Variable Operation Local Offset - 1 Write
277                            brwclust(bp, 0)
Addr : 2797:             01  : Drop Anchor   
Addr : 2798:             68  : Variable Operation Local Offset - 2 Read
Addr : 2799:             35  : Constant 1 $00000000
Addr : 279A:          05 11  : Call Sub 17   
Addr : 279C: Label0004
Addr : 279C: JMP Label0003
Addr : 279C:          04 5E  : Jmp 277C -34  
Addr : 279E: Label0005
278                         flushifdirty
Addr : 279E:             01  : Drop Anchor   
Addr : 279F:          05 0A  : Call Sub 10   
Addr : 27A1:             32  : Return        
|===========================================================================|
Spin Block datablock with 0 Parameters and 0 Extra Stack Longs. Method 24
pri datablock

Local Parameter DBASE:0000 - Result
|===========================================================================|
283                         return (fclust << clustershift) + dataregion + ((floc >> SECTORSHIFT) & ((1 << clustershift) - 1))
Addr : 27A2:             40  : Variable Operation Global Offset - 0 Read
Addr : 27A3:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 27A6:             E3  : Math Op <<    
Addr : 27A7:          C4 7C  : Memory Op Long PBASE + READ Address = 007C
Addr : 27A9:             EC  : Math Op +     
Addr : 27AA:             48  : Variable Operation Global Offset - 2 Read
Addr : 27AB:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 27AD:             E2  : Math Op >>    
Addr : 27AE:             36  : Constant 2 $00000001
Addr : 27AF:       C4 80 80  : Memory Op Long PBASE + READ Address = 0080
Addr : 27B2:             E3  : Math Op <<    
Addr : 27B3:             36  : Constant 2 $00000001
Addr : 27B4:             ED  : Math Op -     
Addr : 27B5:             E8  : Math Op &     
Addr : 27B6:             EC  : Math Op +     
Addr : 27B7:             33  : Return value  
Addr : 27B8: Data : 32                       2
|===========================================================================|
Spin Block uc with 1 Parameters and 0 Extra Stack Longs. Method 25
pri uc(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
288                         if ("a" =< c and c =< "z")
Addr : 27B9:          38 61  : Constant 1 Bytes - 61 - $00000061 97
Addr : 27BB:             64  : Variable Operation Local Offset - 1 Read
Addr : 27BC:             FD  : Math Op =<    
Addr : 27BD:             64  : Variable Operation Local Offset - 1 Read
Addr : 27BE:          38 7A  : Constant 1 Bytes - 7A - $0000007A 122
Addr : 27C0:             FD  : Math Op =<    
Addr : 27C1:             F0  : Math Op AND   
Addr : 27C2: JZ Label0003
Addr : 27C2:          0A 05  : jz Address = 27C9 5
289                            return c - 32
Addr : 27C4:             64  : Variable Operation Local Offset - 1 Read
Addr : 27C5:          37 04  : Constant Mask Y=4 00000020 32
Addr : 27C7:             ED  : Math Op -     
Addr : 27C8:             33  : Return value  
Addr : 27C9: Label0003
Addr : 27C9: Label0004
290                         return c
Addr : 27C9:             64  : Variable Operation Local Offset - 1 Read
Addr : 27CA:             33  : Return value  
Addr : 27CB: Data : 32                       2
|===========================================================================|
Spin Block pflushbuf with 2 Parameters and 4 Extra Stack Longs. Method 26
pri pflushbuf(rcnt, metadata) : r | cluststart, newcluster, count, i

Local Parameter DBASE:0000 - r
Local Parameter DBASE:0004 - rcnt
Local Parameter DBASE:0008 - metadata
Local Variable  DBASE:000C - cluststart
Local Variable  DBASE:0010 - newcluster
Local Variable  DBASE:0014 - count
Local Variable  DBASE:0018 - i
|===========================================================================|
298                         if (direntry == 0)
Addr : 27CC:             58  : Variable Operation Global Offset - 6 Read
Addr : 27CD:             35  : Constant 1 $00000000
Addr : 27CE:             FC  : Math Op ==    
Addr : 27CF: JZ Label0003
Addr : 27CF:          0A 04  : jz Address = 27D5 4
299                            abort(-27) ' not open for writing
Addr : 27D1:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 27D3:             E7  : Math Op !     
Addr : 27D4:             31  : Abort value   
Addr : 27D5: Label0003
Addr : 27D5: Label0004
300                         if (rcnt > 0) ' must *not* allocate cluster if flushing an empty buffer
Addr : 27D5:             64  : Variable Operation Local Offset - 1 Read
Addr : 27D6:             35  : Constant 1 $00000000
Addr : 27D7:             FA  : Math Op >     
Addr : 27D8: JZ Label0005
Addr : 27D8:       0A 80 F9  : jz Address = 28D4 249
301                            if (frem < SECTORSIZE)
Addr : 27DB:             4C  : Variable Operation Global Offset - 3 Read
Addr : 27DC:          37 08  : Constant Mask Y=8 00000200 512
Addr : 27DE:             F9  : Math Op <     
Addr : 27DF: JZ Label0007
Addr : 27DF:       0A 80 D3  : jz Address = 28B5 211
304                               newcluster := -1
Addr : 27E2:             34  : Constant 0 $FFFFFFFF
Addr : 27E3:             71  : Variable Operation Local Offset - 4 Write
305                               cluststart := fclust & (!((SECTORSIZE >> filesystem) - 1))
Addr : 27E4:             40  : Variable Operation Global Offset - 0 Read
Addr : 27E5:          37 08  : Constant Mask Y=8 00000200 512
Addr : 27E7:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 27E9:             E2  : Math Op >>    
Addr : 27EA:             36  : Constant 2 $00000001
Addr : 27EB:             ED  : Math Op -     
Addr : 27EC:             E7  : Math Op !     
Addr : 27ED:             E8  : Math Op &     
Addr : 27EE:             6D  : Variable Operation Local Offset - 3 Write
306                               count := 2
Addr : 27EF:          37 00  : Constant Mask Y=0 00000002 2
Addr : 27F1:             75  : Variable Operation Local Offset - 5 Write
Addr : 27F2: Label0009
308                                  readfat(cluststart)
Addr : 27F2:             01  : Drop Anchor   
Addr : 27F3:             6C  : Variable Operation Local Offset - 3 Read
Addr : 27F4:          05 14  : Call Sub 20   
309                                  repeat i from 0 to SECTORSIZE - 1<<filesystem step 1<<filesystem
Addr : 27F6:             35  : Constant 1 $00000000
Addr : 27F7:             79  : Variable Operation Local Offset - 6 Write
Addr : 27F8: Label000C
310                                    if (buf2[i] == 0)
Addr : 27F8:             78  : Variable Operation Local Offset - 6 Read
Addr : 27F9:       94 80 A4  : Memory Op Byte PBASE + POP Index READ Address = 00A4
Addr : 27FC:             35  : Constant 1 $00000000
Addr : 27FD:             FC  : Math Op ==    
Addr : 27FE: JZ Label000F
Addr : 27FE:          0A 1E  : jz Address = 281E 30
311                                      if (brclust(@buf2+i) == 0)
Addr : 2800:             00  : Drop Anchor Push 
Addr : 2801:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2804:             78  : Variable Operation Local Offset - 6 Read
Addr : 2805:             EC  : Math Op +     
Addr : 2806:          05 0E  : Call Sub 14   
Addr : 2808:             35  : Constant 1 $00000000
Addr : 2809:             FC  : Math Op ==    
Addr : 280A: JZ Label0011
Addr : 280A:          0A 12  : jz Address = 281E 18
312                                         newcluster := cluststart + (i >> filesystem)
Addr : 280C:             6C  : Variable Operation Local Offset - 3 Read
Addr : 280D:             78  : Variable Operation Local Offset - 6 Read
Addr : 280E:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2810:             E2  : Math Op >>    
Addr : 2811:             EC  : Math Op +     
Addr : 2812:             71  : Variable Operation Local Offset - 4 Write
313                                         if (newcluster => totclusters)
Addr : 2813:             70  : Variable Operation Local Offset - 4 Read
Addr : 2814:       C4 80 8C  : Memory Op Long PBASE + READ Address = 008C
Addr : 2817:             FE  : Math Op =>    
Addr : 2818: JZ Label0013
Addr : 2818:          0A 02  : jz Address = 281C 2
314                                            newcluster := -1
Addr : 281A:             34  : Constant 0 $FFFFFFFF
Addr : 281B:             71  : Variable Operation Local Offset - 4 Write
Addr : 281C: Label0013
Addr : 281C: Label0014
Addr : 281C: JMP Label000E
Addr : 281C:          04 0F  : Jmp 282D 15   
Addr : 281E: Label0011
Addr : 281E: Label0012
Addr : 281E: Label000F
Addr : 281E: Label0010
Addr : 281E: Label000D
309                                  repeat i from 0 to SECTORSIZE - 1<<filesystem step 1<<filesystem
Addr : 281E:             36  : Constant 2 $00000001
Addr : 281F:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2821:             E3  : Math Op <<    
Addr : 2822:             35  : Constant 1 $00000000
Addr : 2823:          37 08  : Constant Mask Y=8 00000200 512
Addr : 2825:             36  : Constant 2 $00000001
Addr : 2826:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2828:             E3  : Math Op <<    
Addr : 2829:             ED  : Math Op -     
Addr : 282A: Repeat i Step Label000C
Addr : 282A:       7A 06 4B  : Variable Operation Local Offset - 6 Assign Repeat-Var loop (pop step) Address= 27F8 -53
Addr : 282D: Label000E
316                                  if (newcluster > 1)
Addr : 282D:             70  : Variable Operation Local Offset - 4 Read
Addr : 282E:             36  : Constant 2 $00000001
Addr : 282F:             FA  : Math Op >     
Addr : 2830: JZ Label0015
Addr : 2830:       0A 80 63  : jz Address = 2896 99
317                                     brwclust(@buf2+i, endofchain+$f)
Addr : 2833:             01  : Drop Anchor   
Addr : 2834:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2837:             78  : Variable Operation Local Offset - 6 Read
Addr : 2838:             EC  : Math Op +     
Addr : 2839:       C4 80 94  : Memory Op Long PBASE + READ Address = 0094
Addr : 283C:          37 23  : Constant Mask Y=35 Decrement 0000000F 15
Addr : 283E:             EC  : Math Op +     
Addr : 283F:          05 11  : Call Sub 17   
318                                     if (writelink == 0)
Addr : 2841:             5C  : Variable Operation Global Offset - 7 Read
Addr : 2842:             35  : Constant 1 $00000000
Addr : 2843:             FC  : Math Op ==    
Addr : 2844: JZ Label0017
Addr : 2844:          0A 39  : jz Address = 287F 57
319                                        brwword(readbytec(direntry)+$1a, newcluster)
Addr : 2846:             01  : Drop Anchor   
Addr : 2847:             00  : Drop Anchor Push 
Addr : 2848:             58  : Variable Operation Global Offset - 6 Read
Addr : 2849:          05 13  : Call Sub 19   
Addr : 284B:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 284D:             EC  : Math Op +     
Addr : 284E:             70  : Variable Operation Local Offset - 4 Read
Addr : 284F:          05 0F  : Call Sub 15   
320                                        writelink := (direntry&(SECTORSIZE-filesystem))
Addr : 2851:             58  : Variable Operation Global Offset - 6 Read
Addr : 2852:          37 08  : Constant Mask Y=8 00000200 512
Addr : 2854:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2856:             ED  : Math Op -     
Addr : 2857:             E8  : Math Op &     
Addr : 2858:             5D  : Variable Operation Global Offset - 7 Write
321                                        brwlong(@buf2+writelink+$1c, floc+bufat)
Addr : 2859:             01  : Drop Anchor   
Addr : 285A:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 285D:             5C  : Variable Operation Global Offset - 7 Read
Addr : 285E:             EC  : Math Op +     
Addr : 285F:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
Addr : 2861:             EC  : Math Op +     
Addr : 2862:             48  : Variable Operation Global Offset - 2 Read
Addr : 2863:             50  : Variable Operation Global Offset - 4 Read
Addr : 2864:             EC  : Math Op +     
Addr : 2865:          05 10  : Call Sub 16   
322                                        if (filesystem == 2)
Addr : 2867:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 2869:          37 00  : Constant Mask Y=0 00000002 2
Addr : 286B:             FC  : Math Op ==    
Addr : 286C: JZ Label0019
Addr : 286C:          0A 0F  : jz Address = 287D 15
323                                           brwword(@buf2+writelink+$14, newcluster>>16)
Addr : 286E:             01  : Drop Anchor   
Addr : 286F:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 2872:             5C  : Variable Operation Global Offset - 7 Read
Addr : 2873:             EC  : Math Op +     
Addr : 2874:          38 14  : Constant 1 Bytes - 14 - $00000014 20
Addr : 2876:             EC  : Math Op +     
Addr : 2877:             70  : Variable Operation Local Offset - 4 Read
Addr : 2878:          37 03  : Constant Mask Y=3 00000010 16
Addr : 287A:             E2  : Math Op >>    
Addr : 287B:          05 0F  : Call Sub 15   
Addr : 287D: Label0019
Addr : 287D: Label001A
Addr : 287D: JMP Label0018
Addr : 287D:          04 08  : Jmp 2887 8    
Addr : 287F: Label0017
325                                        brwclust(readbytec(writelink), newcluster)
Addr : 287F:             01  : Drop Anchor   
Addr : 2880:             00  : Drop Anchor Push 
Addr : 2881:             5C  : Variable Operation Global Offset - 7 Read
Addr : 2882:          05 13  : Call Sub 19   
Addr : 2884:             70  : Variable Operation Local Offset - 4 Read
Addr : 2885:          05 11  : Call Sub 17   
Addr : 2887: Label001B
Addr : 2887: Label0018
326                                     writelink := fatptr + i
Addr : 2887:          C8 20  : Memory Op Long VBASE + READ Address = 0020
Addr : 2889:             78  : Variable Operation Local Offset - 6 Read
Addr : 288A:             EC  : Math Op +     
Addr : 288B:             5D  : Variable Operation Global Offset - 7 Write
327                                     fclust := newcluster
Addr : 288C:             70  : Variable Operation Local Offset - 4 Read
Addr : 288D:             41  : Variable Operation Global Offset - 0 Write
328                                     frem := clustersize
Addr : 288E:       C4 80 84  : Memory Op Long PBASE + READ Address = 0084
Addr : 2891:             4D  : Variable Operation Global Offset - 3 Write
Addr : 2892: JMP Label000B
Addr : 2892:          04 21  : Jmp 28B5 33   
Addr : 2894: JMP Label0016
Addr : 2894:          04 1C  : Jmp 28B2 28   
Addr : 2896: Label0015
Addr : 2896:          37 08  : Constant Mask Y=8 00000200 512
331                                     cluststart += (SECTORSIZE >> filesystem)
Addr : 2898:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 289A:             E2  : Math Op >>    
Addr : 289B:          6E 4C  : Variable Operation Local Offset - 3 Assign WordMathop +
332                                     if (cluststart => totclusters)
Addr : 289D:             6C  : Variable Operation Local Offset - 3 Read
Addr : 289E:       C4 80 8C  : Memory Op Long PBASE + READ Address = 008C
Addr : 28A1:             FE  : Math Op =>    
Addr : 28A2: JZ Label001D
Addr : 28A2:          0A 0E  : jz Address = 28B2 14
333                                        cluststart := 0
Addr : 28A4:             35  : Constant 1 $00000000
Addr : 28A5:             6D  : Variable Operation Local Offset - 3 Write
334                                        count--
Addr : 28A6:          76 3E  : Variable Operation Local Offset - 5 Assign VAR-- post-dec Long
335                                        if (rcnt < 0)
Addr : 28A8:             64  : Variable Operation Local Offset - 1 Read
Addr : 28A9:             35  : Constant 1 $00000000
Addr : 28AA:             F9  : Math Op <     
Addr : 28AB: JZ Label001F
Addr : 28AB:          0A 05  : jz Address = 28B2 5
336                                           rcnt := -5 ' No space left on device
Addr : 28AD:          37 41  : Constant Mask Y=65 Invert FFFFFFFB 4294967291
Addr : 28AF:             65  : Variable Operation Local Offset - 1 Write
Addr : 28B0: JMP Label000B
Addr : 28B0:          04 03  : Jmp 28B5 3    
Addr : 28B2: Label001F
Addr : 28B2: Label0020
Addr : 28B2: Label001D
Addr : 28B2: Label001E
Addr : 28B2: Label001C
Addr : 28B2: Label0016
Addr : 28B2: Label000A
Addr : 28B2: JMP Label0009
Addr : 28B2:       04 FF 3D  : Jmp 27F2 -195 
Addr : 28B5: Label000B
Addr : 28B5: Label0007
Addr : 28B5: Label0008
338                            if (frem => SECTORSIZE)
Addr : 28B5:             4C  : Variable Operation Global Offset - 3 Read
Addr : 28B6:          37 08  : Constant Mask Y=8 00000200 512
Addr : 28B8:             FE  : Math Op =>    
Addr : 28B9: JZ Label0021
Addr : 28B9:          0A 19  : jz Address = 28D4 25
339                               sdspi.writeblock(datablock, @buf)
Addr : 28BB:             01  : Drop Anchor   
Addr : 28BC:             00  : Drop Anchor Push 
Addr : 28BD:          05 18  : Call Sub 24   
Addr : 28BF:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 28C1:       06 1B 02  : Call Obj.Sub 27 2
340                               if (rcnt == SECTORSIZE) ' full buffer, clear it
Addr : 28C4:             64  : Variable Operation Local Offset - 1 Read
Addr : 28C5:          37 08  : Constant Mask Y=8 00000200 512
Addr : 28C7:             FC  : Math Op ==    
Addr : 28C8: JZ Label0023
Addr : 28C8:          0A 0A  : jz Address = 28D4 10
341                                  floc += rcnt
Addr : 28CA:             64  : Variable Operation Local Offset - 1 Read
Addr : 28CB:          4A 4C  : Variable Operation Global Offset - 2 Assign WordMathop +
342                                  frem -= rcnt
Addr : 28CD:             64  : Variable Operation Local Offset - 1 Read
Addr : 28CE:          4E 4D  : Variable Operation Global Offset - 3 Assign WordMathop -
343                                  bufat := 0
Addr : 28D0:             35  : Constant 1 $00000000
Addr : 28D1:             51  : Variable Operation Global Offset - 4 Write
344                                  bufend := rcnt
Addr : 28D2:             64  : Variable Operation Local Offset - 1 Read
Addr : 28D3:             55  : Variable Operation Global Offset - 5 Write
Addr : 28D4: Label0023
Addr : 28D4: Label0024
Addr : 28D4: Label0021
Addr : 28D4: Label0022
Addr : 28D4: Label0005
Addr : 28D4: Label0006
345                         if (rcnt < 0 or metadata) ' update metadata even if error
Addr : 28D4:             64  : Variable Operation Local Offset - 1 Read
Addr : 28D5:             35  : Constant 1 $00000000
Addr : 28D6:             F9  : Math Op <     
Addr : 28D7:             68  : Variable Operation Local Offset - 2 Read
Addr : 28D8:             F2  : Math Op OR    
Addr : 28D9: JZ Label0025
Addr : 28D9:          0A 1E  : jz Address = 28F9 30
346                            readblockc(direntry >> SECTORSHIFT) ' flushes unwritten FAT too
Addr : 28DB:             01  : Drop Anchor   
Addr : 28DC:             58  : Variable Operation Global Offset - 6 Read
Addr : 28DD:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 28DF:             E2  : Math Op >>    
Addr : 28E0:          05 0B  : Call Sub 11   
347                            brwlong(@buf2+(direntry & (SECTORSIZE-filesystem))+$1c, floc+bufat)
Addr : 28E2:             01  : Drop Anchor   
Addr : 28E3:       87 80 A4  : Memory Op Byte PBASE + ADDRESS Address = 00A4
Addr : 28E6:             58  : Variable Operation Global Offset - 6 Read
Addr : 28E7:          37 08  : Constant Mask Y=8 00000200 512
Addr : 28E9:          C4 70  : Memory Op Long PBASE + READ Address = 0070
Addr : 28EB:             ED  : Math Op -     
Addr : 28EC:             E8  : Math Op &     
Addr : 28ED:             EC  : Math Op +     
Addr : 28EE:          38 1C  : Constant 1 Bytes - 1C - $0000001C 28
Addr : 28F0:             EC  : Math Op +     
Addr : 28F1:             48  : Variable Operation Global Offset - 2 Read
Addr : 28F2:             50  : Variable Operation Global Offset - 4 Read
Addr : 28F3:             EC  : Math Op +     
Addr : 28F4:          05 10  : Call Sub 16   
348                            flushifdirty
Addr : 28F6:             01  : Drop Anchor   
Addr : 28F7:          05 0A  : Call Sub 10   
Addr : 28F9: Label0025
Addr : 28F9: Label0026
349                         if (rcnt < 0)
Addr : 28F9:             64  : Variable Operation Local Offset - 1 Read
Addr : 28FA:             35  : Constant 1 $00000000
Addr : 28FB:             F9  : Math Op <     
Addr : 28FC: JZ Label0027
Addr : 28FC:          0A 02  : jz Address = 2900 2
350                            abort(rcnt)
Addr : 28FE:             64  : Variable Operation Local Offset - 1 Read
Addr : 28FF:             31  : Abort value   
Addr : 2900: Label0027
Addr : 2900: Label0028
351                         return rcnt
Addr : 2900:             64  : Variable Operation Local Offset - 1 Read
Addr : 2901:             33  : Return value  
Addr : 2902: Data : 32                       2
|===========================================================================|
Object safe_spi
Object Base is 2904
|===========================================================================|
Object Constants
|===========================================================================|
Object DAT Blocks
|===========================================================================|
2930(0000) 00 00 00 00 | SPI_engine_cog          long 0
2934(0001) 00 00 00 00 | SPI_command             long 0  ' "t", "r", "w", 0 =>done, <0 => error          | unused
2938(0002) 00 00 00 00 | SPI_block_index         long 0  ' which 512-byte block to read/write            | cnt at init
293C(0003) 00 00 00 00 | SPI_buffer_address      long 0  ' where to get/put the data in Hub RAM          | unused
2940(0004)             | ORG 0
2940(0000)             | SPI_engine_entry
2940(0000) 2F F1 BF A0 |         mov ctra,writeMode
2944(0001) 31 F3 BF A0 |         mov ctrb,clockLineMode
2948(0002) 2B ED BF A0 |         mov dira,maskAll
294C(0003) 01 80 FE A4 |         neg user_request,#1
2950(0004) F0 81 3E 08 |         wrlong user_request,par
2954(0005) F1 8B BE A0 |         mov last_time,cnt
2958(0006)             | waiting_for_command
2958(0006) A4 66 FD 5C |         call #handle_time
295C(0007) F0 81 BE 08 |         rdlong user_request,par
2960(0008) 00 80 7E C3 |         cmps user_request,#0 wz,wc
2964(0009) 06 00 78 5C | if_be   jmp #waiting_for_command
2968(000A) 72 80 7E 86 |         cmp user_request,#"r" wz
296C(000B) 1D 00 68 5C | if_z    jmp #read_ahead
2970(000C) 77 80 7E 86 |         cmp user_request,#"w" wz
2974(000D) 2D 00 68 5C | if_z    jmp #write_behind
2978(000E) 7A 80 7E 86 |         cmp user_request,#"z" wz
297C(000F) 16 00 68 5C | if_z    jmp #release_card
2980(0010) 74 80 7E 86 |         cmp user_request,#"t" wz    ' time
2984(0011) 2E 6F 2A 08 | if_z    wrlong seconds,sdAdr    ' seconds goes into the SD index register
2988(0012) 2D 71 2A 08 | if_z    wrlong dtime,bufAdr     ' the remainder goes into the buffer address register
298C(0013) 00 80 FE A0 |         mov user_request,#0
2990(0014) F0 81 3E 08 |         wrlong user_request,par
2994(0015) 06 00 7C 5C |         jmp #waiting_for_command
2998(0016)             | release_card
2998(0016) 7A 82 FE A0 |         mov user_cmd,#"z"       ' request a release 
299C(0017) 01 76 FE A4 |         neg lastIndexPlus,#1    ' reset the last block index 
29A0(0018) 01 84 FE A4 |         neg user_idx,#1         ' and make this match it 
29A4(0019) 35 96 FC 5C |         call #handle_command
29A8(001A) 41 81 BE A0 |         mov user_request,user_cmd
29AC(001B) F0 81 3E 08 |         wrlong user_request,par
29B0(001C) 06 00 7C 5C |         jmp #waiting_for_command
29B4(001D)             | read_ahead
29B4(001D) 2E 85 BE 08 |         rdlong user_idx,sdAdr
29B8(001E) 42 7F BE A0 |         mov tmp1,user_idx
29BC(001F) 01 7E FE 80 |         add tmp1,#1
29C0(0020) 3B 7F 3E 86 |         cmp tmp1,lastIndexPlus wz
29C4(0021) 72 78 6A 86 | if_z    cmp lastCommand,#"r" wz
29C8(0022) 25 00 68 5C | if_z    jmp #:get_on_with_it
29CC(0023) 72 82 FE A0 |         mov user_cmd,#"r"
29D0(0024) 35 96 FC 5C |         call #handle_command
29D4(0025)             | :get_on_with_it
29D4(0025) 10 78 FD 58 |         movi transfer_long,#%000010_000 'set to wrlong
29D8(0026) B4 8A FD 5C |         call #hub_cog_transfer
29DC(0027) 41 81 BE A0 |         mov user_request,user_cmd
29E0(0028) F0 81 3E 08 |         wrlong user_request,par
29E4(0029) 72 82 FE A0 |         mov user_cmd,#"r"
29E8(002A) 01 84 FE 80 |         add user_idx,#1
29EC(002B) 35 96 FC 5C |         call #handle_command
29F0(002C) 06 00 7C 5C |         jmp #waiting_for_command
29F4(002D)             | write_behind
29F4(002D) 2E 85 BE 08 |         rdlong user_idx,sdAdr
29F8(002E) 11 78 FD 58 |         movi transfer_long,#%000010_001 'set to rdlong
29FC(002F) B4 8A FD 5C |         call #hub_cog_transfer
2A00(0030) 41 81 BE A0 |         mov user_request,user_cmd
2A04(0031) F0 81 3E 08 |         wrlong user_request,par
2A08(0032) 77 82 FE A0 |         mov user_cmd,#"w"
2A0C(0033) 35 96 FC 5C |         call #handle_command
2A10(0034) 06 00 7C 5C |         jmp #waiting_for_command
2A14(0035)             | handle_command
2A14(0035) 42 77 3E 86 |         cmp lastIndexPlus,user_idx wz
2A18(0036) 3C 83 2A 86 | if_z    cmp user_cmd,lastCommand wz
2A1C(0037) 42 00 68 5C | if_z    jmp #:execute_block_command
2A20(0038) 77 78 7E 86 |         cmp lastCommand,#"w" wz
2A24(0039) 5A C4 E8 5C | if_z    call #stop_mb_write
2A28(003A) 72 78 7E 86 |         cmp lastCommand,#"r" wz  
2A2C(003B) 53 AC E8 5C | if_z    call #stop_mb_read
2A30(003C) 77 82 7E 86 |         cmp user_cmd,#"w" wz
2A34(003D) 57 B2 E8 5C | if_z    call #start_mb_write
2A38(003E) 72 82 7E 86 |         cmp user_cmd,#"r" wz
2A3C(003F) 50 A4 E8 5C | if_z    call #start_mb_read
2A40(0040) 7A 82 7E 86 |         cmp user_cmd,#"z" wz
2A44(0041) 4C 9E E8 5C | if_z    call #release_DO
2A48(0042)             | :execute_block_command
2A48(0042) 42 77 BE A0 |         mov lastIndexPlus,user_idx
2A4C(0043) 01 76 FE 80 |         add lastIndexPlus,#1
2A50(0044) 41 79 BE A0 |         mov lastCommand,user_cmd
2A54(0045) 77 82 7E 86 |         cmp user_cmd,#"w" wz
2A58(0046) F0 48 EA 5C | if_z    call #write_single_block
2A5C(0047) 72 82 7E 86 |         cmp user_cmd,#"r" wz
2A60(0048) C6 DE E9 5C | if_z    call #read_single_block
2A64(0049) 7A 82 7E 86 |         cmp user_cmd,#"z" wz
2A68(004A) 00 82 EA A0 | if_z    mov user_cmd,#0
2A6C(004B)             | handle_command_ret
2A6C(004B) 00 00 7C 5C |         ret   
2A70(004C)             | release_DO
2A70(004C) 2A E9 BF 68 |         or outa,maskCS
2A74(004D) 8D 46 FD 5C |         call #in8
2A78(004E) 8D 46 FD 5C |         call #in8
2A7C(004F)             | release_DO_ret
2A7C(004F) 00 00 7C 5C |         ret
2A80(0050)             | start_mb_read  
2A80(0050) A4 86 FE 58 |         movi block_cmd,#CMD18<<1
2A84(0051) 63 F6 FC 5C |         call #send_SPI_command_fast       
2A88(0052)             | start_mb_read_ret
2A88(0052) 00 00 7C 5C |         ret
2A8C(0053)             | stop_mb_read
2A8C(0053) 98 86 FE 58 |         movi block_cmd,#CMD12<<1
2A90(0054) 63 F6 FC 5C |         call #send_SPI_command_fast
2A94(0055) 7C 00 FD 5C |         call #busy_fast
2A98(0056)             | stop_mb_read_ret
2A98(0056) 00 00 7C 5C |         ret
2A9C(0057)             | start_mb_write  
2A9C(0057) B2 86 FE 58 |         movi block_cmd,#CMD25<<1
2AA0(0058) 63 F6 FC 5C |         call #send_SPI_command_fast
2AA4(0059)             | start_mb_write_ret
2AA4(0059) 00 00 7C 5C |         ret
2AA8(005A)             | stop_mb_write
2AA8(005A) 7C 00 FD 5C |         call #busy_fast
2AAC(005B) 10 7E FE A0 |         mov tmp1,#16
2AB0(005C)             | :loopity
2AB0(005C) 8D 46 FD 5C |         call #in8         
2AB4(005D) 5C 7E FE E4 |         djnz tmp1,#:loopity
2AB8(005E) FA F9 FF 58 |         movi phsa,#$FD<<1
2ABC(005F) 81 18 FD 5C |         call #out8
2AC0(0060) 8D 46 FD 5C |         call #in8       ' stuff byte
2AC4(0061) 7C 00 FD 5C |         call #busy_fast
2AC8(0062)             | stop_mb_write_ret
2AC8(0062) 00 00 7C 5C |         ret
2ACC(0063)             | send_SPI_command_fast
2ACC(0063) 2B ED BF A0 |         mov dira,maskAll
2AD0(0064) 2A E9 BF 68 |         or outa,maskCS  
2AD4(0065) 2A E9 BF 64 |         andn outa,maskCS
2AD8(0066) 8D 46 FD 5C |         call #in8 
2ADC(0067) 43 F9 BF A0 |         mov phsa,block_cmd                      ' do which ever block command this is (already in the top 8 bits)
2AE0(0068) 81 18 FD 5C |         call #out8                               ' write the byte
2AE4(0069) 42 F9 BF A0 |         mov phsa,user_idx                       ' read in the desired block index
2AE8(006A) 2C F9 BF 2C |         shl phsa,adrShift                       ' this will multiply by 512 (bytes/sector) for MMC and SD
2AEC(006B) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
2AF0(006C) 01 F8 FF 24 |         rol phsa,#1
2AF4(006D) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
2AF8(006E) 01 F8 FF 24 |         rol phsa,#1
2AFC(006F) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
2B00(0070) 01 F8 FF 24 |         rol phsa,#1
2B04(0071) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
2B08(0072) 8D 46 FD 5C |         call #in8                                ' in8 looks like out8 with $FF
2B0C(0073) 18 86 FE 28 |         shr block_cmd,#24
2B10(0074) 4C 86 7E 86 |         cmp block_cmd,#CMD12 wz
2B14(0075) 8D 46 E9 5C | if_z    call #in8                               ' 8 clocks
2B18(0076) 09 7E FE A0 |         mov tmp1,#9
2B1C(0077)             | :cmd_response
2B1C(0077) 8D 46 FD 5C |         call #in8
2B20(0078) 80 7C 7E 63 |         test readback,#$80 wc,wz
2B24(0079) 77 7E F2 E4 | if_c    djnz tmp1,#:cmd_response
2B28(007A) 3E 83 96 A4 | if_nz   neg user_cmd,readback
2B2C(007B)             | send_SPI_command_fast_ret
2B2C(007B) 00 00 7C 5C |         ret    
2B30(007C)             | busy_fast
2B30(007C) 30 7F BE A0 |         mov tmp1,N_in8_500ms
2B34(007D)             | :still_busy
2B34(007D) 8D 46 FD 5C |         call #in8
2B38(007E) FF 7C 7E 86 |         cmp readback,#$FF wz
2B3C(007F) 7D 7E D6 E4 | if_nz   djnz tmp1,#:still_busy
2B40(0080)             | busy_fast_ret
2B40(0080) 00 00 7C 5C |         ret
2B44(0081)             | out8
2B44(0081) 29 E9 BF 64 |         andn outa,maskDI 
2B48(0082) 00 FA FF A0 |         mov phsb,#0
2B4C(0083) 80 F6 FF 58 |         movi frqb,#%01_0000000        
2B50(0084) 01 F8 FF 24 |         rol phsa,#1
2B54(0085) 01 F8 FF 24 |         rol phsa,#1
2B58(0086) 01 F8 FF 24 |         rol phsa,#1
2B5C(0087) 01 F8 FF 24 |         rol phsa,#1
2B60(0088) 01 F8 FF 24 |         rol phsa,#1
2B64(0089) 01 F8 FF 24 |         rol phsa,#1
2B68(008A) 01 F8 FF 24 |         rol phsa,#1
2B6C(008B) 00 F6 FF A0 |         mov frqb,#0
2B70(008C)             | out8_ret
2B70(008C) 00 00 7C 5C |         ret
2B74(008D)             | in8
2B74(008D) 01 F8 FF A4 |         neg phsa,#1' DI high
2B78(008E) 00 7C FE A0 |         mov readback,#0
2B7C(008F) C0 FA FF 58 |         movi phsb,#%011_000000
2B80(0090) 40 F6 FF 58 |         movi frqb,#%001_000000
2B84(0091) F2 51 3E 61 |         test maskDO,ina wc
2B88(0092) 01 7C FE 34 |         rcl readback,#1
2B8C(0093) F2 51 3E 61 |         test maskDO,ina wc
2B90(0094) 01 7C FE 34 |         rcl readback,#1
2B94(0095) F2 51 3E 61 |         test maskDO,ina wc
2B98(0096) 01 7C FE 34 |         rcl readback,#1
2B9C(0097) F2 51 3E 61 |         test maskDO,ina wc
2BA0(0098) 01 7C FE 34 |         rcl readback,#1
2BA4(0099) F2 51 3E 61 |         test maskDO,ina wc
2BA8(009A) 01 7C FE 34 |         rcl readback,#1
2BAC(009B) F2 51 3E 61 |         test maskDO,ina wc
2BB0(009C) 01 7C FE 34 |         rcl readback,#1
2BB4(009D) F2 51 3E 61 |         test maskDO,ina wc
2BB8(009E) 01 7C FE 34 |         rcl readback,#1
2BBC(009F) F2 51 3E 61 |         test maskDO,ina wc
2BC0(00A0) 00 F6 FF A0 |         mov frqb,#0 ' stop the clock
2BC4(00A1) 01 7C FE 34 |         rcl readback,#1
2BC8(00A2) 00 F8 FF A0 |         mov phsa,#0 'DI low
2BCC(00A3)             | in8_ret
2BCC(00A3) 00 00 7C 5C |         ret
2BD0(00A4)             | handle_time        
2BD0(00A4) F1 7F BE A0 |         mov tmp1,cnt            ' get the current timestamp
2BD4(00A5) 3F 73 BE 80 |         add idle_time,tmp1      ' add the current time to my idle time counter
2BD8(00A6) 45 73 BE 84 |         sub idle_time,last_time ' subtract the last time from my idle counter (hence delta)    
2BDC(00A7) 3F 71 BE 80 |         add dtime,tmp1          ' add to my accumulator, 
2BE0(00A8) 45 71 BE 84 |         sub dtime,last_time     ' and subtract the old (adding delta)
2BE4(00A9) 3F 8B BE A0 |         mov last_time,tmp1      ' update my "last timestamp"        
2BE8(00AA) 00 7E FE 08 |         rdlong tmp1,#0          ' what is the clock frequency?
2BEC(00AB) 3F 71 BE E1 |         cmpsub dtime,tmp1 wc    ' if I have more than a second in my accumulator
2BF0(00AC) 00 6E FE C8 |         addx seconds,#0         ' then add it to "seconds"
2BF4(00AD) 3A 73 3E 87 |         cmp idle_time,idle_limit wz,wc
2BF8(00AE) B3 00 70 5C | if_b    jmp #handle_time_ret    ' don't clear if we haven't hit the limit
2BFC(00AF) 7A 82 FE A0 |         mov user_cmd,#"z"       ' we can't overdo it, the command handler makes sure
2C00(00B0) 01 76 FE A4 |         neg lastIndexPlus,#1    ' reset the last block index 
2C04(00B1) 01 84 FE A4 |         neg user_idx,#1         ' and make this match it 
2C08(00B2) 35 96 FC 5C |         call #handle_command    ' release the card, but don't mess with the user's request register
2C0C(00B3)             | handle_time_ret
2C0C(00B3) 00 00 7C 5C |         ret
2C10(00B4)             | hub_cog_transfer
2C10(00B4) 32 F3 BF A0 |         mov ctrb,clockXferMode
2C14(00B5) 01 F6 FF A0 |         mov frqb,#1 
2C18(00B6) 2D 89 BE 08 |         rdlong buf_ptr,bufAdr
2C1C(00B7) 04 7A FE A0 |         mov ops_left,#4
2C20(00B8) 46 79 FD 54 |         movd transfer_long,#speed_buf
2C24(00B9)             | four_transfer_passes
2C24(00B9) 3F 7F BE 08 |         rdlong tmp1,tmp1
2C28(00BA) 20 7E FE A0 |         mov tmp1,#(512 / 4 / 4)
2C2C(00BB) 44 FB BF A0 |         mov phsb,buf_ptr
2C30(00BC)             | transfer_long
2C30(00BC) FD 01 BC 08 |         rdlong 0-0,phsb
2C34(00BD) 35 79 BD 80 |         add transfer_long,incDest4
2C38(00BE) BC 7E FE E4 |         djnz tmp1,#transfer_long
2C3C(00BF) 36 79 BD 84 |         sub transfer_long,decDestNminus1
2C40(00C0) 04 88 FE 80 |         add buf_ptr,#4
2C44(00C1) B9 7A FE E4 |         djnz ops_left,#four_transfer_passes
2C48(00C2) 00 F6 FF A0 |         mov frqb,#0
2C4C(00C3) 00 FA FF A0 |         mov phsb,#0
2C50(00C4) 31 F3 BF A0 |         mov ctrb,clockLineMode
2C54(00C5)             | hub_cog_transfer_ret
2C54(00C5) 00 00 7C 5C |         ret
2C58(00C6)             | read_single_block
2C58(00C6) 46 CD FD 54 |         movd :store_read_long,#speed_buf
2C5C(00C7) 80 7A FE A0 |         mov ops_left,#128
2C60(00C8) 30 7F BE A0 |         mov tmp1,N_in8_500ms
2C64(00C9)             | :get_resp
2C64(00C9) 8D 46 FD 5C |         call #in8
2C68(00CA) FE 7C 7E 86 |         cmp readback,#$FE wz        
2C6C(00CB) C9 7E D6 E4 | if_nz   djnz tmp1,#:get_resp
2C70(00CC) 64 82 D6 A4 | if_nz   neg user_cmd,#ERR_ASM_NO_READ_TOKEN  
2C74(00CD) EF 00 54 5C | if_nz   jmp #read_single_block_ret
2C78(00CE) 01 F8 FF A4 |         neg phsa,#1
2C7C(00CF) 80 7A FE A0 |         mov ops_left,#128
2C80(00D0)             | :read_loop        
2C80(00D0) 04 7E FE A0 |         mov tmp1,#4
2C84(00D1) C0 FA FF 58 |         movi phsb,#%011_000000
2C88(00D2)             | :in_byte        
2C88(00D2) 40 F6 FF 58 |         movi frqb,#%001_000000
2C8C(00D3) F2 51 3E 61 |         test maskDO,ina wc
2C90(00D4) 08 7C FE 34 |         rcl readback,#8
2C94(00D5) F2 51 3E 61 |         test maskDO,ina wc
2C98(00D6) 02 7C FE 70 |         muxc readback,#2
2C9C(00D7) F2 51 3E 61 |         test maskDO,ina wc
2CA0(00D8) 04 7C FE 70 |         muxc readback,#4
2CA4(00D9) F2 51 3E 61 |         test maskDO,ina wc
2CA8(00DA) 08 7C FE 70 |         muxc readback,#8
2CAC(00DB) F2 51 3E 61 |         test maskDO,ina wc
2CB0(00DC) 10 7C FE 70 |         muxc readback,#16
2CB4(00DD) F2 51 3E 61 |         test maskDO,ina wc
2CB8(00DE) 20 7C FE 70 |         muxc readback,#32
2CBC(00DF) F2 51 3E 61 |         test maskDO,ina wc
2CC0(00E0) 40 7C FE 70 |         muxc readback,#64
2CC4(00E1) F2 51 3E 61 |         test maskDO,ina wc
2CC8(00E2) 00 F6 FF A0 |         mov frqb,#0 ' stop the clock
2CCC(00E3) 80 7C FE 70 |         muxc readback,#128
2CD0(00E4) D2 7E FE E4 |         djnz tmp1,#:in_byte
2CD4(00E5) 00 7C FE 3C |         rev readback,#0
2CD8(00E6)             | :store_read_long
2CD8(00E6) 3E 01 BC A0 |         mov 0-0,readback       ' due to some counter weirdness, we need this mov
2CDC(00E7) 33 CD BD 80 |         add :store_read_long,const512
2CE0(00E8) D0 7A FE E4 |         djnz ops_left,#:read_loop
2CE4(00E9) 00 F8 FF A0 |         mov phsa,#0
2CE8(00EA) 8D 46 FD 5C |         call #in8      ' out8 is 2x faster than in8
2CEC(00EB) 8D 46 FD 5C |         call #in8      ' and I'm not using the CRC anyway
2CF0(00EC) 8D 46 FD 5C |         call #in8       ' in8 looks like out8($FF)
2CF4(00ED) 00 72 FE A0 |         mov idle_time,#0
2CF8(00EE) 00 82 FE A0 |         mov user_cmd,#0               
2CFC(00EF)             | read_single_block_ret
2CFC(00EF) 00 00 7C 5C |         ret          
2D00(00F0)             | write_single_block               
2D00(00F0) 46 ED FD 50 |         movs :write_loop,#speed_buf
2D04(00F1) 80 7A FE A0 |         mov ops_left,#128        
2D08(00F2) 7C 00 FD 5C |         call #busy_fast 
2D0C(00F3) F8 F9 FF 58 |         movi phsa,#$FC<<1
2D10(00F4) 81 18 FD 5C |         call #out8
2D14(00F5) 00 FA FF A0 |         mov phsb,#0             ' make sure my clock accumulator is right
2D18(00F6)             | :write_loop
2D18(00F6) 46 F9 BF A0 |         mov phsa,speed_buf
2D1C(00F7) 01 EC FD 80 |         add :write_loop,#1
2D20(00F8) 18 F8 FF 24 |         rol phsa,#24            ' move A7 into position, so I can do the swizzled version
2D24(00F9) 80 F6 FF 58 |         movi frqb,#%010000000   ' start the clock (remember A7 is already in place)
2D28(00FA) 01 F8 FF 24 |         rol phsa,#1             ' A7 is going out, at the end of this instr, A6 is in place
2D2C(00FB) 01 F8 FF 24 |         rol phsa,#1             ' A5
2D30(00FC) 01 F8 FF 24 |         rol phsa,#1             ' A4
2D34(00FD) 01 F8 FF 24 |         rol phsa,#1             ' A3
2D38(00FE) 01 F8 FF 24 |         rol phsa,#1             ' A2
2D3C(00FF) 01 F8 FF 24 |         rol phsa,#1             ' A1
2D40(0100) 01 F8 FF 24 |         rol phsa,#1             ' A0
2D44(0101) 11 F8 FF 24 |         rol phsa,#17            ' B7
2D48(0102) 01 F8 FF 24 |         rol phsa,#1             ' B6
2D4C(0103) 01 F8 FF 24 |         rol phsa,#1             ' B5
2D50(0104) 01 F8 FF 24 |         rol phsa,#1             ' B4
2D54(0105) 01 F8 FF 24 |         rol phsa,#1             ' B3
2D58(0106) 01 F8 FF 24 |         rol phsa,#1             ' B2
2D5C(0107) 01 F8 FF 24 |         rol phsa,#1             ' B1
2D60(0108) 01 F8 FF 24 |         rol phsa,#1             ' B0
2D64(0109) 11 F8 FF 24 |         rol phsa,#17            ' C7
2D68(010A) 01 F8 FF 24 |         rol phsa,#1             ' C6
2D6C(010B) 01 F8 FF 24 |         rol phsa,#1             ' C5
2D70(010C) 01 F8 FF 24 |         rol phsa,#1             ' C4
2D74(010D) 01 F8 FF 24 |         rol phsa,#1             ' C3
2D78(010E) 01 F8 FF 24 |         rol phsa,#1             ' C2
2D7C(010F) 01 F8 FF 24 |         rol phsa,#1             ' C1
2D80(0110) 01 F8 FF 24 |         rol phsa,#1             ' C0
2D84(0111) 11 F8 FF 24 |         rol phsa,#17            ' D7
2D88(0112) 01 F8 FF 24 |         rol phsa,#1             ' D6
2D8C(0113) 01 F8 FF 24 |         rol phsa,#1             ' D5
2D90(0114) 01 F8 FF 24 |         rol phsa,#1             ' D4
2D94(0115) 01 F8 FF 24 |         rol phsa,#1             ' D3
2D98(0116) 01 F8 FF 24 |         rol phsa,#1             ' D2
2D9C(0117) 01 F8 FF 24 |         rol phsa,#1             ' D1
2DA0(0118) 01 F8 FF 24 |         rol phsa,#1             ' D0 will be in place _after_ this instruction
2DA4(0119) 00 F6 FF A0 |         mov frqb,#0             ' shuts the clock off, _after_ this instruction
2DA8(011A) F6 7A FE E4 |         djnz ops_left,#:write_loop
2DAC(011B) 8D 46 FD 5C |         call #in8
2DB0(011C) 8D 46 FD 5C |         call #in8
2DB4(011D) 8D 46 FD 5C |         call #in8
2DB8(011E) 1F 7C FE 60 |         and readback,#$1F
2DBC(011F) 05 7C 7E 86 |         cmp readback,#5 wz
2DC0(0120) 00 82 EA A0 | if_z    mov user_cmd,#0 ' great
2DC4(0121) 65 82 D6 A4 | if_nz   neg user_cmd,#ERR_ASM_BLOCK_NOT_WRITTEN ' oops
2DC8(0122) 8D 46 FD 5C |         call #in8 
2DCC(0123) 00 72 FE A0 |         mov idle_time,#0
2DD0(0124)             | write_single_block_ret
2DD0(0124) 00 00 7C 5C |         ret
2DD4(0125) 00 00 00 00 | pinDO         long 0    ' pin is controlled by a counter
2DD8(0126) 00 00 00 00 | pinCLK        long 0    ' pin is controlled by a counter
2DDC(0127) 00 00 00 00 | pinDI         long 0    ' pin is controlled by a counter
2DE0(0128) 00 00 00 00 | maskDO        long 0    ' mask for reading the DO line from the card
2DE4(0129) 00 00 00 00 | maskDI        long 0    ' mask for setting the pin high while reading  
2DE8(012A) 00 00 00 00 | maskCS        long 0    ' mask = (1<<pin), and is controlled directly
2DEC(012B) 00 00 00 00 | maskAll       long 0
2DF0(012C) 09 00 00 00 | adrShift      long 9    ' will be 0 for SDHC, 9 for MMC & SD
2DF4(012D) 00 00 00 00 | bufAdr        long 0    ' where in Hub RAM is the buffer to copy to/from?
2DF8(012E) 00 00 00 00 | sdAdr         long 0    ' where on the SD card does it read/write?
2DFC(012F) 00 00 00 00 | writeMode     long 0    ' the counter setup in NCO single ended, clocking data out on pinDI
2E00(0130) 40 42 0F 00 | N_in8_500ms   long 1_000_000 ' used for timeout checking in PASM
2E04(0131) 00 00 00 00 | clockLineMode long 0
2E08(0132) 00 00 00 7C | clockXferMode long %11111 << 26
2E0C(0133) 00 02 00 00 | const512      long 512
2E10(0134) 00 04 00 00 | const1024     long 1024
2E14(0135) 00 08 00 00 | incDest4      long 4 << 9
2E18(0136) 00 FE 00 00 | decDestNminus1 long (512 / 4 - 1) << 9         
2E1C(0137) 00 00 00 00 | seconds       long 0
2E20(0138) 00 00 00 00 | dtime         long 0
2E24(0139) 00 00 00 00 | idle_time     long 0
2E28(013A) 00 00 00 00 | idle_limit    long 0
2E2C(013B) FF FF FF FF | lastIndexPlus long -1   ' state handler will check against lastIndexPlus, which will not have been -1
2E30(013C) 00 00 00 00 | lastCommand   long 0    ' this will never be the last command.
2E34(013D)             | ops_left      res 1     ' used as a counter for bytes, words, longs, whatever (start w/ # byte clocks out)
2E34(013E)             | readback      res 1     ' all reading from the card goes through here
2E34(013F)             | tmp1          res 1     ' this may get used in all subroutines...don't use except in lowest 
2E34(0140)             | user_request  res 1     ' the main command variable, read in from Hub: "r"-read single, "w"-write single
2E34(0141)             | user_cmd      res 1     ' used internally to handle actual commands to be executed
2E34(0142)             | user_idx      res 1     ' the pointer to the Hub RAM where the data block is/goes
2E34(0143)             | block_cmd     res 1     ' one of the SD/MMC command codes, no app-specific allowed
2E34(0144)             | buf_ptr       res 1     ' moving pointer to the Hub RAM buffer
2E34(0145)             | last_time     res 1     ' tracking the timestamp
2E34(0146)             | speed_buf     res 128   ' 512 bytes to be used for read-ahead / write-behind
2E34(01C6)             | FIT 496
2E34(01C6)             | There are 42 ($02A) Longs left in the cog
|===========================================================================|
|===========================================================================|
Spin Block readblock with 2 Parameters and 0 Extra Stack Longs. Method 1
PUB readblock( block_index, buffer_address )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - block_index
Local Parameter DBASE:0008 - buffer_address
|===========================================================================|
95                        if SPI_engine_cog == 0
Addr : 2E34:          C4 2C  : Memory Op Long PBASE + READ Address = 002C
Addr : 2E36:             35  : Constant 1 $00000000
Addr : 2E37:             FC  : Math Op ==    
Addr : 2E38: JZ Label0002
Addr : 2E38:          0A 05  : jz Address = 2E3F 5
Addr : 2E3A:       39 03 E6  : Constant 2 Bytes - 03 E6 - $000003E6 998
Addr : 2E3D:             E7  : Math Op !     
Addr : 2E3E:             31  : Abort value   
Addr : 2E3F: Label0002
Addr : 2E3F: Label0003
97                        if (buffer_address & 3)
Addr : 2E3F:             68  : Variable Operation Local Offset - 2 Read
Addr : 2E40:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 2E42:             E8  : Math Op &     
Addr : 2E43: JZ Label0004
Addr : 2E43:          0A 03  : jz Address = 2E48 3
Addr : 2E45:          37 61  : Constant Mask Y=97 Decrement Invert FFFFFFFC 4294967292
Addr : 2E47:             31  : Abort value   
Addr : 2E48: Label0004
Addr : 2E48: Label0005
99                        SPI_block_index := block_index
Addr : 2E48:             64  : Variable Operation Local Offset - 1 Read
Addr : 2E49:          C5 34  : Memory Op Long PBASE + WRITE Address = 0034
100                        SPI_buffer_address := buffer_address
Addr : 2E4B:             68  : Variable Operation Local Offset - 2 Read
Addr : 2E4C:          C5 38  : Memory Op Long PBASE + WRITE Address = 0038
101                        SPI_command := "r"
Addr : 2E4E:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 2E50:          C5 30  : Memory Op Long PBASE + WRITE Address = 0030
Addr : 2E52: Label0006
102                        repeat while SPI_command == "r"
Addr : 2E52:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E54:          38 72  : Constant 1 Bytes - 72 - $00000072 114
Addr : 2E56:             FC  : Math Op ==    
Addr : 2E57: JZ Label0008
Addr : 2E57:          0A 02  : jz Address = 2E5B 2
Addr : 2E59: Label0007
Addr : 2E59: JMP Label0006
Addr : 2E59:          04 77  : Jmp 2E52 -9   
Addr : 2E5B: Label0008
103                        if SPI_command < 0
Addr : 2E5B:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E5D:             35  : Constant 1 $00000000
Addr : 2E5E:             F9  : Math Op <     
Addr : 2E5F: JZ Label0009
Addr : 2E5F:          0A 03  : jz Address = 2E64 3
104                          abort SPI_command
Addr : 2E61:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E63:             31  : Abort value   
Addr : 2E64: Label0009
Addr : 2E64: Label000A
Addr : 2E64:             32  : Return        
|===========================================================================|
Spin Block writeblock with 2 Parameters and 0 Extra Stack Longs. Method 2
PUB writeblock( block_index, buffer_address )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - block_index
Local Parameter DBASE:0008 - buffer_address
|===========================================================================|
107                        if SPI_engine_cog == 0
Addr : 2E65:          C4 2C  : Memory Op Long PBASE + READ Address = 002C
Addr : 2E67:             35  : Constant 1 $00000000
Addr : 2E68:             FC  : Math Op ==    
Addr : 2E69: JZ Label0002
Addr : 2E69:          0A 05  : jz Address = 2E70 5
Addr : 2E6B:       39 03 E6  : Constant 2 Bytes - 03 E6 - $000003E6 998
Addr : 2E6E:             E7  : Math Op !     
Addr : 2E6F:             31  : Abort value   
Addr : 2E70: Label0002
Addr : 2E70: Label0003
109                        if (buffer_address & 3)
Addr : 2E70:             68  : Variable Operation Local Offset - 2 Read
Addr : 2E71:          37 21  : Constant Mask Y=33 Decrement 00000003 3
Addr : 2E73:             E8  : Math Op &     
Addr : 2E74: JZ Label0004
Addr : 2E74:          0A 03  : jz Address = 2E79 3
Addr : 2E76:          37 61  : Constant Mask Y=97 Decrement Invert FFFFFFFC 4294967292
Addr : 2E78:             31  : Abort value   
Addr : 2E79: Label0004
Addr : 2E79: Label0005
111                        SPI_block_index := block_index
Addr : 2E79:             64  : Variable Operation Local Offset - 1 Read
Addr : 2E7A:          C5 34  : Memory Op Long PBASE + WRITE Address = 0034
112                        SPI_buffer_address := buffer_address
Addr : 2E7C:             68  : Variable Operation Local Offset - 2 Read
Addr : 2E7D:          C5 38  : Memory Op Long PBASE + WRITE Address = 0038
113                        SPI_command := "w"
Addr : 2E7F:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 2E81:          C5 30  : Memory Op Long PBASE + WRITE Address = 0030
Addr : 2E83: Label0006
114                        repeat while SPI_command == "w"
Addr : 2E83:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E85:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 2E87:             FC  : Math Op ==    
Addr : 2E88: JZ Label0008
Addr : 2E88:          0A 02  : jz Address = 2E8C 2
Addr : 2E8A: Label0007
Addr : 2E8A: JMP Label0006
Addr : 2E8A:          04 77  : Jmp 2E83 -9   
Addr : 2E8C: Label0008
115                        if SPI_command < 0
Addr : 2E8C:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E8E:             35  : Constant 1 $00000000
Addr : 2E8F:             F9  : Math Op <     
Addr : 2E90: JZ Label0009
Addr : 2E90:          0A 03  : jz Address = 2E95 3
116                          abort SPI_command
Addr : 2E92:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 2E94:             31  : Abort value   
Addr : 2E95: Label0009
Addr : 2E95: Label000A
Addr : 2E95:             32  : Return        
|===========================================================================|
Spin Block start_explicit with 4 Parameters and 2 Extra Stack Longs. Method 3
PUB start_explicit( DO, CLK, DI, CS ) : card_type | tmp, i

Local Parameter DBASE:0000 - card_type
Local Parameter DBASE:0004 - DO
Local Parameter DBASE:0008 - CLK
Local Parameter DBASE:000C - DI
Local Parameter DBASE:0010 - CS
Local Variable  DBASE:0014 - tmp
Local Variable  DBASE:0018 - i
|===========================================================================|
141                        stop
Addr : 2E96:             01  : Drop Anchor   
Addr : 2E97:          05 05  : Call Sub 5    
149                        waitcnt( 500 + (clkfreq>>8) + cnt )
Addr : 2E99:       39 01 F4  : Constant 2 Bytes - 01 F4 - $000001F4 500
Addr : 2E9C:             35  : Constant 1 $00000000
Addr : 2E9D:             C0  : Memory Op Long POP Address READ 
Addr : 2E9E:          37 02  : Constant Mask Y=2 00000008 8
Addr : 2EA0:             E2  : Math Op >>    
Addr : 2EA1:             EC  : Math Op +     
Addr : 2EA2:          3F 91  : Register op CNT Read
Addr : 2EA4:             EC  : Math Op +     
Addr : 2EA5:             23  : WaitCnt(count)
151                        pinDO := DO
Addr : 2EA6:             64  : Variable Operation Local Offset - 1 Read
Addr : 2EA7:       C5 84 D0  : Memory Op Long PBASE + WRITE Address = 04D0
152                        maskDO := |< DO
Addr : 2EAA:             64  : Variable Operation Local Offset - 1 Read
Addr : 2EAB:             F3  : Math Op |<    
Addr : 2EAC:       C5 84 DC  : Memory Op Long PBASE + WRITE Address = 04DC
153                        pinCLK := CLK
Addr : 2EAF:             68  : Variable Operation Local Offset - 2 Read
Addr : 2EB0:       C5 84 D4  : Memory Op Long PBASE + WRITE Address = 04D4
154                        pinDI := DI
Addr : 2EB3:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2EB4:       C5 84 D8  : Memory Op Long PBASE + WRITE Address = 04D8
155                        maskDI := |< DI
Addr : 2EB7:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2EB8:             F3  : Math Op |<    
Addr : 2EB9:       C5 84 E0  : Memory Op Long PBASE + WRITE Address = 04E0
156                        maskCS := |< CS
Addr : 2EBC:             70  : Variable Operation Local Offset - 4 Read
Addr : 2EBD:             F3  : Math Op |<    
Addr : 2EBE:       C5 84 E4  : Memory Op Long PBASE + WRITE Address = 04E4
157                        adrShift := 9 ' block = 512 * index, and 512 = 1<<9
Addr : 2EC1:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 2EC3:       C5 84 EC  : Memory Op Long PBASE + WRITE Address = 04EC
159                        maskAll := maskCS | (|<pinCLK) | maskDI
Addr : 2EC6:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 2EC9:       C4 84 D4  : Memory Op Long PBASE + READ Address = 04D4
Addr : 2ECC:             F3  : Math Op |<    
Addr : 2ECD:             EA  : Math Op |     
Addr : 2ECE:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 2ED1:             EA  : Math Op |     
Addr : 2ED2:       C5 84 E8  : Memory Op Long PBASE + WRITE Address = 04E8
160                        dira |= maskAll  
Addr : 2ED5:       C4 84 E8  : Memory Op Long PBASE + READ Address = 04E8
Addr : 2ED8:       3F D6 4A  : Register op DIRA ByteMathop |
162                        outa |= maskAll
Addr : 2EDB:       C4 84 E8  : Memory Op Long PBASE + READ Address = 04E8
Addr : 2EDE:       3F D4 4A  : Register op OUTA ByteMathop |
163                        repeat 4096
Addr : 2EE1:          37 0B  : Constant Mask Y=11 00001000 4096
Addr : 2EE3: TJZ Label0004
Addr : 2EE3:          08 0A  : tjz Address = 2EEF 10
Addr : 2EE5: Label0002
164                          outa[CLK]~~
Addr : 2EE5:             68  : Variable Operation Local Offset - 2 Read
Addr : 2EE6:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
165                          outa[CLK]~
Addr : 2EE9:             68  : Variable Operation Local Offset - 2 Read
Addr : 2EEA:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
Addr : 2EED: Label0003
Addr : 2EED: DJNZ Label0002
Addr : 2EED:          09 76  : djnz Address = 2EE5 -10
Addr : 2EEF: Label0004
167                        SPI_block_index := cnt
Addr : 2EEF:          3F 91  : Register op CNT Read
Addr : 2EF1:          C5 34  : Memory Op Long PBASE + WRITE Address = 0034
169                        tmp~
Addr : 2EF3:          76 18  : Variable Operation Local Offset - 5 Assign VAR~ Post-clear
170                        repeat i from 0 to 9
Addr : 2EF5:             35  : Constant 1 $00000000
Addr : 2EF6:             79  : Variable Operation Local Offset - 6 Write
Addr : 2EF7: Label0005
171                          if tmp <> 1
Addr : 2EF7:             74  : Variable Operation Local Offset - 5 Read
Addr : 2EF8:             36  : Constant 2 $00000001
Addr : 2EF9:             FB  : Math Op <>    
Addr : 2EFA: JZ Label0008
Addr : 2EFA:          0A 3B  : jz Address = 2F37 59
172                            tmp := send_cmd_slow( CMD0, 0, $95 )
Addr : 2EFC:             00  : Drop Anchor Push 
Addr : 2EFD:          37 05  : Constant Mask Y=5 00000040 64
Addr : 2EFF:             35  : Constant 1 $00000000
Addr : 2F00:          38 95  : Constant 1 Bytes - 95 - $00000095 149
Addr : 2F02:          05 07  : Call Sub 7    
Addr : 2F04:             75  : Variable Operation Local Offset - 5 Write
173                            if (tmp & 4)
Addr : 2F05:             74  : Variable Operation Local Offset - 5 Read
Addr : 2F06:          37 01  : Constant Mask Y=1 00000004 4
Addr : 2F08:             E8  : Math Op &     
Addr : 2F09: JZ Label000A
Addr : 2F09:          0A 2C  : jz Address = 2F37 44
175                              if i & 1
Addr : 2F0B:             78  : Variable Operation Local Offset - 6 Read
Addr : 2F0C:             36  : Constant 2 $00000001
Addr : 2F0D:             E8  : Math Op &     
Addr : 2F0E: JZ Label000C
Addr : 2F0E:          0A 1F  : jz Address = 2F2F 31
177                                repeat 4
Addr : 2F10:          37 01  : Constant Mask Y=1 00000004 4
Addr : 2F12: TJZ Label0010
Addr : 2F12:          08 05  : tjz Address = 2F19 5
Addr : 2F14: Label000E
178                                  read_32_slow        ' these extra clocks are required for some MMC cards
Addr : 2F14:             01  : Drop Anchor   
Addr : 2F15:          05 09  : Call Sub 9    
Addr : 2F17: Label000F
Addr : 2F17: DJNZ Label000E
Addr : 2F17:          09 7B  : djnz Address = 2F14 -5
Addr : 2F19: Label0010
179                                send_slow( $FD, 8 )   ' stop token
Addr : 2F19:             01  : Drop Anchor   
Addr : 2F1A:          38 FD  : Constant 1 Bytes - FD - $000000FD 253
Addr : 2F1C:          37 02  : Constant Mask Y=2 00000008 8
Addr : 2F1E:          05 08  : Call Sub 8    
180                                read_32_slow
Addr : 2F20:             01  : Drop Anchor   
Addr : 2F21:          05 09  : Call Sub 9    
Addr : 2F23: Label0011
181                                repeat while read_slow <> $FF
Addr : 2F23:             00  : Drop Anchor Push 
Addr : 2F24:          05 0A  : Call Sub 10   
Addr : 2F26:          37 27  : Constant Mask Y=39 Decrement 000000FF 255
Addr : 2F28:             FB  : Math Op <>    
Addr : 2F29: JZ Label0013
Addr : 2F29:          0A 02  : jz Address = 2F2D 2
Addr : 2F2B: Label0012
Addr : 2F2B: JMP Label0011
Addr : 2F2B:          04 76  : Jmp 2F23 -10  
Addr : 2F2D: Label0013
Addr : 2F2D: JMP Label000D
Addr : 2F2D:          04 08  : Jmp 2F37 8    
Addr : 2F2F: Label000C
184                                send_cmd_slow( CMD12, 0, $61 )           
Addr : 2F2F:             01  : Drop Anchor   
Addr : 2F30:          38 4C  : Constant 1 Bytes - 4C - $0000004C 76
Addr : 2F32:             35  : Constant 1 $00000000
Addr : 2F33:          38 61  : Constant 1 Bytes - 61 - $00000061 97
Addr : 2F35:          05 07  : Call Sub 7    
Addr : 2F37: Label0014
Addr : 2F37: Label000D
Addr : 2F37: Label000A
Addr : 2F37: Label000B
Addr : 2F37: Label0008
Addr : 2F37: Label0009
Addr : 2F37: Label0006
170                        repeat i from 0 to 9
Addr : 2F37:             35  : Constant 1 $00000000
Addr : 2F38:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 2F3A: Repeat i Step Label0005
Addr : 2F3A:    7A 02 FF B9  : Variable Operation Local Offset - 6 Assign Repeat-Var loop Address= 2EF7 -71
Addr : 2F3E: Label0007
185                        if tmp <> 1
Addr : 2F3E:             74  : Variable Operation Local Offset - 5 Read
Addr : 2F3F:             36  : Constant 2 $00000001
Addr : 2F40:             FB  : Math Op <>    
Addr : 2F41: JZ Label0015
Addr : 2F41:          0A 04  : jz Address = 2F47 4
187                          crash( ERR_CARD_NOT_RESET )
Addr : 2F43:             01  : Drop Anchor   
Addr : 2F44:             34  : Constant 0 $FFFFFFFF
Addr : 2F45:          05 06  : Call Sub 6    
Addr : 2F47: Label0015
Addr : 2F47: Label0016
189                        if send_cmd_slow( CMD8, $1AA, $87 ) == 1
Addr : 2F47:             00  : Drop Anchor Push 
Addr : 2F48:          38 48  : Constant 1 Bytes - 48 - $00000048 72
Addr : 2F4A:       39 01 AA  : Constant 2 Bytes - 01 AA - $000001AA 426
Addr : 2F4D:          38 87  : Constant 1 Bytes - 87 - $00000087 135
Addr : 2F4F:          05 07  : Call Sub 7    
Addr : 2F51:             36  : Constant 2 $00000001
Addr : 2F52:             FC  : Math Op ==    
Addr : 2F53: JZ Label0017
Addr : 2F53:       0A 80 4B  : jz Address = 2FA1 75
191                          tmp := read_32_slow
Addr : 2F56:             00  : Drop Anchor Push 
Addr : 2F57:          05 09  : Call Sub 9    
Addr : 2F59:             75  : Variable Operation Local Offset - 5 Write
193                          if (tmp & $1FF) <> $1AA
Addr : 2F5A:             74  : Variable Operation Local Offset - 5 Read
Addr : 2F5B:          37 28  : Constant Mask Y=40 Decrement 000001FF 511
Addr : 2F5D:             E8  : Math Op &     
Addr : 2F5E:       39 01 AA  : Constant 2 Bytes - 01 AA - $000001AA 426
Addr : 2F61:             FB  : Math Op <>    
Addr : 2F62: JZ Label0019
Addr : 2F62:          0A 05  : jz Address = 2F69 5
194                            crash( ERR_3v3_NOT_SUPPORTED )
Addr : 2F64:             01  : Drop Anchor   
Addr : 2F65:          37 60  : Constant Mask Y=96 Decrement Invert FFFFFFFE 4294967294
Addr : 2F67:          05 06  : Call Sub 6    
Addr : 2F69: Label0019
Addr : 2F69: Label001A
Addr : 2F69: Label001B
196                          repeat while send_cmd_slow( ACMD41, |<30, $77 )
Addr : 2F69:             00  : Drop Anchor Push 
Addr : 2F6A:          38 E9  : Constant 1 Bytes - E9 - $000000E9 233
Addr : 2F6C:          38 1E  : Constant 1 Bytes - 1E - $0000001E 30
Addr : 2F6E:             F3  : Math Op |<    
Addr : 2F6F:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 2F71:          05 07  : Call Sub 7    
Addr : 2F73: JZ Label001D
Addr : 2F73:          0A 02  : jz Address = 2F77 2
Addr : 2F75: Label001C
Addr : 2F75: JMP Label001B
Addr : 2F75:          04 72  : Jmp 2F69 -14  
Addr : 2F77: Label001D
198                          if send_cmd_slow( CMD58, 0, $FD ) <> 0
Addr : 2F77:             00  : Drop Anchor Push 
Addr : 2F78:          38 7A  : Constant 1 Bytes - 7A - $0000007A 122
Addr : 2F7A:             35  : Constant 1 $00000000
Addr : 2F7B:          38 FD  : Constant 1 Bytes - FD - $000000FD 253
Addr : 2F7D:          05 07  : Call Sub 7    
Addr : 2F7F:             35  : Constant 1 $00000000
Addr : 2F80:             FB  : Math Op <>    
Addr : 2F81: JZ Label001E
Addr : 2F81:          0A 05  : jz Address = 2F88 5
199                            crash( ERR_OCR_FAILED )
Addr : 2F83:             01  : Drop Anchor   
Addr : 2F84:          37 40  : Constant Mask Y=64 Invert FFFFFFFD 4294967293
Addr : 2F86:          05 06  : Call Sub 6    
Addr : 2F88: Label001E
Addr : 2F88: Label001F
201                          tmp := read_32_slow
Addr : 2F88:             00  : Drop Anchor Push 
Addr : 2F89:          05 09  : Call Sub 9    
Addr : 2F8B:             75  : Variable Operation Local Offset - 5 Write
203                          if tmp & |<30
Addr : 2F8C:             74  : Variable Operation Local Offset - 5 Read
Addr : 2F8D:          38 1E  : Constant 1 Bytes - 1E - $0000001E 30
Addr : 2F8F:             F3  : Math Op |<    
Addr : 2F90:             E8  : Math Op &     
Addr : 2F91: JZ Label0020
Addr : 2F91:          0A 09  : jz Address = 2F9C 9
Addr : 2F93:          37 21  : Constant Mask Y=33 Decrement 00000003 3
204                            card_type := type_SDHC
Addr : 2F95:             61  : Variable Operation Local Offset - 0 Write
205                            adrShift := 0
Addr : 2F96:             35  : Constant 1 $00000000
Addr : 2F97:       C5 84 EC  : Memory Op Long PBASE + WRITE Address = 04EC
Addr : 2F9A: JMP Label0021
Addr : 2F9A:          04 03  : Jmp 2F9F 3    
Addr : 2F9C: Label0020
Addr : 2F9C:          37 00  : Constant Mask Y=0 00000002 2
207                            card_type := type_SD
Addr : 2F9E:             61  : Variable Operation Local Offset - 0 Write
Addr : 2F9F: Label0022
Addr : 2F9F: Label0021
Addr : 2F9F: JMP Label0018
Addr : 2F9F:          04 35  : Jmp 2FD6 53   
Addr : 2FA1: Label0017
210                          if send_cmd_slow( ACMD41, 0, $E5 ) < 2
Addr : 2FA1:             00  : Drop Anchor Push 
Addr : 2FA2:          38 E9  : Constant 1 Bytes - E9 - $000000E9 233
Addr : 2FA4:             35  : Constant 1 $00000000
Addr : 2FA5:          38 E5  : Constant 1 Bytes - E5 - $000000E5 229
Addr : 2FA7:          05 07  : Call Sub 7    
Addr : 2FA9:          37 00  : Constant Mask Y=0 00000002 2
Addr : 2FAB:             F9  : Math Op <     
Addr : 2FAC: JZ Label0024
Addr : 2FAC:          0A 11  : jz Address = 2FBF 17
Addr : 2FAE:          37 00  : Constant Mask Y=0 00000002 2
212                            card_type := type_SD
Addr : 2FB0:             61  : Variable Operation Local Offset - 0 Write
Addr : 2FB1: Label0026
213                            repeat while send_cmd_slow( ACMD41, 0, $E5 )
Addr : 2FB1:             00  : Drop Anchor Push 
Addr : 2FB2:          38 E9  : Constant 1 Bytes - E9 - $000000E9 233
Addr : 2FB4:             35  : Constant 1 $00000000
Addr : 2FB5:          38 E5  : Constant 1 Bytes - E5 - $000000E5 229
Addr : 2FB7:          05 07  : Call Sub 7    
Addr : 2FB9: JZ Label0028
Addr : 2FB9:          0A 02  : jz Address = 2FBD 2
Addr : 2FBB: Label0027
Addr : 2FBB: JMP Label0026
Addr : 2FBB:          04 74  : Jmp 2FB1 -12  
Addr : 2FBD: Label0028
Addr : 2FBD: JMP Label0025
Addr : 2FBD:          04 0E  : Jmp 2FCD 14   
Addr : 2FBF: Label0024
Addr : 2FBF:             36  : Constant 2 $00000001
216                            card_type := type_MMC
Addr : 2FC0:             61  : Variable Operation Local Offset - 0 Write
Addr : 2FC1: Label002A
217                            repeat while send_cmd_slow( CMD1, 0, $F9 )
Addr : 2FC1:             00  : Drop Anchor Push 
Addr : 2FC2:          38 41  : Constant 1 Bytes - 41 - $00000041 65
Addr : 2FC4:             35  : Constant 1 $00000000
Addr : 2FC5:          38 F9  : Constant 1 Bytes - F9 - $000000F9 249
Addr : 2FC7:          05 07  : Call Sub 7    
Addr : 2FC9: JZ Label002C
Addr : 2FC9:          0A 02  : jz Address = 2FCD 2
Addr : 2FCB: Label002B
Addr : 2FCB: JMP Label002A
Addr : 2FCB:          04 74  : Jmp 2FC1 -12  
Addr : 2FCD: Label002C
Addr : 2FCD: Label0029
Addr : 2FCD: Label0025
219                          send_cmd_slow( CMD16, 512, $15 )
Addr : 2FCD:             01  : Drop Anchor   
Addr : 2FCE:          38 50  : Constant 1 Bytes - 50 - $00000050 80
Addr : 2FD0:          37 08  : Constant Mask Y=8 00000200 512
Addr : 2FD2:          38 15  : Constant 1 Bytes - 15 - $00000015 21
Addr : 2FD4:          05 07  : Call Sub 7    
Addr : 2FD6: Label0023
Addr : 2FD6: Label0018
221                        send_cmd_slow( CMD59, 0, $91 )
Addr : 2FD6:             01  : Drop Anchor   
Addr : 2FD7:          38 7B  : Constant 1 Bytes - 7B - $0000007B 123
Addr : 2FD9:             35  : Constant 1 $00000000
Addr : 2FDA:          38 91  : Constant 1 Bytes - 91 - $00000091 145
Addr : 2FDC:          05 07  : Call Sub 7    
225                        outa |= maskCS
Addr : 2FDE:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 2FE1:       3F D4 4A  : Register op OUTA ByteMathop |
228                        writeMode := (%00100 << 26) | (DI << 0)
Addr : 2FE4:          37 01  : Constant Mask Y=1 00000004 4
Addr : 2FE6:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 2FE8:             E3  : Math Op <<    
Addr : 2FE9:             6C  : Variable Operation Local Offset - 3 Read
Addr : 2FEA:             35  : Constant 1 $00000000
Addr : 2FEB:             E3  : Math Op <<    
Addr : 2FEC:             EA  : Math Op |     
Addr : 2FED:       C5 84 F8  : Memory Op Long PBASE + WRITE Address = 04F8
234                        clockLineMode := (%00100 << 26) | (CLK << 0) ' NCO, 50% duty cycle
Addr : 2FF0:          37 01  : Constant Mask Y=1 00000004 4
Addr : 2FF2:          38 1A  : Constant 1 Bytes - 1A - $0000001A 26
Addr : 2FF4:             E3  : Math Op <<    
Addr : 2FF5:             68  : Variable Operation Local Offset - 2 Read
Addr : 2FF6:             35  : Constant 1 $00000000
Addr : 2FF7:             E3  : Math Op <<    
Addr : 2FF8:             EA  : Math Op |     
Addr : 2FF9:       C5 85 00  : Memory Op Long PBASE + WRITE Address = 0500
Addr : 2FFC:             35  : Constant 1 $00000000
Addr : 2FFD:             C0  : Memory Op Long POP Address READ 
Addr : 2FFE:          38 06  : Constant 1 Bytes - 06 - $00000006 6
236                        N_in8_500ms := clkfreq >> constant(1+2+3)
Addr : 3000:             E2  : Math Op >>    
Addr : 3001:       C5 84 FC  : Memory Op Long PBASE + WRITE Address = 04FC
238                        idle_limit := 125 ' ms, NEVER make this > 1000
Addr : 3004:          38 7D  : Constant 1 Bytes - 7D - $0000007D 125
Addr : 3006:       C5 85 24  : Memory Op Long PBASE + WRITE Address = 0524
Addr : 3009:             35  : Constant 1 $00000000
Addr : 300A:             C0  : Memory Op Long POP Address READ 
239                        idle_limit := clkfreq / (1000 / idle_limit) ' convert to counts
Addr : 300B:       39 03 E8  : Constant 2 Bytes - 03 E8 - $000003E8 1000
Addr : 300E:       C4 85 24  : Memory Op Long PBASE + READ Address = 0524
Addr : 3011:             F6  : Math Op /     
Addr : 3012:             F6  : Math Op /     
Addr : 3013:       C5 85 24  : Memory Op Long PBASE + WRITE Address = 0524
241                        bufAdr := @SPI_buffer_address
Addr : 3016:          C7 38  : Memory Op Long PBASE + ADDRESS Address = 0038
Addr : 3018:       C5 84 F0  : Memory Op Long PBASE + WRITE Address = 04F0
242                        sdAdr := @SPI_block_index
Addr : 301B:          C7 34  : Memory Op Long PBASE + ADDRESS Address = 0034
Addr : 301D:       C5 84 F4  : Memory Op Long PBASE + WRITE Address = 04F4
243                        SPI_command := 0 ' just make sure it's not 1
Addr : 3020:             35  : Constant 1 $00000000
Addr : 3021:          C5 30  : Memory Op Long PBASE + WRITE Address = 0030
Addr : 3023:             34  : Constant 0 $FFFFFFFF
245                        SPI_engine_cog := cognew( @SPI_engine_entry, @SPI_command ) + 1
Addr : 3024:          C7 3C  : Memory Op Long PBASE + ADDRESS Address = 003C
Addr : 3026:          C7 30  : Memory Op Long PBASE + ADDRESS Address = 0030
Addr : 3028:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 3029:             36  : Constant 2 $00000001
Addr : 302A:             EC  : Math Op +     
Addr : 302B:          C5 2C  : Memory Op Long PBASE + WRITE Address = 002C
246                        if( SPI_engine_cog == 0 )
Addr : 302D:          C4 2C  : Memory Op Long PBASE + READ Address = 002C
Addr : 302F:             35  : Constant 1 $00000000
Addr : 3030:             FC  : Math Op ==    
Addr : 3031: JZ Label002D
Addr : 3031:          0A 07  : jz Address = 303A 7
247                          crash( ERR_SPI_ENGINE_NOT_RUNNING )
Addr : 3033:             01  : Drop Anchor   
Addr : 3034:       39 03 E6  : Constant 2 Bytes - 03 E6 - $000003E6 998
Addr : 3037:             E7  : Math Op !     
Addr : 3038:          05 06  : Call Sub 6    
Addr : 303A: Label002D
Addr : 303A: Label002E
Addr : 303A: Label002F
248                        repeat while SPI_command <> -1
Addr : 303A:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 303C:             34  : Constant 0 $FFFFFFFF
Addr : 303D:             FB  : Math Op <>    
Addr : 303E: JZ Label0031
Addr : 303E:          0A 02  : jz Address = 3042 2
Addr : 3040: Label0030
Addr : 3040: JMP Label002F
Addr : 3040:          04 78  : Jmp 303A -8   
Addr : 3042: Label0031
250                        dira &= !maskAll
Addr : 3042:       C4 84 E8  : Memory Op Long PBASE + READ Address = 04E8
Addr : 3045:             E7  : Math Op !     
Addr : 3046:       3F D6 48  : Register op DIRA BitMathop &
Addr : 3049:             32  : Return        
|===========================================================================|
Spin Block release with 0 Parameters and 0 Extra Stack Longs. Method 4
PUB release

Local Parameter DBASE:0000 - Result
|===========================================================================|
259                        if SPI_engine_cog
Addr : 304A:          C4 2C  : Memory Op Long PBASE + READ Address = 002C
Addr : 304C: JZ Label0002
Addr : 304C:          0A 0D  : jz Address = 305B 13
260                          SPI_command := "z"
Addr : 304E:          38 7A  : Constant 1 Bytes - 7A - $0000007A 122
Addr : 3050:          C5 30  : Memory Op Long PBASE + WRITE Address = 0030
Addr : 3052: Label0004
261                          repeat while SPI_command == "z"
Addr : 3052:          C4 30  : Memory Op Long PBASE + READ Address = 0030
Addr : 3054:          38 7A  : Constant 1 Bytes - 7A - $0000007A 122
Addr : 3056:             FC  : Math Op ==    
Addr : 3057: JZ Label0006
Addr : 3057:          0A 02  : jz Address = 305B 2
Addr : 3059: Label0005
Addr : 3059: JMP Label0004
Addr : 3059:          04 77  : Jmp 3052 -9   
Addr : 305B: Label0006
Addr : 305B: Label0002
Addr : 305B: Label0003
Addr : 305B:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 5
PUB stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
267                        release
Addr : 305C:             01  : Drop Anchor   
Addr : 305D:          05 04  : Call Sub 4    
268                        if SPI_engine_cog
Addr : 305F:          C4 2C  : Memory Op Long PBASE + READ Address = 002C
Addr : 3061: JZ Label0002
Addr : 3061:          0A 06  : jz Address = 3069 6
269                          cogstop( SPI_engine_cog~ - 1 )
Addr : 3063:       C6 2C 98  : Memory Op Long PBASE + ASSIGN Address = 002C VAR~ Post-clear Push
Addr : 3066:             36  : Constant 2 $00000001
Addr : 3067:             ED  : Math Op -     
Addr : 3068:             21  : CogStop(id)   
Addr : 3069: Label0002
Addr : 3069: Label0003
Addr : 3069:             32  : Return        
|===========================================================================|
Spin Block crash with 1 Parameters and 0 Extra Stack Longs. Method 6
PRI crash( abort_code )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - abort_code
|===========================================================================|
277                        dira &= !maskAll
Addr : 306A:       C4 84 E8  : Memory Op Long PBASE + READ Address = 04E8
Addr : 306D:             E7  : Math Op !     
Addr : 306E:       3F D6 48  : Register op DIRA BitMathop &
279                        abort abort_code
Addr : 3071:             64  : Variable Operation Local Offset - 1 Read
Addr : 3072:             31  : Abort value   
Addr : 3073: Data : 32                       2
|===========================================================================|
Spin Block send_cmd_slow with 3 Parameters and 1 Extra Stack Longs. Method 7
PRI send_cmd_slow( cmd, val, crc ) : reply | time_stamp

Local Parameter DBASE:0000 - reply
Local Parameter DBASE:0004 - cmd
Local Parameter DBASE:0008 - val
Local Parameter DBASE:000C - crc
Local Variable  DBASE:0010 - time_stamp
|===========================================================================|
293                        if (cmd & $80)
Addr : 3074:             64  : Variable Operation Local Offset - 1 Read
Addr : 3075:          37 06  : Constant Mask Y=6 00000080 128
Addr : 3077:             E8  : Math Op &     
Addr : 3078: JZ Label0002
Addr : 3078:          0A 14  : jz Address = 308E 20
295                            cmd &= $7F
Addr : 307A:          37 26  : Constant Mask Y=38 Decrement 0000007F 127
Addr : 307C:          66 48  : Variable Operation Local Offset - 1 Assign BitMathop &
296                            reply := send_cmd_slow( CMD55, 0, $65 )
Addr : 307E:             00  : Drop Anchor Push 
Addr : 307F:          38 77  : Constant 1 Bytes - 77 - $00000077 119
Addr : 3081:             35  : Constant 1 $00000000
Addr : 3082:          38 65  : Constant 1 Bytes - 65 - $00000065 101
Addr : 3084:          05 07  : Call Sub 7    
Addr : 3086:             61  : Variable Operation Local Offset - 0 Write
297                            if (reply > 1)
Addr : 3087:             60  : Variable Operation Local Offset - 0 Read
Addr : 3088:             36  : Constant 2 $00000001
Addr : 3089:             FA  : Math Op >     
Addr : 308A: JZ Label0004
Addr : 308A:          0A 02  : jz Address = 308E 2
298                              return reply  
Addr : 308C:             60  : Variable Operation Local Offset - 0 Read
Addr : 308D:             33  : Return value  
Addr : 308E: Label0004
Addr : 308E: Label0005
Addr : 308E: Label0002
Addr : 308E: Label0003
300                        outa |= maskCS
Addr : 308E:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 3091:       3F D4 4A  : Register op OUTA ByteMathop |
301                        outa &= !maskCS
Addr : 3094:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 3097:             E7  : Math Op !     
Addr : 3098:       3F D4 48  : Register op OUTA BitMathop &
303                        read_32_slow
Addr : 309B:             01  : Drop Anchor   
Addr : 309C:          05 09  : Call Sub 9    
305                        send_slow( cmd, 8 )
Addr : 309E:             01  : Drop Anchor   
Addr : 309F:             64  : Variable Operation Local Offset - 1 Read
Addr : 30A0:          37 02  : Constant Mask Y=2 00000008 8
Addr : 30A2:          05 08  : Call Sub 8    
307                        send_slow( val, 32 )   
Addr : 30A4:             01  : Drop Anchor   
Addr : 30A5:             68  : Variable Operation Local Offset - 2 Read
Addr : 30A6:          37 04  : Constant Mask Y=4 00000020 32
Addr : 30A8:          05 08  : Call Sub 8    
309                        send_slow( crc, 8 )
Addr : 30AA:             01  : Drop Anchor   
Addr : 30AB:             6C  : Variable Operation Local Offset - 3 Read
Addr : 30AC:          37 02  : Constant Mask Y=2 00000008 8
Addr : 30AE:          05 08  : Call Sub 8    
311                        if cmd == CMD12
Addr : 30B0:             64  : Variable Operation Local Offset - 1 Read
Addr : 30B1:          38 4C  : Constant 1 Bytes - 4C - $0000004C 76
Addr : 30B3:             FC  : Math Op ==    
Addr : 30B4: JZ Label0006
Addr : 30B4:          0A 03  : jz Address = 30B9 3
312                          read_slow
Addr : 30B6:             01  : Drop Anchor   
Addr : 30B7:          05 0A  : Call Sub 10   
Addr : 30B9: Label0006
Addr : 30B9: Label0007
314                        time_stamp := 9
Addr : 30B9:          38 09  : Constant 1 Bytes - 09 - $00000009 9
Addr : 30BB:             71  : Variable Operation Local Offset - 4 Write
Addr : 30BC: Label0008
316                          reply := read_slow
Addr : 30BC:             00  : Drop Anchor Push 
Addr : 30BD:          05 0A  : Call Sub 10   
Addr : 30BF:             61  : Variable Operation Local Offset - 0 Write
Addr : 30C0: Label0009
317                        while( reply & $80 ) and ( time_stamp-- )
Addr : 30C0:             60  : Variable Operation Local Offset - 0 Read
Addr : 30C1:          37 06  : Constant Mask Y=6 00000080 128
Addr : 30C3:             E8  : Math Op &     
Addr : 30C4:          72 BE  : Variable Operation Local Offset - 4 Assign VAR-- post-dec Long Push
Addr : 30C6:             F0  : Math Op AND   
Addr : 30C7: JNZ Label0008
Addr : 30C7:          0B 73  : jnz Address = 30BC -13
Addr : 30C9: Label000A
Addr : 30C9:             32  : Return        
|===========================================================================|
Spin Block send_slow with 2 Parameters and 0 Extra Stack Longs. Method 8
PRI send_slow( value, bits_to_send )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - bits_to_send
|===========================================================================|
330                        value ><= bits_to_send
Addr : 30CA:             68  : Variable Operation Local Offset - 2 Read
Addr : 30CB:          66 4F  : Variable Operation Local Offset - 1 Assign LongMathop ><
331                        repeat bits_to_send
Addr : 30CD:             68  : Variable Operation Local Offset - 2 Read
Addr : 30CE: TJZ Label0004
Addr : 30CE:          08 17  : tjz Address = 30E7 23
Addr : 30D0: Label0002
332                          outa[pinCLK]~
Addr : 30D0:       C4 84 D4  : Memory Op Long PBASE + READ Address = 04D4
Addr : 30D3:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
333                          outa[pinDI] := value
Addr : 30D6:             64  : Variable Operation Local Offset - 1 Read
Addr : 30D7:       C4 84 D8  : Memory Op Long PBASE + READ Address = 04D8
Addr : 30DA:          3D B4  : Register [Bit] op OUTA Write
334                          value >>= 1
Addr : 30DC:             36  : Constant 2 $00000001
Addr : 30DD:          66 42  : Variable Operation Local Offset - 1 Assign ByteMathop >>
335                          outa[pinCLK]~~
Addr : 30DF:       C4 84 D4  : Memory Op Long PBASE + READ Address = 04D4
Addr : 30E2:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
Addr : 30E5: Label0003
Addr : 30E5: DJNZ Label0002
Addr : 30E5:          09 69  : djnz Address = 30D0 -23
Addr : 30E7: Label0004
Addr : 30E7:             32  : Return        
|===========================================================================|
Spin Block read_32_slow with 0 Parameters and 0 Extra Stack Longs. Method 9
PRI read_32_slow : r

Local Parameter DBASE:0000 - r
|===========================================================================|
338                        repeat 4
Addr : 30E8:          37 01  : Constant Mask Y=1 00000004 4
Addr : 30EA: TJZ Label0004
Addr : 30EA:          08 0B  : tjz Address = 30F7 11
Addr : 30EC: Label0002
339                          r <<= 8
Addr : 30EC:          37 02  : Constant Mask Y=2 00000008 8
Addr : 30EE:          62 43  : Variable Operation Local Offset - 0 Assign ByteMathop <<
340                          r |= read_slow
Addr : 30F0:             00  : Drop Anchor Push 
Addr : 30F1:          05 0A  : Call Sub 10   
Addr : 30F3:          62 4A  : Variable Operation Local Offset - 0 Assign ByteMathop |
Addr : 30F5: Label0003
Addr : 30F5: DJNZ Label0002
Addr : 30F5:          09 75  : djnz Address = 30EC -11
Addr : 30F7: Label0004
Addr : 30F7:             32  : Return        
|===========================================================================|
Spin Block read_slow with 0 Parameters and 0 Extra Stack Longs. Method 10
PRI read_slow : r

Local Parameter DBASE:0000 - r
|===========================================================================|
347                        outa[pinDI]~~
Addr : 30F8:       C4 84 D8  : Memory Op Long PBASE + READ Address = 04D8
Addr : 30FB:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
349                        repeat 8
Addr : 30FE:          37 02  : Constant Mask Y=2 00000008 8
Addr : 3100: TJZ Label0004
Addr : 3100:          08 17  : tjz Address = 3119 23
Addr : 3102: Label0002
350                          outa[pinCLK]~
Addr : 3102:       C4 84 D4  : Memory Op Long PBASE + READ Address = 04D4
Addr : 3105:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
351                          outa[pinCLK]~~
Addr : 3108:       C4 84 D4  : Memory Op Long PBASE + READ Address = 04D4
Addr : 310B:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
352                          r += r + ina[pinDO]
Addr : 310E:             60  : Variable Operation Local Offset - 0 Read
Addr : 310F:       C4 84 D0  : Memory Op Long PBASE + READ Address = 04D0
Addr : 3112:          3D 92  : Register [Bit] op INA Read
Addr : 3114:             EC  : Math Op +     
Addr : 3115:          62 4C  : Variable Operation Local Offset - 0 Assign WordMathop +
Addr : 3117: Label0003
Addr : 3117: DJNZ Label0002
Addr : 3117:          09 69  : djnz Address = 3102 -23
Addr : 3119: Label0004
354                        if( (cnt - SPI_block_index) > (clkfreq << 2) )
Addr : 3119:          3F 91  : Register op CNT Read
Addr : 311B:          C4 34  : Memory Op Long PBASE + READ Address = 0034
Addr : 311D:             ED  : Math Op -     
Addr : 311E:             35  : Constant 1 $00000000
Addr : 311F:             C0  : Memory Op Long POP Address READ 
Addr : 3120:          37 00  : Constant Mask Y=0 00000002 2
Addr : 3122:             E3  : Math Op <<    
Addr : 3123:             FA  : Math Op >     
Addr : 3124: JZ Label0005
Addr : 3124:          0A 07  : jz Address = 312D 7
355                          crash( ERR_CARD_BUSY_TIMEOUT )
Addr : 3126:             01  : Drop Anchor   
Addr : 3127:       39 03 E7  : Constant 2 Bytes - 03 E7 - $000003E7 999
Addr : 312A:             E7  : Math Op !     
Addr : 312B:          05 06  : Call Sub 6    
Addr : 312D: Label0005
Addr : 312D: Label0006
Addr : 312D:             32  : Return        
